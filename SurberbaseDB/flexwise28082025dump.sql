--
-- PostgreSQL database dump
--

-- Dumped from database version 15.8
-- Dumped by pg_dump version 16.9 (Ubuntu 16.9-0ubuntu0.24.04.1)

SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;

--
-- Name: Just table; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA "Just table";


ALTER SCHEMA "Just table" OWNER TO postgres;

--
-- Name: _realtime; Type: SCHEMA; Schema: -; Owner: supabase_admin
--

CREATE SCHEMA _realtime;


ALTER SCHEMA _realtime OWNER TO supabase_admin;

--
-- Name: auth; Type: SCHEMA; Schema: -; Owner: supabase_admin
--

CREATE SCHEMA auth;


ALTER SCHEMA auth OWNER TO supabase_admin;

--
-- Name: extensions; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA extensions;


ALTER SCHEMA extensions OWNER TO postgres;

--
-- Name: graphql; Type: SCHEMA; Schema: -; Owner: supabase_admin
--

CREATE SCHEMA graphql;


ALTER SCHEMA graphql OWNER TO supabase_admin;

--
-- Name: graphql_public; Type: SCHEMA; Schema: -; Owner: supabase_admin
--

CREATE SCHEMA graphql_public;


ALTER SCHEMA graphql_public OWNER TO supabase_admin;

--
-- Name: pg_net; Type: EXTENSION; Schema: -; Owner: -
--

CREATE EXTENSION IF NOT EXISTS pg_net WITH SCHEMA extensions;


--
-- Name: EXTENSION pg_net; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION pg_net IS 'Async HTTP';


--
-- Name: pgbouncer; Type: SCHEMA; Schema: -; Owner: pgbouncer
--

CREATE SCHEMA pgbouncer;


ALTER SCHEMA pgbouncer OWNER TO pgbouncer;

--
-- Name: realtime; Type: SCHEMA; Schema: -; Owner: supabase_admin
--

CREATE SCHEMA realtime;


ALTER SCHEMA realtime OWNER TO supabase_admin;

--
-- Name: storage; Type: SCHEMA; Schema: -; Owner: supabase_admin
--

CREATE SCHEMA storage;


ALTER SCHEMA storage OWNER TO supabase_admin;

--
-- Name: supabase_functions; Type: SCHEMA; Schema: -; Owner: supabase_admin
--

CREATE SCHEMA supabase_functions;


ALTER SCHEMA supabase_functions OWNER TO supabase_admin;

--
-- Name: vault; Type: SCHEMA; Schema: -; Owner: supabase_admin
--

CREATE SCHEMA vault;


ALTER SCHEMA vault OWNER TO supabase_admin;

--
-- Name: pg_graphql; Type: EXTENSION; Schema: -; Owner: -
--

CREATE EXTENSION IF NOT EXISTS pg_graphql WITH SCHEMA graphql;


--
-- Name: EXTENSION pg_graphql; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION pg_graphql IS 'pg_graphql: GraphQL support';


--
-- Name: pg_stat_statements; Type: EXTENSION; Schema: -; Owner: -
--

CREATE EXTENSION IF NOT EXISTS pg_stat_statements WITH SCHEMA extensions;


--
-- Name: EXTENSION pg_stat_statements; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION pg_stat_statements IS 'track planning and execution statistics of all SQL statements executed';


--
-- Name: pgaudit; Type: EXTENSION; Schema: -; Owner: -
--

CREATE EXTENSION IF NOT EXISTS pgaudit WITH SCHEMA public;


--
-- Name: EXTENSION pgaudit; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION pgaudit IS 'provides auditing functionality';


--
-- Name: pgcrypto; Type: EXTENSION; Schema: -; Owner: -
--

CREATE EXTENSION IF NOT EXISTS pgcrypto WITH SCHEMA extensions;


--
-- Name: EXTENSION pgcrypto; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION pgcrypto IS 'cryptographic functions';


--
-- Name: pgjwt; Type: EXTENSION; Schema: -; Owner: -
--

CREATE EXTENSION IF NOT EXISTS pgjwt WITH SCHEMA extensions;


--
-- Name: EXTENSION pgjwt; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION pgjwt IS 'JSON Web Token API for Postgresql';


--
-- Name: supabase_vault; Type: EXTENSION; Schema: -; Owner: -
--

CREATE EXTENSION IF NOT EXISTS supabase_vault WITH SCHEMA vault;


--
-- Name: EXTENSION supabase_vault; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION supabase_vault IS 'Supabase Vault Extension';


--
-- Name: uuid-ossp; Type: EXTENSION; Schema: -; Owner: -
--

CREATE EXTENSION IF NOT EXISTS "uuid-ossp" WITH SCHEMA extensions;


--
-- Name: EXTENSION "uuid-ossp"; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION "uuid-ossp" IS 'generate universally unique identifiers (UUIDs)';


--
-- Name: aal_level; Type: TYPE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TYPE auth.aal_level AS ENUM (
    'aal1',
    'aal2',
    'aal3'
);


ALTER TYPE auth.aal_level OWNER TO supabase_auth_admin;

--
-- Name: code_challenge_method; Type: TYPE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TYPE auth.code_challenge_method AS ENUM (
    's256',
    'plain'
);


ALTER TYPE auth.code_challenge_method OWNER TO supabase_auth_admin;

--
-- Name: factor_status; Type: TYPE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TYPE auth.factor_status AS ENUM (
    'unverified',
    'verified'
);


ALTER TYPE auth.factor_status OWNER TO supabase_auth_admin;

--
-- Name: factor_type; Type: TYPE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TYPE auth.factor_type AS ENUM (
    'totp',
    'webauthn',
    'phone'
);


ALTER TYPE auth.factor_type OWNER TO supabase_auth_admin;

--
-- Name: one_time_token_type; Type: TYPE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TYPE auth.one_time_token_type AS ENUM (
    'confirmation_token',
    'reauthentication_token',
    'recovery_token',
    'email_change_token_new',
    'email_change_token_current',
    'phone_change_token'
);


ALTER TYPE auth.one_time_token_type OWNER TO supabase_auth_admin;

--
-- Name: account_status_enum; Type: TYPE; Schema: public; Owner: supabase_admin
--

CREATE TYPE public.account_status_enum AS ENUM (
    'none',
    'created',
    'invited',
    'active',
    'inactive',
    'expired',
    'suspended',
    'deleted'
);


ALTER TYPE public.account_status_enum OWNER TO supabase_admin;

--
-- Name: attendance_status; Type: TYPE; Schema: public; Owner: supabase_admin
--

CREATE TYPE public.attendance_status AS ENUM (
    'present',
    'late',
    'absent_unexcused',
    'absent_excused',
    'left_early'
);


ALTER TYPE public.attendance_status OWNER TO supabase_admin;

--
-- Name: presence_event_type; Type: TYPE; Schema: public; Owner: supabase_admin
--

CREATE TYPE public.presence_event_type AS ENUM (
    'check_in',
    'check_out',
    'temporary_exit',
    'temporary_return',
    'manual_edit'
);


ALTER TYPE public.presence_event_type OWNER TO supabase_admin;

--
-- Name: presence_status; Type: TYPE; Schema: public; Owner: supabase_admin
--

CREATE TYPE public.presence_status AS ENUM (
    'present',
    'absent_unexcused',
    'absent_excused',
    'unmarked',
    'left_early',
    'left_without_notice',
    'temporarily_offsite',
    'late',
    'partial'
);


ALTER TYPE public.presence_status OWNER TO supabase_admin;

--
-- Name: subject_type_enum; Type: TYPE; Schema: public; Owner: supabase_admin
--

CREATE TYPE public.subject_type_enum AS ENUM (
    'school_subject',
    'module_subject',
    'termin'
);


ALTER TYPE public.subject_type_enum OWNER TO supabase_admin;

--
-- Name: action; Type: TYPE; Schema: realtime; Owner: supabase_admin
--

CREATE TYPE realtime.action AS ENUM (
    'INSERT',
    'UPDATE',
    'DELETE',
    'TRUNCATE',
    'ERROR'
);


ALTER TYPE realtime.action OWNER TO supabase_admin;

--
-- Name: equality_op; Type: TYPE; Schema: realtime; Owner: supabase_admin
--

CREATE TYPE realtime.equality_op AS ENUM (
    'eq',
    'neq',
    'lt',
    'lte',
    'gt',
    'gte',
    'in'
);


ALTER TYPE realtime.equality_op OWNER TO supabase_admin;

--
-- Name: user_defined_filter; Type: TYPE; Schema: realtime; Owner: supabase_admin
--

CREATE TYPE realtime.user_defined_filter AS (
	column_name text,
	op realtime.equality_op,
	value text
);


ALTER TYPE realtime.user_defined_filter OWNER TO supabase_admin;

--
-- Name: wal_column; Type: TYPE; Schema: realtime; Owner: supabase_admin
--

CREATE TYPE realtime.wal_column AS (
	name text,
	type_name text,
	type_oid oid,
	value jsonb,
	is_pkey boolean,
	is_selectable boolean
);


ALTER TYPE realtime.wal_column OWNER TO supabase_admin;

--
-- Name: wal_rls; Type: TYPE; Schema: realtime; Owner: supabase_admin
--

CREATE TYPE realtime.wal_rls AS (
	wal jsonb,
	is_rls_enabled boolean,
	subscription_ids uuid[],
	errors text[]
);


ALTER TYPE realtime.wal_rls OWNER TO supabase_admin;

--
-- Name: email(); Type: FUNCTION; Schema: auth; Owner: supabase_auth_admin
--

CREATE FUNCTION auth.email() RETURNS text
    LANGUAGE sql STABLE
    AS $$
  select 
  coalesce(
    nullif(current_setting('request.jwt.claim.email', true), ''),
    (nullif(current_setting('request.jwt.claims', true), '')::jsonb ->> 'email')
  )::text
$$;


ALTER FUNCTION auth.email() OWNER TO supabase_auth_admin;

--
-- Name: FUNCTION email(); Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON FUNCTION auth.email() IS 'Deprecated. Use auth.jwt() -> ''email'' instead.';


--
-- Name: get_accessible_children(); Type: FUNCTION; Schema: auth; Owner: supabase_admin
--

CREATE FUNCTION auth.get_accessible_children() RETURNS uuid[]
    LANGUAGE sql STABLE SECURITY DEFINER
    AS $$
    SELECT ARRAY(
        SELECT child_profile_id
        FROM public.family_member_child_links
        WHERE adult_profile_id = auth.get_profile_id()
        AND access_restricted = false
    );
$$;


ALTER FUNCTION auth.get_accessible_children() OWNER TO supabase_admin;

--
-- Name: get_accessible_class_ids(); Type: FUNCTION; Schema: auth; Owner: supabase_admin
--

CREATE FUNCTION auth.get_accessible_class_ids() RETURNS uuid[]
    LANGUAGE sql STABLE SECURITY DEFINER
    AS $$
    SELECT ARRAY(
        -- Get user's direct school classes (for staff)
        SELECT id FROM public.structure_classes 
        WHERE school_id = (
            SELECT school_id FROM public.user_profiles 
            WHERE id = auth.get_profile_id()
        )
        
        UNION
        
        -- Get classes that user's accessible children are in (for parents)
        SELECT DISTINCT ps.class_id
        FROM public.profile_info_student ps
        WHERE ps.profile_id = ANY(auth.get_accessible_children())
        AND ps.class_id IS NOT NULL
    );
$$;


ALTER FUNCTION auth.get_accessible_class_ids() OWNER TO supabase_admin;

--
-- Name: get_current_user_school_id(); Type: FUNCTION; Schema: auth; Owner: supabase_admin
--

CREATE FUNCTION auth.get_current_user_school_id() RETURNS uuid
    LANGUAGE sql STABLE SECURITY DEFINER
    AS $$
  SELECT COALESCE(
    -- Try to get from user_profiles table (using 'id' not 'user_id')
    (SELECT school_id FROM public.user_profiles WHERE id = auth.uid()),
    -- Fallback to user metadata
    (auth.jwt() ->> 'school_id')::UUID,
    -- Parse from email domain if structured (optional)
    NULL
  );
$$;


ALTER FUNCTION auth.get_current_user_school_id() OWNER TO supabase_admin;

--
-- Name: get_profile_id(); Type: FUNCTION; Schema: auth; Owner: supabase_admin
--

CREATE FUNCTION auth.get_profile_id() RETURNS uuid
    LANGUAGE sql STABLE SECURITY DEFINER
    AS $$
    SELECT CASE 
        WHEN auth.jwt() IS NOT NULL 
        AND auth.jwt() -> 'user_metadata' IS NOT NULL 
        AND auth.jwt() -> 'user_metadata' ->> 'profile_id' IS NOT NULL
        THEN (auth.jwt() -> 'user_metadata' ->> 'profile_id')::uuid
        ELSE NULL
    END;
$$;


ALTER FUNCTION auth.get_profile_id() OWNER TO supabase_admin;

--
-- Name: get_user_family_ids(); Type: FUNCTION; Schema: auth; Owner: supabase_admin
--

CREATE FUNCTION auth.get_user_family_ids() RETURNS uuid[]
    LANGUAGE sql STABLE SECURITY DEFINER
    AS $$
    SELECT ARRAY(
        SELECT DISTINCT family_id 
        FROM public.family_member_child_links 
        WHERE adult_profile_id = auth.get_profile_id()
        AND access_restricted = false
    );
$$;


ALTER FUNCTION auth.get_user_family_ids() OWNER TO supabase_admin;

--
-- Name: get_user_role(); Type: FUNCTION; Schema: auth; Owner: supabase_admin
--

CREATE FUNCTION auth.get_user_role() RETURNS text
    LANGUAGE sql STABLE SECURITY DEFINER
    AS $$
    SELECT r.name 
    FROM public.user_roles ur
    JOIN public.roles r ON r.id = ur.role_id
    WHERE ur.user_profile_id = auth.get_profile_id()
    LIMIT 1;
$$;


ALTER FUNCTION auth.get_user_role() OWNER TO supabase_admin;

--
-- Name: get_user_school_id(); Type: FUNCTION; Schema: auth; Owner: supabase_admin
--

CREATE FUNCTION auth.get_user_school_id() RETURNS uuid
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    AS $$
BEGIN
  -- Return NULL if no authenticated user
  IF auth.uid() IS NULL THEN 
    RETURN NULL; 
  END IF;
  
  -- Get school_id from user_profiles
  RETURN (SELECT school_id FROM public.user_profiles WHERE id = auth.uid());
END;
$$;


ALTER FUNCTION auth.get_user_school_id() OWNER TO supabase_admin;

--
-- Name: get_user_school_id_safe(); Type: FUNCTION; Schema: auth; Owner: supabase_admin
--

CREATE FUNCTION auth.get_user_school_id_safe() RETURNS uuid
    LANGUAGE sql STABLE SECURITY DEFINER
    AS $$
    -- This function bypasses RLS to avoid recursion
    SELECT school_id 
    FROM public.user_profiles 
    WHERE id = auth.get_profile_id();
$$;


ALTER FUNCTION auth.get_user_school_id_safe() OWNER TO supabase_admin;

--
-- Name: jwt(); Type: FUNCTION; Schema: auth; Owner: supabase_auth_admin
--

CREATE FUNCTION auth.jwt() RETURNS jsonb
    LANGUAGE sql STABLE
    AS $$
  select 
    coalesce(
        nullif(current_setting('request.jwt.claim', true), ''),
        nullif(current_setting('request.jwt.claims', true), '')
    )::jsonb
$$;


ALTER FUNCTION auth.jwt() OWNER TO supabase_auth_admin;

--
-- Name: role(); Type: FUNCTION; Schema: auth; Owner: supabase_auth_admin
--

CREATE FUNCTION auth.role() RETURNS text
    LANGUAGE sql STABLE
    AS $$
  select 
  coalesce(
    nullif(current_setting('request.jwt.claim.role', true), ''),
    (nullif(current_setting('request.jwt.claims', true), '')::jsonb ->> 'role')
  )::text
$$;


ALTER FUNCTION auth.role() OWNER TO supabase_auth_admin;

--
-- Name: FUNCTION role(); Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON FUNCTION auth.role() IS 'Deprecated. Use auth.jwt() -> ''role'' instead.';


--
-- Name: uid(); Type: FUNCTION; Schema: auth; Owner: supabase_auth_admin
--

CREATE FUNCTION auth.uid() RETURNS uuid
    LANGUAGE sql STABLE
    AS $$
  SELECT CASE 
    WHEN COALESCE(
      NULLIF(current_setting('app.current_user_id', true), ''),
      NULLIF((current_setting('request.jwt.claims', true)::jsonb ->> 'user_metadata')::jsonb ->> 'profile_id', '')
    ) IS NOT NULL THEN
      COALESCE(
        NULLIF(current_setting('app.current_user_id', true), ''),
        NULLIF((current_setting('request.jwt.claims', true)::jsonb ->> 'user_metadata')::jsonb ->> 'profile_id', '')
      )::uuid
    ELSE NULL
  END;
$$;


ALTER FUNCTION auth.uid() OWNER TO supabase_auth_admin;

--
-- Name: FUNCTION uid(); Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON FUNCTION auth.uid() IS 'Deprecated. Use auth.jwt() -> ''sub'' instead.';


--
-- Name: grant_pg_cron_access(); Type: FUNCTION; Schema: extensions; Owner: postgres
--

CREATE FUNCTION extensions.grant_pg_cron_access() RETURNS event_trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  IF EXISTS (
    SELECT
    FROM pg_event_trigger_ddl_commands() AS ev
    JOIN pg_extension AS ext
    ON ev.objid = ext.oid
    WHERE ext.extname = 'pg_cron'
  )
  THEN
    grant usage on schema cron to postgres with grant option;

    alter default privileges in schema cron grant all on tables to postgres with grant option;
    alter default privileges in schema cron grant all on functions to postgres with grant option;
    alter default privileges in schema cron grant all on sequences to postgres with grant option;

    alter default privileges for user supabase_admin in schema cron grant all
        on sequences to postgres with grant option;
    alter default privileges for user supabase_admin in schema cron grant all
        on tables to postgres with grant option;
    alter default privileges for user supabase_admin in schema cron grant all
        on functions to postgres with grant option;

    grant all privileges on all tables in schema cron to postgres with grant option;
    revoke all on table cron.job from postgres;
    grant select on table cron.job to postgres with grant option;
  END IF;
END;
$$;


ALTER FUNCTION extensions.grant_pg_cron_access() OWNER TO postgres;

--
-- Name: FUNCTION grant_pg_cron_access(); Type: COMMENT; Schema: extensions; Owner: postgres
--

COMMENT ON FUNCTION extensions.grant_pg_cron_access() IS 'Grants access to pg_cron';


--
-- Name: grant_pg_graphql_access(); Type: FUNCTION; Schema: extensions; Owner: supabase_admin
--

CREATE FUNCTION extensions.grant_pg_graphql_access() RETURNS event_trigger
    LANGUAGE plpgsql
    AS $_$
DECLARE
    func_is_graphql_resolve bool;
BEGIN
    func_is_graphql_resolve = (
        SELECT n.proname = 'resolve'
        FROM pg_event_trigger_ddl_commands() AS ev
        LEFT JOIN pg_catalog.pg_proc AS n
        ON ev.objid = n.oid
    );

    IF func_is_graphql_resolve
    THEN
        -- Update public wrapper to pass all arguments through to the pg_graphql resolve func
        DROP FUNCTION IF EXISTS graphql_public.graphql;
        create or replace function graphql_public.graphql(
            "operationName" text default null,
            query text default null,
            variables jsonb default null,
            extensions jsonb default null
        )
            returns jsonb
            language sql
        as $$
            select graphql.resolve(
                query := query,
                variables := coalesce(variables, '{}'),
                "operationName" := "operationName",
                extensions := extensions
            );
        $$;

        -- This hook executes when `graphql.resolve` is created. That is not necessarily the last
        -- function in the extension so we need to grant permissions on existing entities AND
        -- update default permissions to any others that are created after `graphql.resolve`
        grant usage on schema graphql to postgres, anon, authenticated, service_role;
        grant select on all tables in schema graphql to postgres, anon, authenticated, service_role;
        grant execute on all functions in schema graphql to postgres, anon, authenticated, service_role;
        grant all on all sequences in schema graphql to postgres, anon, authenticated, service_role;
        alter default privileges in schema graphql grant all on tables to postgres, anon, authenticated, service_role;
        alter default privileges in schema graphql grant all on functions to postgres, anon, authenticated, service_role;
        alter default privileges in schema graphql grant all on sequences to postgres, anon, authenticated, service_role;

        -- Allow postgres role to allow granting usage on graphql and graphql_public schemas to custom roles
        grant usage on schema graphql_public to postgres with grant option;
        grant usage on schema graphql to postgres with grant option;
    END IF;

END;
$_$;


ALTER FUNCTION extensions.grant_pg_graphql_access() OWNER TO supabase_admin;

--
-- Name: FUNCTION grant_pg_graphql_access(); Type: COMMENT; Schema: extensions; Owner: supabase_admin
--

COMMENT ON FUNCTION extensions.grant_pg_graphql_access() IS 'Grants access to pg_graphql';


--
-- Name: grant_pg_net_access(); Type: FUNCTION; Schema: extensions; Owner: postgres
--

CREATE FUNCTION extensions.grant_pg_net_access() RETURNS event_trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  IF EXISTS (
    SELECT 1
    FROM pg_event_trigger_ddl_commands() AS ev
    JOIN pg_extension AS ext
    ON ev.objid = ext.oid
    WHERE ext.extname = 'pg_net'
  )
  THEN
    IF NOT EXISTS (
      SELECT 1
      FROM pg_roles
      WHERE rolname = 'supabase_functions_admin'
    )
    THEN
      CREATE USER supabase_functions_admin NOINHERIT CREATEROLE LOGIN NOREPLICATION;
    END IF;

    GRANT USAGE ON SCHEMA net TO supabase_functions_admin, postgres, anon, authenticated, service_role;

    IF EXISTS (
      SELECT FROM pg_extension
      WHERE extname = 'pg_net'
      -- all versions in use on existing projects as of 2025-02-20
      -- version 0.12.0 onwards don't need these applied
      AND extversion IN ('0.2', '0.6', '0.7', '0.7.1', '0.8', '0.10.0', '0.11.0')
    ) THEN
      ALTER function net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) SECURITY DEFINER;
      ALTER function net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) SECURITY DEFINER;

      ALTER function net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) SET search_path = net;
      ALTER function net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) SET search_path = net;

      REVOKE ALL ON FUNCTION net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) FROM PUBLIC;
      REVOKE ALL ON FUNCTION net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) FROM PUBLIC;

      GRANT EXECUTE ON FUNCTION net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) TO supabase_functions_admin, postgres, anon, authenticated, service_role;
      GRANT EXECUTE ON FUNCTION net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) TO supabase_functions_admin, postgres, anon, authenticated, service_role;
    END IF;
  END IF;
END;
$$;


ALTER FUNCTION extensions.grant_pg_net_access() OWNER TO postgres;

--
-- Name: FUNCTION grant_pg_net_access(); Type: COMMENT; Schema: extensions; Owner: postgres
--

COMMENT ON FUNCTION extensions.grant_pg_net_access() IS 'Grants access to pg_net';


--
-- Name: pgrst_ddl_watch(); Type: FUNCTION; Schema: extensions; Owner: supabase_admin
--

CREATE FUNCTION extensions.pgrst_ddl_watch() RETURNS event_trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  cmd record;
BEGIN
  FOR cmd IN SELECT * FROM pg_event_trigger_ddl_commands()
  LOOP
    IF cmd.command_tag IN (
      'CREATE SCHEMA', 'ALTER SCHEMA'
    , 'CREATE TABLE', 'CREATE TABLE AS', 'SELECT INTO', 'ALTER TABLE'
    , 'CREATE FOREIGN TABLE', 'ALTER FOREIGN TABLE'
    , 'CREATE VIEW', 'ALTER VIEW'
    , 'CREATE MATERIALIZED VIEW', 'ALTER MATERIALIZED VIEW'
    , 'CREATE FUNCTION', 'ALTER FUNCTION'
    , 'CREATE TRIGGER'
    , 'CREATE TYPE', 'ALTER TYPE'
    , 'CREATE RULE'
    , 'COMMENT'
    )
    -- don't notify in case of CREATE TEMP table or other objects created on pg_temp
    AND cmd.schema_name is distinct from 'pg_temp'
    THEN
      NOTIFY pgrst, 'reload schema';
    END IF;
  END LOOP;
END; $$;


ALTER FUNCTION extensions.pgrst_ddl_watch() OWNER TO supabase_admin;

--
-- Name: pgrst_drop_watch(); Type: FUNCTION; Schema: extensions; Owner: supabase_admin
--

CREATE FUNCTION extensions.pgrst_drop_watch() RETURNS event_trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  obj record;
BEGIN
  FOR obj IN SELECT * FROM pg_event_trigger_dropped_objects()
  LOOP
    IF obj.object_type IN (
      'schema'
    , 'table'
    , 'foreign table'
    , 'view'
    , 'materialized view'
    , 'function'
    , 'trigger'
    , 'type'
    , 'rule'
    )
    AND obj.is_temporary IS false -- no pg_temp objects
    THEN
      NOTIFY pgrst, 'reload schema';
    END IF;
  END LOOP;
END; $$;


ALTER FUNCTION extensions.pgrst_drop_watch() OWNER TO supabase_admin;

--
-- Name: set_graphql_placeholder(); Type: FUNCTION; Schema: extensions; Owner: supabase_admin
--

CREATE FUNCTION extensions.set_graphql_placeholder() RETURNS event_trigger
    LANGUAGE plpgsql
    AS $_$
    DECLARE
    graphql_is_dropped bool;
    BEGIN
    graphql_is_dropped = (
        SELECT ev.schema_name = 'graphql_public'
        FROM pg_event_trigger_dropped_objects() AS ev
        WHERE ev.schema_name = 'graphql_public'
    );

    IF graphql_is_dropped
    THEN
        create or replace function graphql_public.graphql(
            "operationName" text default null,
            query text default null,
            variables jsonb default null,
            extensions jsonb default null
        )
            returns jsonb
            language plpgsql
        as $$
            DECLARE
                server_version float;
            BEGIN
                server_version = (SELECT (SPLIT_PART((select version()), ' ', 2))::float);

                IF server_version >= 14 THEN
                    RETURN jsonb_build_object(
                        'errors', jsonb_build_array(
                            jsonb_build_object(
                                'message', 'pg_graphql extension is not enabled.'
                            )
                        )
                    );
                ELSE
                    RETURN jsonb_build_object(
                        'errors', jsonb_build_array(
                            jsonb_build_object(
                                'message', 'pg_graphql is only available on projects running Postgres 14 onwards.'
                            )
                        )
                    );
                END IF;
            END;
        $$;
    END IF;

    END;
$_$;


ALTER FUNCTION extensions.set_graphql_placeholder() OWNER TO supabase_admin;

--
-- Name: FUNCTION set_graphql_placeholder(); Type: COMMENT; Schema: extensions; Owner: supabase_admin
--

COMMENT ON FUNCTION extensions.set_graphql_placeholder() IS 'Reintroduces placeholder function for graphql_public.graphql';


--
-- Name: get_auth(text); Type: FUNCTION; Schema: pgbouncer; Owner: supabase_admin
--

CREATE FUNCTION pgbouncer.get_auth(p_usename text) RETURNS TABLE(username text, password text)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
    RAISE WARNING 'PgBouncer auth request: %', p_usename;

    RETURN QUERY
    SELECT usename::TEXT, passwd::TEXT FROM pg_catalog.pg_shadow
    WHERE usename = p_usename;
END;
$$;


ALTER FUNCTION pgbouncer.get_auth(p_usename text) OWNER TO supabase_admin;

--
-- Name: add_course_note(text, text, text, text, integer, text, text, boolean); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.add_course_note(p_course_id text, p_school_id text, p_registration_period_id text, p_semester_id text, p_day_of_week integer, p_text text, p_author text DEFAULT 'Admin'::text, p_is_problem boolean DEFAULT false) RETURNS json
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  new_note_id UUID;
BEGIN
  -- Insert the new note
  INSERT INTO course_notes (
    course_id, school_id, registration_period_id, semester_id,
    day_of_week, text, author, is_problem
  ) VALUES (
    p_course_id, p_school_id, p_registration_period_id, p_semester_id,
    p_day_of_week, p_text, p_author, p_is_problem
  ) RETURNING id INTO new_note_id;

  RETURN json_build_object(
    'ok', true,
    'note_id', new_note_id,
    'message', 'Note added successfully'
  );
EXCEPTION WHEN OTHERS THEN
  RETURN json_build_object(
    'ok', false,
    'error', SQLERRM
  );
END;
$$;


ALTER FUNCTION public.add_course_note(p_course_id text, p_school_id text, p_registration_period_id text, p_semester_id text, p_day_of_week integer, p_text text, p_author text, p_is_problem boolean) OWNER TO supabase_admin;

--
-- Name: add_family_contact_for_all_children(uuid, text, text, text, boolean, uuid); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.add_family_contact_for_all_children(in_family_id uuid, in_first_name text, in_last_name text, in_relationship text, in_authorized_for_pickup boolean DEFAULT false, in_user_id uuid DEFAULT NULL::uuid) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
declare
  new_profile_id uuid;
  school_id uuid;
  student_id uuid;
begin
  -- Get school_id from any child
  select s.school_id into school_id
  from profile_info_student s
  join family_members fm on fm.profile_id = s.profile_id
  where fm.family_id = in_family_id
    and fm.role = 'student'
  limit 1;

  -- Create the contact (no auth account)
  insert into user_profiles (
    first_name,
    last_name,
    school_id,
    role_id
  )
  select
    in_first_name,
    in_last_name,
    school_id,
    r.id
  from roles r
  where r.name = 'parent'
  returning id into new_profile_id;

  -- Link contact to family
  insert into family_members (
    family_id,
    profile_id,
    role,
    is_primary_guardian
  )
  values (
    in_family_id,
    new_profile_id,
    'parent',
    false
  );

  -- Loop through all children and create child links
  for student_id in
    select profile_id from family_members
    where family_id = in_family_id and role = 'student'
  loop
    insert into family_member_child_links (
      family_id,
      adult_profile_id,
      child_profile_id,
      relationship,
      authorized_for_pickup
    )
    values (
      in_family_id,
      new_profile_id,
      student_id,
      in_relationship,
      in_authorized_for_pickup
    );
  end loop;

  return new_profile_id;
end;
$$;


ALTER FUNCTION public.add_family_contact_for_all_children(in_family_id uuid, in_first_name text, in_last_name text, in_relationship text, in_authorized_for_pickup boolean, in_user_id uuid) OWNER TO supabase_admin;

--
-- Name: add_family_contact_for_all_children(uuid, text, text, text, text, boolean); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.add_family_contact_for_all_children(_family_id uuid, _first_name text, _last_name text, _phone text, _relationship text, _authorized_for_pickup boolean) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
declare
  v_new_profile_id uuid;
  v_parent_role_id uuid;
  v_family_school_id uuid;
  v_student_record record;
begin
  -- Get family's school_id from any student in the family
  select s.school_id into v_family_school_id
  from family_members fm
  join profile_info_student s on s.profile_id = fm.profile_id
  where fm.family_id = _family_id
    and fm.role = 'student'
    and fm.removed_at is null
  limit 1;
  
  if v_family_school_id is null then
    raise exception 'Family not found or no students in family: %', _family_id;
  end if;

  -- Get Parent role ID
  select id into v_parent_role_id
  from roles
  where name = 'Parent'
  limit 1;

  if v_parent_role_id is null then
    raise exception 'Parent role not found in roles table';
  end if;

  -- Create user profile (parent without login)
  insert into user_profiles (
    first_name, 
    last_name, 
    school_id, 
    role_id, 
    account_status
  )
  values (
    _first_name, 
    _last_name, 
    v_family_school_id, 
    v_parent_role_id, 
    'none'
  )
  returning id into v_new_profile_id;

  -- Add user role
  insert into user_roles (user_profile_id, role_id)
  values (v_new_profile_id, v_parent_role_id)
  on conflict (user_profile_id, role_id) do nothing;

  -- Add phone contact
  insert into contacts (
    profile_id,
    profile_type,
    type,
    value,
    is_primary,
    notes,
    is_linked_to_user_login
  )
  values (
    v_new_profile_id,
    'parent',
    'phone',
    _phone,
    true,
    'Manual family contact',
    false
  );

  -- Link to family
  insert into family_members (
    family_id,
    profile_id,
    role,
    relation_description,
    is_primary_guardian,
    is_primary_contact,
    notes
  )
  values (
    _family_id,
    v_new_profile_id,
    'parent',
    _relationship,
    false,
    false,
    'Manual family contact'
  );

  -- Create pickup authorization links for all students in the family
  for v_student_record in 
    select fm.profile_id as student_id
    from family_members fm
    where fm.family_id = _family_id
      and fm.role = 'student'
      and fm.removed_at is null
  loop
    insert into family_member_child_links (
      family_id,
      adult_profile_id,
      child_profile_id,
      relationship,
      authorized_for_pickup
    )
    values (
      _family_id,
      v_new_profile_id,
      v_student_record.student_id,
      _relationship,
      _authorized_for_pickup
    )
    on conflict (family_id, adult_profile_id, child_profile_id) do update
    set 
      relationship = excluded.relationship,
      authorized_for_pickup = excluded.authorized_for_pickup;
  end loop;

  return v_new_profile_id;
end;
$$;


ALTER FUNCTION public.add_family_contact_for_all_children(_family_id uuid, _first_name text, _last_name text, _phone text, _relationship text, _authorized_for_pickup boolean) OWNER TO supabase_admin;

--
-- Name: add_family_contact_for_all_children(uuid, text, text, text, text, boolean, jsonb); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.add_family_contact_for_all_children(_family_id uuid, _first_name text, _last_name text, _phone text, _relationship text DEFAULT NULL::text, _authorized_for_pickup boolean DEFAULT NULL::boolean, _child_settings jsonb DEFAULT NULL::jsonb) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
declare
  v_new_profile_id uuid;
  v_parent_role_id uuid;
  v_family_school_id uuid;
  v_student_record record;
begin
  -- Get family's school_id from any student in the family
  select s.school_id into v_family_school_id
  from family_members fm
  join profile_info_student s on s.profile_id = fm.profile_id
  where fm.family_id = _family_id
    and fm.role = 'student'
    and fm.removed_at is null
  limit 1;
  
  if v_family_school_id is null then
    raise exception 'Family not found or no students in family: %', _family_id;
  end if;

  -- Get Parent role ID
  select id into v_parent_role_id
  from roles
  where name = 'Parent'
  limit 1;

  if v_parent_role_id is null then
    raise exception 'Parent role not found in roles table';
  end if;

  -- Create user profile (parent without login)
  insert into user_profiles (
    first_name, 
    last_name, 
    school_id, 
    role_id, 
    account_status
  )
  values (
    _first_name, 
    _last_name, 
    v_family_school_id, 
    v_parent_role_id, 
    'none'
  )
  returning id into v_new_profile_id;

  -- Add user role
  insert into user_roles (user_profile_id, role_id)
  values (v_new_profile_id, v_parent_role_id)
  on conflict (user_profile_id, role_id) do nothing;

  -- Add phone contact
  insert into contacts (
    profile_id,
    profile_type,
    type,
    value,
    is_primary,
    notes,
    is_linked_to_user_login
  )
  values (
    v_new_profile_id,
    'parent',
    'phone',
    _phone,
    true,
    'Manual family contact',
    false
  );

  -- Link to family (use primary relationship or default)
  insert into family_members (
    family_id,
    profile_id,
    role,
    relation_description,
    is_primary_guardian,
    is_primary_contact,
    notes
  )
  values (
    _family_id,
    v_new_profile_id,
    'parent',
    coalesce(_relationship, 'guardian'),
    false,
    false,
    'Manual family contact'
  );

  -- Create pickup authorization links for all students in the family
  for v_student_record in 
    select fm.profile_id as student_id
    from family_members fm
    where fm.family_id = _family_id
      and fm.role = 'student'
      and fm.removed_at is null
  loop
    declare
      v_child_relationship text;
      v_child_authorized boolean;
      v_child_setting jsonb;
    begin
      -- Check if individual child settings are provided
      if _child_settings is not null then
        -- Find settings for this specific child
        select value into v_child_setting
        from jsonb_array_elements(_child_settings) as value
        where (value->>'profile_id')::uuid = v_student_record.student_id;
        
        if v_child_setting is not null then
          -- Use individual child settings
          v_child_relationship := v_child_setting->>'relationship';
          v_child_authorized := (v_child_setting->>'auth')::boolean;
        else
          -- Fall back to default parameters if child not found in settings
          v_child_relationship := coalesce(_relationship, 'guardian');
          v_child_authorized := coalesce(_authorized_for_pickup, false);
        end if;
      else
        -- Use default parameters (backward compatibility)
        if _relationship is null or _authorized_for_pickup is null then
          raise exception 'Either provide _child_settings or both _relationship and _authorized_for_pickup parameters';
        end if;
        v_child_relationship := _relationship;
        v_child_authorized := _authorized_for_pickup;
      end if;
      
      insert into family_member_child_links (
        family_id,
        adult_profile_id,
        child_profile_id,
        relationship,
        authorized_for_pickup
      )
      values (
        _family_id,
        v_new_profile_id,
        v_student_record.student_id,
        v_child_relationship,
        v_child_authorized
      )
      on conflict (family_id, adult_profile_id, child_profile_id) do update
      set 
        relationship = excluded.relationship,
        authorized_for_pickup = excluded.authorized_for_pickup;
    end;
  end loop;

  return v_new_profile_id;
end;
$$;


ALTER FUNCTION public.add_family_contact_for_all_children(_family_id uuid, _first_name text, _last_name text, _phone text, _relationship text, _authorized_for_pickup boolean, _child_settings jsonb) OWNER TO supabase_admin;

--
-- Name: add_family_contact_for_student(uuid, uuid, text, text, text, boolean, uuid); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.add_family_contact_for_student(in_student_id uuid, in_family_id uuid, in_first_name text, in_last_name text, in_relationship text, in_authorized_for_pickup boolean DEFAULT false, in_user_id uuid DEFAULT NULL::uuid) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
declare
  new_profile_id uuid;
begin
  -- Create the contact (no auth account)
  insert into user_profiles (
    first_name,
    last_name,
    school_id,
    role_id
  )
  select
    in_first_name,
    in_last_name,
    s.school_id,
    r.id
  from profile_info_student s
  join roles r on r.name = 'parent'
  where s.profile_id = in_student_id
  returning id into new_profile_id;

  -- Link contact to family
  insert into family_members (
    family_id,
    profile_id,
    role,
    is_primary_guardian
  )
  values (
    in_family_id,
    new_profile_id,
    'parent',
    false
  );

  -- Create child link for only this student
  insert into family_member_child_links (
    family_id,
    adult_profile_id,
    child_profile_id,
    relationship,
    authorized_for_pickup
  )
  values (
    in_family_id,
    new_profile_id,
    in_student_id,
    in_relationship,
    in_authorized_for_pickup
  );

  return new_profile_id;
end;
$$;


ALTER FUNCTION public.add_family_contact_for_student(in_student_id uuid, in_family_id uuid, in_first_name text, in_last_name text, in_relationship text, in_authorized_for_pickup boolean, in_user_id uuid) OWNER TO supabase_admin;

--
-- Name: add_family_contact_for_student(uuid, uuid, text, text, text, text, boolean); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.add_family_contact_for_student(_student_id uuid, _family_id uuid, _first_name text, _last_name text, _phone text, _relationship text, _authorized_for_pickup boolean) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
declare
  v_new_profile_id uuid;
  v_parent_role_id uuid;
  v_student_school_id uuid;
begin
  -- Get student's school_id
  select school_id into v_student_school_id
  from profile_info_student
  where profile_id = _student_id;
  
  if v_student_school_id is null then
    raise exception 'Student not found or missing school_id: %', _student_id;
  end if;

  -- Get Parent role ID
  select id into v_parent_role_id
  from roles
  where name = 'Parent'
  limit 1;

  if v_parent_role_id is null then
    raise exception 'Parent role not found in roles table';
  end if;

  -- Create user profile (parent without login)
  insert into user_profiles (
    first_name, 
    last_name, 
    school_id, 
    role_id, 
    account_status
  )
  values (
    _first_name, 
    _last_name, 
    v_student_school_id, 
    v_parent_role_id, 
    'none'
  )
  returning id into v_new_profile_id;

  -- Add user role
  insert into user_roles (user_profile_id, role_id)
  values (v_new_profile_id, v_parent_role_id)
  on conflict (user_profile_id, role_id) do nothing;

  -- Add phone contact
  insert into contacts (
    profile_id,
    profile_type,
    type,
    value,
    is_primary,
    notes,
    is_linked_to_user_login
  )
  values (
    v_new_profile_id,
    'parent',
    'phone',
    _phone,
    true,
    'Manual family contact',
    false
  );

  -- Link to family
  insert into family_members (
    family_id,
    profile_id,
    role,
    relation_description,
    is_primary_guardian,
    is_primary_contact,
    notes
  )
  values (
    _family_id,
    v_new_profile_id,
    'parent',
    _relationship,
    false,
    false,
    'Manual family contact'
  );

  -- Create pickup authorization link
  insert into family_member_child_links (
    family_id,
    adult_profile_id,
    child_profile_id,
    relationship,
    authorized_for_pickup
  )
  values (
    _family_id,
    v_new_profile_id,
    _student_id,
    _relationship,
    _authorized_for_pickup
  )
  on conflict (family_id, adult_profile_id, child_profile_id) do update
  set 
    relationship = excluded.relationship,
    authorized_for_pickup = excluded.authorized_for_pickup;

  return v_new_profile_id;
end;
$$;


ALTER FUNCTION public.add_family_contact_for_student(_student_id uuid, _family_id uuid, _first_name text, _last_name text, _phone text, _relationship text, _authorized_for_pickup boolean) OWNER TO supabase_admin;

--
-- Name: add_main_email_contact(uuid, character varying); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.add_main_email_contact(p_profile_id uuid, p_email_value character varying) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    v_contact_id UUID;
    v_replacement_type VARCHAR(50);
BEGIN
    -- Check if the email address already exists for this profile
    SELECT id INTO v_contact_id
    FROM public.contacts
    WHERE profile_id = p_profile_id
      AND type = 'email'
      AND value = p_email_value;

    -- Determine replacement type for the note
    IF v_contact_id IS NULL THEN
        v_replacement_type := 'new login email';
    ELSE
        v_replacement_type := 'existing email';
    END IF;

    -- Set any existing login email for this profile to false and add replacement note
    UPDATE public.contacts
    SET is_linked_to_user_login = FALSE,
        notes = 'Replaced by ' || v_replacement_type || ': ' || p_email_value || ' on ' ||
          to_char(now(), 'YYYY-MM-DD HH24:MI')
    WHERE profile_id = p_profile_id
      AND type = 'email'
      AND is_linked_to_user_login = TRUE
      AND (v_contact_id IS NULL OR id != v_contact_id);

    -- Handle the specific action based on whether email exists
    IF v_contact_id IS NULL THEN
        -- If the email does NOT exist, insert a new contact and set it as login
        INSERT INTO public.contacts (profile_id, profile_type, type, value, is_linked_to_user_login)
        VALUES (p_profile_id, 'staff', 'email', p_email_value, TRUE);
    ELSE
        -- If the email already exists, set it as the login email
        UPDATE public.contacts
        SET is_linked_to_user_login = TRUE
        WHERE id = v_contact_id;
    END IF;
END;
$$;


ALTER FUNCTION public.add_main_email_contact(p_profile_id uuid, p_email_value character varying) OWNER TO supabase_admin;

--
-- Name: add_schedule_period(uuid, text, text, time without time zone, time without time zone, integer, text, text); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.add_schedule_period(p_school_id uuid, p_label text, p_group_label text, p_start_time time without time zone, p_end_time time without time zone, p_block_number integer, p_attendance_requirement text DEFAULT 'required'::text, p_block_type text DEFAULT 'instructional'::text) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_id uuid := gen_random_uuid();
BEGIN
  INSERT INTO schedule_periods(
    id,
    school_id,
    label,
    group_label,
    start_time,
    end_time,
    block_number,
    attendance_requirement,
    block_type
  )
  VALUES (
    v_id,
    p_school_id,
    p_label,
    p_group_label,
    p_start_time,
    p_end_time,
    p_block_number,
    p_attendance_requirement,
    p_block_type
  );
  RETURN v_id;
END;
$$;


ALTER FUNCTION public.add_schedule_period(p_school_id uuid, p_label text, p_group_label text, p_start_time time without time zone, p_end_time time without time zone, p_block_number integer, p_attendance_requirement text, p_block_type text) OWNER TO supabase_admin;

--
-- Name: add_student_absence(uuid, uuid, date, date, text, text, text, text, text); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.add_student_absence(p_student_id uuid, p_school_id uuid, p_start_date date, p_end_date date DEFAULT NULL::date, p_absence_type text DEFAULT 'unentschuldigt'::text, p_reason text DEFAULT ''::text, p_attachment_url text DEFAULT NULL::text, p_time_range text DEFAULT NULL::text, p_duration text DEFAULT 'Ganzer Tag'::text) RETURNS json
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    new_absence_id uuid;
    result json;
BEGIN
    -- Set end_date to start_date if not provided
    IF p_end_date IS NULL THEN
        p_end_date := p_start_date;
    END IF;
    
    -- Validate absence_type
    IF p_absence_type NOT IN ('krankgemeldet', 'unentschuldigt', 'beurlaubt', 'ungekl채rt', 'versp채tet') THEN
        RAISE EXCEPTION 'Invalid absence_type. Must be one of: krankgemeldet, unentschuldigt, beurlaubt, ungekl채rt, versp채tet';
    END IF;
    
    -- Insert new absence
    INSERT INTO student_absence_notes (
        student_id,
        school_id,
        created_by,
        start_date,
        end_date,
        absence_type,
        reason,
        attachment_url,
        status,
        is_excused,
        sensitive
    ) VALUES (
        p_student_id,
        p_school_id,
        auth.uid(),
        p_start_date,
        p_end_date,
        p_absence_type,
        p_reason,
        p_attachment_url,
        'pending',
        CASE 
            WHEN p_absence_type IN ('krankgemeldet', 'beurlaubt') THEN true 
            ELSE false 
        END,
        false
    ) RETURNING id INTO new_absence_id;
    
    -- Return success with new record data
    SELECT json_build_object(
        'success', true,
        'message', 'Absence added successfully',
        'data', json_build_object(
            'id', new_absence_id,
            'student_id', p_student_id,
            'start_date', p_start_date,
            'end_date', p_end_date,
            'absence_type', p_absence_type,
            'reason', p_reason,
            'duration', p_duration,
            'time_range', p_time_range
        )
    ) INTO result;
    
    RETURN result;
    
EXCEPTION
    WHEN OTHERS THEN
        RETURN json_build_object(
            'success', false,
            'error', SQLERRM,
            'message', 'Failed to add absence'
        );
END;
$$;


ALTER FUNCTION public.add_student_absence(p_student_id uuid, p_school_id uuid, p_start_date date, p_end_date date, p_absence_type text, p_reason text, p_attachment_url text, p_time_range text, p_duration text) OWNER TO supabase_admin;

--
-- Name: add_student_absence_with_times_and_recurrence(uuid, uuid, date, time without time zone, time without time zone, text, boolean, text, uuid, jsonb, text); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.add_student_absence_with_times_and_recurrence(p_student_id uuid, p_school_id uuid, p_absence_date date, p_from_time time without time zone, p_to_time time without time zone, p_reason text, p_excused boolean DEFAULT false, p_attachment_url text DEFAULT NULL::text, p_created_by uuid DEFAULT auth.uid(), p_recurrence jsonb DEFAULT NULL::jsonb, p_absence_status text DEFAULT 'unentschuldigt'::text) RETURNS TABLE(daily_log_id uuid, attendance_log_id uuid, absence_date date, lesson_uuid uuid, notes text, recurrence_id uuid, absence_note_id uuid)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_recurrence_id uuid;
  v_absence_note_id uuid;
  v_dates date[];
  v_date date;
  v_daily_log_id uuid;
  v_lesson RECORD;
  v_attendance_log_id uuid;
  v_note text;
  v_daily_status presence_status;
  v_lesson_status attendance_status;
  v_has_lessons_before boolean := false;
  v_has_lessons_after boolean := false;
  v_absence_type text;
  v_start_date date;
  v_end_date date;
BEGIN
  -- Debug logging
  INSERT INTO debug_logs (step, message) VALUES 
    ('add_student_absence_start', 
     format('Processing absence for student %s on %s from %s to %s with status %s', 
            p_student_id, p_absence_date, p_from_time, p_to_time, p_absence_status));

  -- RECURRENCE HANDLING: Proper workflow implementation
  IF p_recurrence IS NOT NULL THEN
    -- Step 1: Create recurrence definition
    INSERT INTO public.student_absence_recurrences(
      start_date, end_date, repeat_every_unit, repeat_every_number, week_days, monthly_text, created_by
    )
    VALUES (
      (p_recurrence->>'startDate')::date,
      (p_recurrence->>'endDate')::date,
      (p_recurrence->>'repeatEveryUnit')::text,
      COALESCE((p_recurrence->>'repeatEveryNumber')::smallint, 1),
      CASE WHEN jsonb_array_length(p_recurrence->'weekDays') > 0
           THEN ARRAY(SELECT jsonb_array_elements_text(p_recurrence->'weekDays')::smallint)
           ELSE NULL
      END,
      NULLIF(p_recurrence->>'monthlyText',''),
      p_created_by
    )
    RETURNING id INTO v_recurrence_id;

    -- Set absence details for recurring pattern
    v_absence_type := 'recurring';
    v_start_date := (p_recurrence->>'startDate')::date;
    v_end_date := (p_recurrence->>'endDate')::date;

    -- Step 2: Generate date array based on recurrence rules
    v_dates := ARRAY[]::date[];
    v_date := (p_recurrence->>'startDate')::date;
    WHILE v_date <= (p_recurrence->>'endDate')::date LOOP
      IF (p_recurrence->>'repeatEveryUnit') = 'day' THEN
        IF (p_recurrence->'weekDays' IS NULL OR jsonb_array_length(p_recurrence->'weekDays') = 0)
           OR (extract(isodow from v_date)::smallint = ANY (
                ARRAY(SELECT jsonb_array_elements_text(p_recurrence->'weekDays')::smallint)
              )) THEN
          v_dates := array_append(v_dates, v_date);
        END IF;
        v_date := v_date + COALESCE((p_recurrence->>'repeatEveryNumber')::integer, 1);
      ELSIF (p_recurrence->>'repeatEveryUnit') = 'week' THEN
        IF (extract(isodow from v_date)::smallint = ANY (
              ARRAY(SELECT jsonb_array_elements_text(p_recurrence->'weekDays')::smallint)
            )) THEN
          v_dates := array_append(v_dates, v_date);
        END IF;
        v_date := v_date + 1;
      ELSE
        v_date := v_date + 1;
      END IF;
    END LOOP;
  ELSE
    -- Single absence: just the specified date
    v_dates := ARRAY[p_absence_date];
    v_recurrence_id := NULL;
    v_absence_type := 'single';
    v_start_date := p_absence_date;
    v_end_date := p_absence_date;
  END IF;

  -- CREATE STUDENT_ABSENCE_NOTES RECORD FIRST (single source of truth)
  INSERT INTO public.student_absence_notes (
    student_id,
    school_id,
    created_by,
    start_date,
    end_date,
    absence_type,
    absence_status,
    reason,
    is_excused,
    status,
    attachment_url,
    recurrence_id,
    sensitive
  )
  VALUES (
    p_student_id,
    p_school_id,
    p_created_by,
    v_start_date,
    v_end_date,
    v_absence_type,
    p_absence_status,
    p_reason,
    p_excused,
    'pending'::text,
    p_attachment_url,
    v_recurrence_id,
    false
  )
  RETURNING id INTO v_absence_note_id;

  -- Debug logging for absence note creation
  INSERT INTO debug_logs (step, message) VALUES 
    ('absence_note_created', 
     format('Created absence note %s for student %s with status %s', 
            v_absence_note_id, p_student_id, p_absence_status));

  -- Process each date (single or multiple from recurrence)
  FOREACH v_date IN ARRAY v_dates LOOP
    -- Debug logging for each date
    INSERT INTO debug_logs (step, message) VALUES 
      ('process_absence_date', 
       format('Processing absence for date %s', v_date));

    -- Check if student has lessons before the absence period (for expected_checkout_time)
    SELECT EXISTS(
      -- Course lessons: Students enrolled via course_enrollments
      SELECT 1 FROM course_lessons cl
      INNER JOIN course_enrollments ce ON ce.course_id = cl.course_id
      WHERE cl.school_id = p_school_id
        AND ce.student_id = p_student_id
        AND ce.school_id = p_school_id
        AND v_date BETWEEN ce.start_date AND ce.end_date
        AND cl.start_datetime::date = v_date
        AND cl.end_datetime::time <= p_from_time
        AND cl.is_cancelled IS NOT TRUE
      
      UNION
      
      -- School lessons: Students enrolled via class membership
      SELECT 1 FROM course_lessons cl
      INNER JOIN profile_info_student pis ON pis.class_id = cl.class_id
      WHERE cl.school_id = p_school_id
        AND pis.profile_id = p_student_id
        AND pis.school_id = p_school_id
        AND cl.course_id IS NULL
        AND cl.class_id IS NOT NULL
        AND cl.start_datetime::date = v_date
        AND cl.end_datetime::time <= p_from_time
        AND cl.is_cancelled IS NOT TRUE
    ) INTO v_has_lessons_before;

    -- Check if student has lessons after the absence period (for expected_arrival_time)
    SELECT EXISTS(
      -- Course lessons: Students enrolled via course_enrollments
      SELECT 1 FROM course_lessons cl
      INNER JOIN course_enrollments ce ON ce.course_id = cl.course_id
      WHERE cl.school_id = p_school_id
        AND ce.student_id = p_student_id
        AND ce.school_id = p_school_id
        AND v_date BETWEEN ce.start_date AND ce.end_date
        AND cl.start_datetime::date = v_date
        AND cl.start_datetime::time >= p_to_time
        AND cl.is_cancelled IS NOT TRUE
      
      UNION
      
      -- School lessons: Students enrolled via class membership
      SELECT 1 FROM course_lessons cl
      INNER JOIN profile_info_student pis ON pis.class_id = cl.class_id
      WHERE cl.school_id = p_school_id
        AND pis.profile_id = p_student_id
        AND pis.school_id = p_school_id
        AND cl.course_id IS NULL
        AND cl.class_id IS NOT NULL
        AND cl.start_datetime::date = v_date
        AND cl.start_datetime::time >= p_to_time
        AND cl.is_cancelled IS NOT TRUE
    ) INTO v_has_lessons_after;

    -- Debug logging for lesson checks
    INSERT INTO debug_logs (step, message) VALUES 
      ('lesson_schedule_check', 
       format('Date %s: Has lessons before %s: %s, Has lessons after %s: %s', 
              v_date, p_from_time, v_has_lessons_before, p_to_time, v_has_lessons_after));

    -- Determine daily status and notes for absence
    IF p_from_time = TIME '00:00' AND p_to_time = TIME '23:59' THEN
      v_daily_status := CASE WHEN p_excused THEN 'absent_excused'::presence_status ELSE 'absent_unexcused'::presence_status END;
      v_note := format('Absent for full day: %s', p_reason);
    ELSE
      v_daily_status := 'partial'::presence_status;
      v_note := format('Absent from %s to %s: %s', p_from_time::text, p_to_time::text, p_reason);
    END IF;

    -- Create/update daily log WITH absence_note_id reference
    INSERT INTO student_daily_log (
      student_id, school_id, date, notes, expected_arrival_time, expected_checkout_time,
      created_at, updated_at, last_updated_by, presence_status, absence_note_id
    )
    VALUES (
      p_student_id, p_school_id, v_date, v_note,
      CASE WHEN v_daily_status = 'partial' AND v_has_lessons_after THEN p_to_time ELSE NULL END,
      CASE WHEN v_daily_status = 'partial' AND v_has_lessons_before THEN p_from_time ELSE NULL END,
      NOW(), NOW(), p_created_by, v_daily_status, v_absence_note_id
    )
    ON CONFLICT (student_id, school_id, date) DO UPDATE
      SET notes = v_note, 
          expected_arrival_time = CASE WHEN v_daily_status = 'partial' AND v_has_lessons_after THEN p_to_time ELSE NULL END,
          expected_checkout_time = CASE WHEN v_daily_status = 'partial' AND v_has_lessons_before THEN p_from_time ELSE NULL END,
          updated_at=NOW(), last_updated_by=p_created_by, presence_status=v_daily_status,
          absence_note_id=v_absence_note_id
    RETURNING id INTO v_daily_log_id;

    -- Mark overlapping lessons that the student is enrolled in
    FOR v_lesson IN
      -- Course lessons: Students enrolled via course_enrollments
      SELECT cl.id, cl.start_datetime, cl.end_datetime
      FROM course_lessons cl
      INNER JOIN course_enrollments ce ON ce.course_id = cl.course_id
      WHERE cl.school_id = p_school_id
        AND ce.student_id = p_student_id
        AND ce.school_id = p_school_id
        AND v_date BETWEEN ce.start_date AND ce.end_date
        AND cl.start_datetime::date = v_date
        AND (cl.start_datetime::time < p_to_time)
        AND (cl.end_datetime::time > p_from_time)
        AND cl.is_cancelled IS NOT TRUE
      
      UNION
      
      -- School lessons: Students enrolled via class membership (course_id is NULL)
      SELECT cl.id, cl.start_datetime, cl.end_datetime
      FROM course_lessons cl
      INNER JOIN profile_info_student pis ON pis.class_id = cl.class_id
      WHERE cl.school_id = p_school_id
        AND pis.profile_id = p_student_id
        AND pis.school_id = p_school_id
        AND cl.course_id IS NULL
        AND cl.class_id IS NOT NULL
        AND cl.start_datetime::date = v_date
        AND (cl.start_datetime::time < p_to_time)
        AND (cl.end_datetime::time > p_from_time)
        AND cl.is_cancelled IS NOT TRUE
    LOOP
      -- Debug logging for each lesson processed
      INSERT INTO debug_logs (step, message) VALUES 
        ('process_lesson', 
         format('Processing lesson %s from %s to %s', 
                v_lesson.id, v_lesson.start_datetime, v_lesson.end_datetime));

      -- Determine lesson status and note based on absence period
      IF p_from_time > v_lesson.start_datetime::time AND p_to_time < v_lesson.end_datetime::time THEN
        -- Student absent for middle part of lesson - mark as left early with note
        v_lesson_status := 'left_early'::attendance_status;
        v_note := format('Teilweise abwesend (%s-%s) wegen %s', p_from_time::text, p_to_time::text, p_reason);
      ELSIF p_from_time > v_lesson.start_datetime::time THEN
        -- Student absent from middle of lesson onwards (will arrive late next time)
        v_lesson_status := 'left_early'::attendance_status;
        v_note := format('Erwartet um %s - abwesend bis dahin wegen %s', p_to_time::text, p_reason);
      ELSIF p_to_time < v_lesson.end_datetime::time THEN
        -- Student absent at start, should be present later in lesson (late arrival)
        v_lesson_status := 'late'::attendance_status;
        v_note := format('Abwesend bis %s wegen %s, sollte dann anwesend sein', p_to_time::text, p_reason);
      ELSE
        -- Student absent for entire lesson
        v_lesson_status := CASE WHEN p_excused THEN 'absent_excused'::attendance_status ELSE 'absent_unexcused'::attendance_status END;
        v_note := format('Abwesend wegen %s', p_reason);
      END IF;

      -- Debug logging for lesson status determination
      INSERT INTO debug_logs (step, message) VALUES 
        ('lesson_status_determined', 
         format('Lesson %s status: %s, note: %s', v_lesson.id, v_lesson_status, v_note));

      -- Insert/update lesson attendance WITH absence_note_id reference
      INSERT INTO student_attendance_logs (
        lesson_id, student_id, daily_log_id, notes, recorded_by, "timestamp", status, absence_note_id
      )
      VALUES (
        v_lesson.id, p_student_id, v_daily_log_id, v_note, p_created_by, NOW(), v_lesson_status, v_absence_note_id
      )
      ON CONFLICT (lesson_id, student_id) DO
        UPDATE SET notes = v_note, daily_log_id = v_daily_log_id, recorded_by=p_created_by, 
                   "timestamp"=NOW(), status=v_lesson_status, absence_note_id=v_absence_note_id
      RETURNING id INTO v_attendance_log_id;

      -- FIXED: Return record with lesson_uuid instead of lesson_id
      RETURN QUERY SELECT 
        v_daily_log_id,
        v_attendance_log_id,
        v_date,
        v_lesson.id,           -- Now maps to lesson_uuid column
        v_note,
        v_recurrence_id,
        v_absence_note_id;
    END LOOP;
  END LOOP;

  -- Final debug logging
  INSERT INTO debug_logs (step, message) VALUES 
    ('add_student_absence_complete', 
     format('Completed absence processing for student %s with absence note %s and status %s', 
            p_student_id, v_absence_note_id, p_absence_status));
END;
$$;


ALTER FUNCTION public.add_student_absence_with_times_and_recurrence(p_student_id uuid, p_school_id uuid, p_absence_date date, p_from_time time without time zone, p_to_time time without time zone, p_reason text, p_excused boolean, p_attachment_url text, p_created_by uuid, p_recurrence jsonb, p_absence_status text) OWNER TO supabase_admin;

--
-- Name: add_student_absence_with_times_and_recurrence_changed25.08.2025(uuid, uuid, uuid, text, time without time zone, time without time zone, date, jsonb, text, boolean); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public."add_student_absence_with_times_and_recurrence_changed25.08.2025"(p_student_id uuid, p_school_id uuid, p_created_by uuid, p_reason text, p_from_time time without time zone, p_to_time time without time zone, p_absence_date date, p_recurrence jsonb DEFAULT NULL::jsonb, p_attachment_url text DEFAULT NULL::text, p_excused boolean DEFAULT true) RETURNS TABLE(daily_log_id uuid, attendance_log_id uuid, log_date date, returned_lesson_id uuid, attendance_note text, recurrence_id uuid, absence_note_id uuid)
    LANGUAGE plpgsql
    AS $$DECLARE
  v_recurrence_id uuid;
  v_absence_note_id uuid;
  v_dates date[];
  v_date date;
  v_daily_log_id uuid;
  v_lesson RECORD;
  v_attendance_log_id uuid;
  v_note text;
  v_daily_status presence_status;
  v_lesson_status attendance_status;
  v_has_lessons_before boolean := false;
  v_has_lessons_after boolean := false;
  v_absence_type text;
  v_start_date date;
  v_end_date date;
BEGIN
  -- Debug logging
  INSERT INTO debug_logs (step, message) VALUES 
    ('add_student_absence_start', 
     format('Processing absence for student %s on %s from %s to %s', 
            p_student_id, p_absence_date, p_from_time, p_to_time));

  -- RECURRENCE HANDLING: Proper workflow implementation
  IF p_recurrence IS NOT NULL THEN
    -- Step 1: Create recurrence definition
    INSERT INTO public.student_absence_recurrences(
      start_date, end_date, repeat_every_unit, repeat_every_number, week_days, monthly_text, created_by
    )
    VALUES (
      (p_recurrence->>'startDate')::date,
      (p_recurrence->>'endDate')::date,
      (p_recurrence->>'repeatEveryUnit')::text,
      COALESCE((p_recurrence->>'repeatEveryNumber')::smallint, 1),
      CASE WHEN jsonb_array_length(p_recurrence->'weekDays') > 0
           THEN ARRAY(SELECT jsonb_array_elements_text(p_recurrence->'weekDays')::smallint)
           ELSE NULL
      END,
      NULLIF(p_recurrence->>'monthlyText',''),
      p_created_by
    )
    RETURNING id INTO v_recurrence_id;

    -- Set absence details for recurring pattern
    v_absence_type := 'recurring';
    v_start_date := (p_recurrence->>'startDate')::date;
    v_end_date := (p_recurrence->>'endDate')::date;

    -- Step 2: Generate date array based on recurrence rules
    v_dates := ARRAY[]::date[];
    v_date := (p_recurrence->>'startDate')::date;
    WHILE v_date <= (p_recurrence->>'endDate')::date LOOP
      IF (p_recurrence->>'repeatEveryUnit') = 'day' THEN
        IF (p_recurrence->'weekDays' IS NULL OR jsonb_array_length(p_recurrence->'weekDays') = 0)
           OR (extract(isodow from v_date)::smallint = ANY (
                ARRAY(SELECT jsonb_array_elements_text(p_recurrence->'weekDays')::smallint)
              )) THEN
          v_dates := array_append(v_dates, v_date);
        END IF;
        v_date := v_date + COALESCE((p_recurrence->>'repeatEveryNumber')::integer, 1);
      ELSIF (p_recurrence->>'repeatEveryUnit') = 'week' THEN
        IF (extract(isodow from v_date)::smallint = ANY (
              ARRAY(SELECT jsonb_array_elements_text(p_recurrence->'weekDays')::smallint)
            )) THEN
          v_dates := array_append(v_dates, v_date);
        END IF;
        v_date := v_date + 1;
      ELSE
        v_date := v_date + 1;
      END IF;
    END LOOP;
  ELSE
    -- Single absence: just the specified date
    v_dates := ARRAY[p_absence_date];
    v_recurrence_id := NULL;
    v_absence_type := 'single';
    v_start_date := p_absence_date;
    v_end_date := p_absence_date;
  END IF;

  -- CREATE STUDENT_ABSENCE_NOTES RECORD FIRST (single source of truth)
  INSERT INTO public.student_absence_notes (
    student_id,
    school_id,
    created_by,
    start_date,
    end_date,
    absence_type,
    reason,
    is_excused,
    status,
    attachment_url,
    recurrence_id,
    sensitive
  )
  VALUES (
    p_student_id,
    p_school_id,
    p_created_by,
    v_start_date,
    v_end_date,
    v_absence_type,
    p_reason,
    p_excused,
    'pending'::text,  -- Initial status is pending for approval workflow
    p_attachment_url,
    v_recurrence_id,
    false  -- Default to not sensitive
  )
  RETURNING id INTO v_absence_note_id;

  -- Debug logging for absence note creation
  INSERT INTO debug_logs (step, message) VALUES 
    ('absence_note_created', 
     format('Created absence note %s for student %s', v_absence_note_id, p_student_id));

  -- Process each date (single or multiple from recurrence)
  FOREACH v_date IN ARRAY v_dates LOOP
    -- Debug logging for each date
    INSERT INTO debug_logs (step, message) VALUES 
      ('process_absence_date', 
       format('Processing absence for date %s', v_date));

    -- Check if student has lessons before the absence period (for expected_checkout_time)
    SELECT EXISTS(
      -- Course lessons: Students enrolled via course_enrollments
      SELECT 1 FROM course_lessons cl
      INNER JOIN course_enrollments ce ON ce.course_id = cl.course_id
      WHERE cl.school_id = p_school_id
        AND ce.student_id = p_student_id
        AND ce.school_id = p_school_id
        AND v_date BETWEEN ce.start_date AND ce.end_date
        AND cl.start_datetime::date = v_date
        AND cl.end_datetime::time <= p_from_time
        AND cl.is_cancelled IS NOT TRUE
      
      UNION
      
      -- School lessons: Students enrolled via class membership
      SELECT 1 FROM course_lessons cl
      INNER JOIN profile_info_student pis ON pis.class_id = cl.class_id
      WHERE cl.school_id = p_school_id
        AND pis.profile_id = p_student_id
        AND pis.school_id = p_school_id
        AND cl.course_id IS NULL
        AND cl.class_id IS NOT NULL
        AND cl.start_datetime::date = v_date
        AND cl.end_datetime::time <= p_from_time
        AND cl.is_cancelled IS NOT TRUE
    ) INTO v_has_lessons_before;

    -- Check if student has lessons after the absence period (for expected_arrival_time)
    SELECT EXISTS(
      -- Course lessons: Students enrolled via course_enrollments
      SELECT 1 FROM course_lessons cl
      INNER JOIN course_enrollments ce ON ce.course_id = cl.course_id
      WHERE cl.school_id = p_school_id
        AND ce.student_id = p_student_id
        AND ce.school_id = p_school_id
        AND v_date BETWEEN ce.start_date AND ce.end_date
        AND cl.start_datetime::date = v_date
        AND cl.start_datetime::time >= p_to_time
        AND cl.is_cancelled IS NOT TRUE
      
      UNION
      
      -- School lessons: Students enrolled via class membership
      SELECT 1 FROM course_lessons cl
      INNER JOIN profile_info_student pis ON pis.class_id = cl.class_id
      WHERE cl.school_id = p_school_id
        AND pis.profile_id = p_student_id
        AND pis.school_id = p_school_id
        AND cl.course_id IS NULL
        AND cl.class_id IS NOT NULL
        AND cl.start_datetime::date = v_date
        AND cl.start_datetime::time >= p_to_time
        AND cl.is_cancelled IS NOT TRUE
    ) INTO v_has_lessons_after;

    -- Debug logging for lesson checks
    INSERT INTO debug_logs (step, message) VALUES 
      ('lesson_schedule_check', 
       format('Date %s: Has lessons before %s: %s, Has lessons after %s: %s', 
              v_date, p_from_time, v_has_lessons_before, p_to_time, v_has_lessons_after));

    -- Determine daily status and notes for absence
    IF p_from_time = TIME '00:00' AND p_to_time = TIME '23:59' THEN
      v_daily_status := CASE WHEN p_excused THEN 'absent_excused'::presence_status ELSE 'absent_unexcused'::presence_status END;
      v_note := format('Absent for full day: %s', p_reason);
    ELSE
      v_daily_status := 'partial'::presence_status;
      v_note := format('Absent from %s to %s: %s', p_from_time::text, p_to_time::text, p_reason);
    END IF;

    -- Create/update daily log WITH absence_note_id reference
    INSERT INTO student_daily_log (
      student_id, school_id, date, notes, expected_arrival_time, expected_checkout_time,
      created_at, updated_at, last_updated_by, presence_status, absence_note_id
    )
    VALUES (
      p_student_id, p_school_id, v_date, v_note,
      CASE WHEN v_daily_status = 'partial' AND v_has_lessons_after THEN p_to_time ELSE NULL END,
      CASE WHEN v_daily_status = 'partial' AND v_has_lessons_before THEN p_from_time ELSE NULL END,
      NOW(), NOW(), p_created_by, v_daily_status, v_absence_note_id
    )
    ON CONFLICT (student_id, school_id, date) DO UPDATE
      SET notes = v_note, 
          expected_arrival_time = CASE WHEN v_daily_status = 'partial' AND v_has_lessons_after THEN p_to_time ELSE NULL END,
          expected_checkout_time = CASE WHEN v_daily_status = 'partial' AND v_has_lessons_before THEN p_from_time ELSE NULL END,
          updated_at=NOW(), last_updated_by=p_created_by, presence_status=v_daily_status,
          absence_note_id=v_absence_note_id
    RETURNING id INTO v_daily_log_id;

    -- Mark overlapping lessons that the student is enrolled in
    FOR v_lesson IN
      -- Course lessons: Students enrolled via course_enrollments
      SELECT cl.id, cl.start_datetime, cl.end_datetime
      FROM course_lessons cl
      INNER JOIN course_enrollments ce ON ce.course_id = cl.course_id
      WHERE cl.school_id = p_school_id
        AND ce.student_id = p_student_id
        AND ce.school_id = p_school_id
        AND v_date BETWEEN ce.start_date AND ce.end_date
        AND cl.start_datetime::date = v_date
        AND (cl.start_datetime::time < p_to_time)
        AND (cl.end_datetime::time > p_from_time)
        AND cl.is_cancelled IS NOT TRUE
      
      UNION
      
      -- School lessons: Students enrolled via class membership (course_id is NULL)
      SELECT cl.id, cl.start_datetime, cl.end_datetime
      FROM course_lessons cl
      INNER JOIN profile_info_student pis ON pis.class_id = cl.class_id
      WHERE cl.school_id = p_school_id
        AND pis.profile_id = p_student_id
        AND pis.school_id = p_school_id
        AND cl.course_id IS NULL  -- School lessons have no course_id
        AND cl.class_id IS NOT NULL  -- School lessons have class_id
        AND cl.start_datetime::date = v_date
        AND (cl.start_datetime::time < p_to_time)
        AND (cl.end_datetime::time > p_from_time)
        AND cl.is_cancelled IS NOT TRUE
    LOOP
      -- Debug logging for each lesson processed
      INSERT INTO debug_logs (step, message) VALUES 
        ('process_lesson', 
         format('Processing lesson %s from %s to %s', 
                v_lesson.id, v_lesson.start_datetime, v_lesson.end_datetime));

      -- Determine lesson status and note based on absence period
      IF p_from_time > v_lesson.start_datetime::time AND p_to_time < v_lesson.end_datetime::time THEN
        -- Student absent for middle part of lesson - mark as left early with note
        v_lesson_status := 'left_early'::attendance_status;
        v_note := format('Teilweise abwesend (%s-%s) wegen %s', p_from_time::text, p_to_time::text, p_reason);
      ELSIF p_from_time > v_lesson.start_datetime::time THEN
        -- Student absent from middle of lesson onwards (will arrive late next time)
        v_lesson_status := 'left_early'::attendance_status;
        v_note := format('Erwartet um %s - abwesend bis dahin wegen %s', p_to_time::text, p_reason);
      ELSIF p_to_time < v_lesson.end_datetime::time THEN
        -- Student absent at start, should be present later in lesson (late arrival)
        v_lesson_status := 'late'::attendance_status;
        v_note := format('Abwesend bis %s wegen %s, sollte dann anwesend sein', p_to_time::text, p_reason);
      ELSE
        -- Student absent for entire lesson
        v_lesson_status := CASE WHEN p_excused THEN 'absent_excused'::attendance_status ELSE 'absent_unexcused'::attendance_status END;
        v_note := format('Abwesend wegen %s', p_reason);
      END IF;

      -- Debug logging for lesson status determination
      INSERT INTO debug_logs (step, message) VALUES 
        ('lesson_status_determined', 
         format('Lesson %s status: %s, note: %s', v_lesson.id, v_lesson_status, v_note));

      -- Insert/update lesson attendance WITH absence_note_id reference
      INSERT INTO student_attendance_logs (
        lesson_id, student_id, daily_log_id, notes, recorded_by, "timestamp", status, absence_note_id
      )
      VALUES (
        v_lesson.id, p_student_id, v_daily_log_id, v_note, p_created_by, NOW(), v_lesson_status, v_absence_note_id
      )
      ON CONFLICT (lesson_id, student_id) DO
        UPDATE SET notes = v_note, daily_log_id = v_daily_log_id, recorded_by=p_created_by, 
                   "timestamp"=NOW(), status=v_lesson_status, absence_note_id=v_absence_note_id
      RETURNING id INTO v_attendance_log_id;

      -- Return record for this lesson including absence_note_id
      RETURN QUERY SELECT 
        v_daily_log_id,
        v_attendance_log_id,
        v_date,
        v_lesson.id,
        v_note,
        v_recurrence_id,
        v_absence_note_id;
    END LOOP;
  END LOOP;

  -- Final debug logging
  INSERT INTO debug_logs (step, message) VALUES 
    ('add_student_absence_complete', 
     format('Completed absence processing for student %s with absence note %s', p_student_id, v_absence_note_id));
END;$$;


ALTER FUNCTION public."add_student_absence_with_times_and_recurrence_changed25.08.2025"(p_student_id uuid, p_school_id uuid, p_created_by uuid, p_reason text, p_from_time time without time zone, p_to_time time without time zone, p_absence_date date, p_recurrence jsonb, p_attachment_url text, p_excused boolean) OWNER TO supabase_admin;

--
-- Name: add_student_partial_absence_with_lesson_marking(uuid, uuid, date, time without time zone, time without time zone, text, uuid, boolean); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.add_student_partial_absence_with_lesson_marking(p_student_id uuid, p_school_id uuid, p_absence_date date, p_from_time time without time zone, p_to_time time without time zone, p_reason text, p_created_by uuid, p_excused boolean DEFAULT true) RETURNS TABLE(daily_log_id uuid, attendance_log_ids uuid[])
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_daily_log_id uuid;
  v_lesson RECORD;
  v_attendance_log_id uuid;
  v_attendance_log_ids uuid[] := ARRAY[]::uuid[];
  v_note text;
  v_daily_status presence_status;
  v_lesson_status attendance_status;
  v_has_lessons_before boolean := false;
  v_has_lessons_after boolean := false;
BEGIN
  -- Debug logging
  INSERT INTO debug_logs (step, message) VALUES 
    ('add_partial_absence_start', 
     format('Processing partial absence for student %s on %s from %s to %s', 
            p_student_id, p_absence_date, p_from_time, p_to_time));

  -- WARNING: This function is for SINGLE DAY absences only!
  -- For recurring absences, use student_absence_recurrences table + student_absence_recurrences_generate()

  -- Check if student has lessons before the absence period (for expected_checkout_time)
  SELECT EXISTS(
    -- Course lessons: Students enrolled via course_enrollments
    SELECT 1 FROM course_lessons cl
    INNER JOIN course_enrollments ce ON ce.course_id = cl.course_id
    WHERE cl.school_id = p_school_id
      AND ce.student_id = p_student_id
      AND ce.school_id = p_school_id
      AND p_absence_date BETWEEN ce.start_date AND ce.end_date
      AND cl.start_datetime::date = p_absence_date
      AND cl.end_datetime::time <= p_from_time
      AND cl.is_cancelled IS NOT TRUE
    
    UNION
    
    -- School lessons: Students enrolled via class membership
    SELECT 1 FROM course_lessons cl
    INNER JOIN profile_info_student pis ON pis.class_id = cl.class_id
    WHERE cl.school_id = p_school_id
      AND pis.profile_id = p_student_id
      AND pis.school_id = p_school_id
      AND cl.course_id IS NULL
      AND cl.class_id IS NOT NULL
      AND cl.start_datetime::date = p_absence_date
      AND cl.end_datetime::time <= p_from_time
      AND cl.is_cancelled IS NOT TRUE
  ) INTO v_has_lessons_before;

  -- Check if student has lessons after the absence period (for expected_arrival_time)
  SELECT EXISTS(
    -- Course lessons: Students enrolled via course_enrollments
    SELECT 1 FROM course_lessons cl
    INNER JOIN course_enrollments ce ON ce.course_id = cl.course_id
    WHERE cl.school_id = p_school_id
      AND ce.student_id = p_student_id
      AND ce.school_id = p_school_id
      AND p_absence_date BETWEEN ce.start_date AND ce.end_date
      AND cl.start_datetime::date = p_absence_date
      AND cl.start_datetime::time >= p_to_time
      AND cl.is_cancelled IS NOT TRUE
    
    UNION
    
    -- School lessons: Students enrolled via class membership
    SELECT 1 FROM course_lessons cl
    INNER JOIN profile_info_student pis ON pis.class_id = cl.class_id
    WHERE cl.school_id = p_school_id
      AND pis.profile_id = p_student_id
      AND pis.school_id = p_school_id
      AND cl.course_id IS NULL
      AND cl.class_id IS NOT NULL
      AND cl.start_datetime::date = p_absence_date
      AND cl.start_datetime::time >= p_to_time
      AND cl.is_cancelled IS NOT TRUE
  ) INTO v_has_lessons_after;

  -- Debug logging for lesson checks
  INSERT INTO debug_logs (step, message) VALUES 
    ('partial_absence_lesson_check', 
     format('Date %s: Has lessons before %s: %s, Has lessons after %s: %s', 
            p_absence_date, p_from_time, v_has_lessons_before, p_to_time, v_has_lessons_after));
  
  -- Determine daily status based on time window
  IF p_from_time = TIME '00:00' AND p_to_time = TIME '23:59' THEN
    v_daily_status := CASE WHEN p_excused THEN 'absent_excused'::presence_status ELSE 'absent_unexcused'::presence_status END;
    v_note := format('Absent for full day: %s', p_reason);
  ELSE
    v_daily_status := 'partial'::presence_status;
    v_note := format('Absent from %s to %s: %s', p_from_time::text, p_to_time::text, p_reason);
  END IF;

  -- Insert or update daily log WITHOUT setting check_in_time/check_out_time for absences
  -- IMPORTANT: check_in_time and check_out_time represent actual physical presence
  -- For absences, we use expected_arrival_time and expected_checkout_time ONLY if student has relevant lessons
  INSERT INTO student_daily_log (
    student_id, school_id, date, notes, expected_arrival_time, expected_checkout_time,
    created_at, updated_at, last_updated_by, presence_status
  )
  VALUES (
    p_student_id, p_school_id, p_absence_date, v_note, 
    CASE WHEN v_has_lessons_after THEN p_to_time ELSE NULL END,
    CASE WHEN v_has_lessons_before THEN p_from_time ELSE NULL END,
    NOW(), NOW(), p_created_by, v_daily_status
  )
  ON CONFLICT (student_id, school_id, date) DO UPDATE
    SET notes = v_note, 
        expected_arrival_time = CASE WHEN v_has_lessons_after THEN p_to_time ELSE NULL END,
        expected_checkout_time = CASE WHEN v_has_lessons_before THEN p_from_time ELSE NULL END,
        updated_at = NOW(), last_updated_by = p_created_by, presence_status = v_daily_status
  RETURNING id INTO v_daily_log_id;

  -- Mark lessons that overlap with the absence window that the student is enrolled in
  -- This handles both course lessons (with course_enrollments) and school lessons (with class_id)
  FOR v_lesson IN
    -- Course lessons: Students enrolled via course_enrollments
    SELECT cl.id, cl.start_datetime, cl.end_datetime
    FROM course_lessons cl
    INNER JOIN course_enrollments ce ON ce.course_id = cl.course_id
    WHERE cl.school_id = p_school_id
      AND ce.student_id = p_student_id
      AND ce.school_id = p_school_id
      AND p_absence_date BETWEEN ce.start_date AND ce.end_date
      AND cl.start_datetime::date = p_absence_date
      AND (cl.start_datetime::time < p_to_time)
      AND (cl.end_datetime::time > p_from_time)
      AND cl.is_cancelled IS NOT TRUE
    
    UNION
    
    -- School lessons: Students enrolled via class membership (course_id is NULL)
    SELECT cl.id, cl.start_datetime, cl.end_datetime
    FROM course_lessons cl
    INNER JOIN profile_info_student pis ON pis.class_id = cl.class_id
    WHERE cl.school_id = p_school_id
      AND pis.profile_id = p_student_id
      AND pis.school_id = p_school_id
      AND cl.course_id IS NULL  -- School lessons have no course_id
      AND cl.class_id IS NOT NULL  -- School lessons have class_id
      AND cl.start_datetime::date = p_absence_date
      AND (cl.start_datetime::time < p_to_time)
      AND (cl.end_datetime::time > p_from_time)
      AND cl.is_cancelled IS NOT TRUE
  LOOP
      -- Debug logging for each lesson processed
      INSERT INTO debug_logs (step, message) VALUES 
        ('partial_absence_process_lesson', 
         format('Processing lesson %s from %s to %s', 
                v_lesson.id, v_lesson.start_datetime, v_lesson.end_datetime));

      -- Determine lesson status and note based on absence period
      IF p_from_time > v_lesson.start_datetime::time AND p_to_time < v_lesson.end_datetime::time THEN
        -- Student absent for middle part of lesson - mark as left early with note
        v_lesson_status := 'left_early'::attendance_status;
        v_note := format('Teilweise abwesend (%s-%s) wegen %s', p_from_time::text, p_to_time::text, p_reason);
      ELSIF p_from_time > v_lesson.start_datetime::time THEN
        -- Student absent from middle of lesson onwards (will arrive late next time)
        v_lesson_status := 'left_early'::attendance_status;
        v_note := format('Erwartet um %s - abwesend bis dahin wegen %s', p_to_time::text, p_reason);
      ELSIF p_to_time < v_lesson.end_datetime::time THEN
        -- Student absent at start, should be present later in lesson (late arrival)
        v_lesson_status := 'late'::attendance_status;
        v_note := format('Abwesend bis %s wegen %s, sollte dann anwesend sein', p_to_time::text, p_reason);
      ELSE
        -- Student absent for entire lesson
        v_lesson_status := CASE WHEN p_excused THEN 'absent_excused'::attendance_status ELSE 'absent_unexcused'::attendance_status END;
        v_note := format('Abwesend wegen %s', p_reason);
      END IF;

      -- Debug logging for lesson status determination
      INSERT INTO debug_logs (step, message) VALUES 
        ('partial_absence_lesson_status', 
         format('Lesson %s status: %s, note: %s', v_lesson.id, v_lesson_status, v_note));

    -- Insert or update lesson attendance
    INSERT INTO student_attendance_logs (
      lesson_id, student_id, daily_log_id, notes, recorded_by, "timestamp", status
    )
    VALUES (
      v_lesson.id, p_student_id, v_daily_log_id, v_note, p_created_by, NOW(), v_lesson_status
    )
    ON CONFLICT (lesson_id, student_id) DO
      UPDATE SET notes = v_note, daily_log_id = v_daily_log_id, recorded_by = p_created_by, 
                 "timestamp" = NOW(), status = v_lesson_status
    RETURNING id INTO v_attendance_log_id;

    -- Collect attendance log IDs
    v_attendance_log_ids := array_append(v_attendance_log_ids, v_attendance_log_id);
  END LOOP;

  -- Final debug logging
  INSERT INTO debug_logs (step, message) VALUES 
    ('partial_absence_complete', 
     format('Completed partial absence processing for student %s on %s', p_student_id, p_absence_date));

  -- Return results
  daily_log_id := v_daily_log_id;
  attendance_log_ids := v_attendance_log_ids;
  RETURN NEXT;
END;
$$;


ALTER FUNCTION public.add_student_partial_absence_with_lesson_marking(p_student_id uuid, p_school_id uuid, p_absence_date date, p_from_time time without time zone, p_to_time time without time zone, p_reason text, p_created_by uuid, p_excused boolean) OWNER TO supabase_admin;

--
-- Name: FUNCTION add_student_partial_absence_with_lesson_marking(p_student_id uuid, p_school_id uuid, p_absence_date date, p_from_time time without time zone, p_to_time time without time zone, p_reason text, p_created_by uuid, p_excused boolean); Type: COMMENT; Schema: public; Owner: supabase_admin
--

COMMENT ON FUNCTION public.add_student_partial_absence_with_lesson_marking(p_student_id uuid, p_school_id uuid, p_absence_date date, p_from_time time without time zone, p_to_time time without time zone, p_reason text, p_created_by uuid, p_excused boolean) IS 'FIXED: Records absence periods without setting check_in_time/check_out_time (which represent actual presence). Uses expected_arrival_time and expected_checkout_time fields ONLY when student has lessons scheduled before/after absence period. Creates attendance logs for BOTH course lessons (via enrollments) AND school lessons (via class membership). Single day absences only - use add_student_absence_with_times_and_recurrence for recurring absences. Includes debug logging for troubleshooting.';


--
-- Name: add_student_partial_absence_with_lesson_marking(uuid, uuid, date, time without time zone, time without time zone, text, uuid, boolean, text); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.add_student_partial_absence_with_lesson_marking(p_student_id uuid, p_school_id uuid, p_absence_date date, p_from_time time without time zone, p_to_time time without time zone, p_reason text, p_created_by uuid, p_excused boolean DEFAULT true, p_attachment_url text DEFAULT NULL::text) RETURNS TABLE(daily_log_id uuid, attendance_log_ids uuid[], absence_note_id uuid)
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_absence_note_id uuid;
  v_daily_log_id uuid;
  v_lesson RECORD;
  v_attendance_log_id uuid;
  v_attendance_log_ids uuid[] := ARRAY[]::uuid[];
  v_note text;
  v_daily_status presence_status;
  v_lesson_status attendance_status;
  v_has_lessons_before boolean := false;
  v_has_lessons_after boolean := false;
BEGIN
  -- Debug logging
  INSERT INTO debug_logs (step, message) VALUES 
    ('add_partial_absence_start', 
     format('Processing partial absence for student %s on %s from %s to %s', 
            p_student_id, p_absence_date, p_from_time, p_to_time));

  -- WARNING: This function is for SINGLE DAY absences only!
  -- For recurring absences, use student_absence_recurrences table + student_absence_recurrences_generate()

  -- CREATE STUDENT_ABSENCE_NOTES RECORD FIRST (single source of truth)
  INSERT INTO public.student_absence_notes (
    student_id,
    school_id,
    created_by,
    start_date,
    end_date,
    absence_type,
    reason,
    is_excused,
    status,
    attachment_url,
    recurrence_id,
    sensitive
  )
  VALUES (
    p_student_id,
    p_school_id,
    p_created_by,
    p_absence_date,
    p_absence_date,
    'single'::text,
    p_reason,
    p_excused,
    'pending'::text,  -- Initial status is pending for approval workflow
    p_attachment_url,
    NULL,  -- No recurrence for single day absence
    false  -- Default to not sensitive
  )
  RETURNING id INTO v_absence_note_id;

  -- Debug logging for absence note creation
  INSERT INTO debug_logs (step, message) VALUES 
    ('absence_note_created', 
     format('Created absence note %s for single day absence', v_absence_note_id));

  -- Check if student has lessons before the absence period (for expected_checkout_time)
  SELECT EXISTS(
    -- Course lessons: Students enrolled via course_enrollments
    SELECT 1 FROM course_lessons cl
    INNER JOIN course_enrollments ce ON ce.course_id = cl.course_id
    WHERE cl.school_id = p_school_id
      AND ce.student_id = p_student_id
      AND ce.school_id = p_school_id
      AND p_absence_date BETWEEN ce.start_date AND ce.end_date
      AND cl.start_datetime::date = p_absence_date
      AND cl.end_datetime::time <= p_from_time
      AND cl.is_cancelled IS NOT TRUE
    
    UNION
    
    -- School lessons: Students enrolled via class membership
    SELECT 1 FROM course_lessons cl
    INNER JOIN profile_info_student pis ON pis.class_id = cl.class_id
    WHERE cl.school_id = p_school_id
      AND pis.profile_id = p_student_id
      AND pis.school_id = p_school_id
      AND cl.course_id IS NULL
      AND cl.class_id IS NOT NULL
      AND cl.start_datetime::date = p_absence_date
      AND cl.end_datetime::time <= p_from_time
      AND cl.is_cancelled IS NOT TRUE
  ) INTO v_has_lessons_before;

  -- Check if student has lessons after the absence period (for expected_arrival_time)
  SELECT EXISTS(
    -- Course lessons: Students enrolled via course_enrollments
    SELECT 1 FROM course_lessons cl
    INNER JOIN course_enrollments ce ON ce.course_id = cl.course_id
    WHERE cl.school_id = p_school_id
      AND ce.student_id = p_student_id
      AND ce.school_id = p_school_id
      AND p_absence_date BETWEEN ce.start_date AND ce.end_date
      AND cl.start_datetime::date = p_absence_date
      AND cl.start_datetime::time >= p_to_time
      AND cl.is_cancelled IS NOT TRUE
    
    UNION
    
    -- School lessons: Students enrolled via class membership
    SELECT 1 FROM course_lessons cl
    INNER JOIN profile_info_student pis ON pis.class_id = cl.class_id
    WHERE cl.school_id = p_school_id
      AND pis.profile_id = p_student_id
      AND pis.school_id = p_school_id
      AND cl.course_id IS NULL
      AND cl.class_id IS NOT NULL
      AND cl.start_datetime::date = p_absence_date
      AND cl.start_datetime::time >= p_to_time
      AND cl.is_cancelled IS NOT TRUE
  ) INTO v_has_lessons_after;

  -- Debug logging for lesson checks
  INSERT INTO debug_logs (step, message) VALUES 
    ('partial_absence_lesson_check', 
     format('Date %s: Has lessons before %s: %s, Has lessons after %s: %s', 
            p_absence_date, p_from_time, v_has_lessons_before, p_to_time, v_has_lessons_after));
  
  -- Determine daily status based on time window
  IF p_from_time = TIME '00:00' AND p_to_time = TIME '23:59' THEN
    v_daily_status := CASE WHEN p_excused THEN 'absent_excused'::presence_status ELSE 'absent_unexcused'::presence_status END;
    v_note := format('Absent for full day: %s', p_reason);
  ELSE
    v_daily_status := 'partial'::presence_status;
    v_note := format('Absent from %s to %s: %s', p_from_time::text, p_to_time::text, p_reason);
  END IF;

  -- Insert or update daily log WITH absence_note_id reference
  INSERT INTO student_daily_log (
    student_id, school_id, date, notes, expected_arrival_time, expected_checkout_time,
    created_at, updated_at, last_updated_by, presence_status, absence_note_id
  )
  VALUES (
    p_student_id, p_school_id, p_absence_date, v_note, 
    CASE WHEN v_has_lessons_after THEN p_to_time ELSE NULL END,
    CASE WHEN v_has_lessons_before THEN p_from_time ELSE NULL END,
    NOW(), NOW(), p_created_by, v_daily_status, v_absence_note_id
  )
  ON CONFLICT (student_id, school_id, date) DO UPDATE
    SET notes = v_note, 
        expected_arrival_time = CASE WHEN v_has_lessons_after THEN p_to_time ELSE NULL END,
        expected_checkout_time = CASE WHEN v_has_lessons_before THEN p_from_time ELSE NULL END,
        updated_at = NOW(), last_updated_by = p_created_by, presence_status = v_daily_status,
        absence_note_id = v_absence_note_id
  RETURNING id INTO v_daily_log_id;

  -- Mark lessons that overlap with the absence window that the student is enrolled in
  FOR v_lesson IN
    -- Course lessons: Students enrolled via course_enrollments
    SELECT cl.id, cl.start_datetime, cl.end_datetime
    FROM course_lessons cl
    INNER JOIN course_enrollments ce ON ce.course_id = cl.course_id
    WHERE cl.school_id = p_school_id
      AND ce.student_id = p_student_id
      AND ce.school_id = p_school_id
      AND p_absence_date BETWEEN ce.start_date AND ce.end_date
      AND cl.start_datetime::date = p_absence_date
      AND (cl.start_datetime::time < p_to_time)
      AND (cl.end_datetime::time > p_from_time)
      AND cl.is_cancelled IS NOT TRUE
    
    UNION
    
    -- School lessons: Students enrolled via class membership (course_id is NULL)
    SELECT cl.id, cl.start_datetime, cl.end_datetime
    FROM course_lessons cl
    INNER JOIN profile_info_student pis ON pis.class_id = cl.class_id
    WHERE cl.school_id = p_school_id
      AND pis.profile_id = p_student_id
      AND pis.school_id = p_school_id
      AND cl.course_id IS NULL  -- School lessons have no course_id
      AND cl.class_id IS NOT NULL  -- School lessons have class_id
      AND cl.start_datetime::date = p_absence_date
      AND (cl.start_datetime::time < p_to_time)
      AND (cl.end_datetime::time > p_from_time)
      AND cl.is_cancelled IS NOT TRUE
  LOOP
    -- Debug logging for each lesson processed
    INSERT INTO debug_logs (step, message) VALUES 
      ('process_lesson_partial', 
       format('Processing lesson %s from %s to %s for partial absence', 
              v_lesson.id, v_lesson.start_datetime, v_lesson.end_datetime));

    -- Determine lesson status and note based on absence period
    IF p_from_time > v_lesson.start_datetime::time AND p_to_time < v_lesson.end_datetime::time THEN
      -- Student absent for middle part of lesson - mark as left early with note
      v_lesson_status := 'left_early'::attendance_status;
      v_note := format('Teilweise abwesend (%s-%s) wegen %s', p_from_time::text, p_to_time::text, p_reason);
    ELSIF p_from_time > v_lesson.start_datetime::time THEN
      -- Student absent from middle of lesson onwards (will arrive late next time)
      v_lesson_status := 'left_early'::attendance_status;
      v_note := format('Erwartet um %s - abwesend bis dahin wegen %s', p_to_time::text, p_reason);
    ELSIF p_to_time < v_lesson.end_datetime::time THEN
      -- Student absent at start, should be present later in lesson (late arrival)
      v_lesson_status := 'late'::attendance_status;
      v_note := format('Abwesend bis %s wegen %s, sollte dann anwesend sein', p_to_time::text, p_reason);
    ELSE
      -- Student absent for entire lesson
      v_lesson_status := CASE WHEN p_excused THEN 'absent_excused'::attendance_status ELSE 'absent_unexcused'::attendance_status END;
      v_note := format('Abwesend wegen %s', p_reason);
    END IF;

    -- Insert/update lesson attendance WITH absence_note_id reference
    INSERT INTO student_attendance_logs (
      lesson_id, student_id, daily_log_id, notes, recorded_by, "timestamp", status, absence_note_id
    )
    VALUES (
      v_lesson.id, p_student_id, v_daily_log_id, v_note, p_created_by, NOW(), v_lesson_status, v_absence_note_id
    )
    ON CONFLICT (lesson_id, student_id) DO
      UPDATE SET notes = v_note, daily_log_id = v_daily_log_id, recorded_by = p_created_by, 
                 "timestamp" = NOW(), status = v_lesson_status, absence_note_id = v_absence_note_id
    RETURNING id INTO v_attendance_log_id;

    -- Collect attendance log IDs
    v_attendance_log_ids := array_append(v_attendance_log_ids, v_attendance_log_id);
  END LOOP;

  -- Final debug logging
  INSERT INTO debug_logs (step, message) VALUES 
    ('partial_absence_complete', 
     format('Completed partial absence processing for student %s on %s with absence note %s', 
            p_student_id, p_absence_date, v_absence_note_id));

  -- Return results
  daily_log_id := v_daily_log_id;
  attendance_log_ids := v_attendance_log_ids;
  absence_note_id := v_absence_note_id;
  RETURN NEXT;
END;
$$;


ALTER FUNCTION public.add_student_partial_absence_with_lesson_marking(p_student_id uuid, p_school_id uuid, p_absence_date date, p_from_time time without time zone, p_to_time time without time zone, p_reason text, p_created_by uuid, p_excused boolean, p_attachment_url text) OWNER TO supabase_admin;

--
-- Name: add_student_to_family(uuid, uuid); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.add_student_to_family(target_student_profile_id uuid, target_family_id uuid) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
declare
  auth_user uuid := auth.uid();  -- pulled from session
  existing_family_id uuid;
  school_id uuid;
begin
  -- Get school_id for student
  select up.school_id into school_id
  from user_profiles up
  where up.id = target_student_profile_id;

  -- Check if student already belongs to a family
  select fm.family_id into existing_family_id
  from family_members fm
  where fm.profile_id = target_student_profile_id
    and fm.role = 'student'
    and fm.removed_at is null;

  if existing_family_id is not null then
    raise exception 'This student already belongs to a family (ID: %)', existing_family_id;
  end if;

  -- Insert into family_members
  insert into family_members (
    family_id,
    profile_id,
    role,
    added_by
  ) values (
    target_family_id,
    target_student_profile_id,
    'student',
    auth_user
  );

  -- Insert into change_log
  insert into change_log (
    user_id,
    school_id,
    table_name,
    record_id,
    action_type,
    after_data
  ) values (
    auth_user,
    school_id,
    'family_members',
    target_student_profile_id,
    'insert',
    jsonb_build_object(
      'family_id', target_family_id,
      'profile_id', target_student_profile_id,
      'role', 'student'
    )
  );
end;
$$;


ALTER FUNCTION public.add_student_to_family(target_student_profile_id uuid, target_family_id uuid) OWNER TO supabase_admin;

--
-- Name: add_subject_icon(text, text, text, text[]); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.add_subject_icon(icon_name text, icon_path text, icon_description text DEFAULT NULL::text, icon_tags text[] DEFAULT NULL::text[]) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
declare
  new_id uuid;
begin
  insert into public.subject_icons (name, icon_path, description, "Tags")
  values (icon_name, icon_path, icon_description, icon_tags)
  returning id into new_id;

  return new_id;
end;
$$;


ALTER FUNCTION public.add_subject_icon(icon_name text, icon_path text, icon_description text, icon_tags text[]) OWNER TO supabase_admin;

--
-- Name: add_user_to_group(); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.add_user_to_group() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_group_id uuid;
  group_name text;
  user_school_id uuid;
BEGIN
  -- Fetch the school_id dynamically from user_profiles
  SELECT school_id INTO user_school_id
  FROM public.user_profiles
  WHERE id = NEW.user_profile_id;

  -- Determine the group based on the new role_id
  SELECT name INTO group_name FROM public.roles WHERE id = NEW.role_id;
  
  -- Check if the group exists for this school (school isolation)
  SELECT id INTO v_group_id
  FROM public.user_groups
  WHERE name = group_name AND school_id = user_school_id;

  -- If the group doesn't exist for this school, create it
  IF v_group_id IS NULL THEN
    INSERT INTO public.user_groups (name, school_id)
    VALUES (group_name, user_school_id)
    RETURNING id INTO v_group_id;
  END IF;

  -- Only add the user to the group if they aren't already a member
  IF NOT EXISTS (
    SELECT 1
    FROM public.user_group_members
    WHERE group_id = v_group_id AND user_id = NEW.user_profile_id
  ) THEN
    INSERT INTO public.user_group_members (group_id, user_id, school_id)
    VALUES (
      v_group_id,
      NEW.user_profile_id,
      user_school_id
    );
    RAISE NOTICE 'User assigned to group: %', v_group_id;
  ELSE
    RAISE NOTICE 'User is already a member of the group: %', v_group_id;
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION public.add_user_to_group() OWNER TO supabase_admin;

--
-- Name: add_user_to_group_alt(); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.add_user_to_group_alt() RETURNS trigger
    LANGUAGE plpgsql
    AS $$DECLARE
  v_group_id uuid;
  group_name text;
  user_school_id uuid;
BEGIN
  -- Fetch the school_id dynamically from user_profiles
  SELECT school_id INTO user_school_id
  FROM public.user_profiles
  WHERE id = NEW.user_profile_id;

  -- Determine the group based on the new role_id
  SELECT name INTO group_name FROM public.roles WHERE id = NEW.role_id;
  
  -- FIXED: Check if the group exists for THIS SCHOOL (not just by name)
  SELECT id INTO v_group_id 
  FROM public.user_groups 
  WHERE name = group_name AND school_id = user_school_id;

  -- If the group doesn't exist for this school, create it
  IF v_group_id IS NULL THEN
    INSERT INTO public.user_groups (name, school_id)
    VALUES (group_name, user_school_id)
    RETURNING id INTO v_group_id;
    RAISE NOTICE 'Created new group for school: % - Group: %', user_school_id, group_name;
  END IF;

  -- Only add the user to the group if they aren't already a member
  IF NOT EXISTS (
    SELECT 1
    FROM public.user_group_members
    WHERE group_id = v_group_id AND user_id = NEW.user_profile_id
  ) THEN
    INSERT INTO public.user_group_members (group_id, user_id, school_id)
    VALUES (
      v_group_id, 
      NEW.user_profile_id,
      user_school_id
    );
    RAISE NOTICE 'User assigned to group: % (School: %)', v_group_id, user_school_id;
  ELSE
    RAISE NOTICE 'User is already a member of the group: %', v_group_id;
  END IF;

  RETURN NEW;
END;$$;


ALTER FUNCTION public.add_user_to_group_alt() OWNER TO supabase_admin;

--
-- Name: app_move_student_in_draft(uuid, uuid, uuid, smallint, uuid, text, uuid); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.app_move_student_in_draft(p_registration_period_id uuid, p_semester_id uuid, p_school_id uuid, p_day_of_week smallint, p_student_id uuid, p_target text, p_updated_by uuid DEFAULT NULL::uuid) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
declare
  v_resolved_course_id uuid;
  v_day_id integer;
begin
  -- Resolve day_id from day_of_week (required while day_id is NOT NULL)
  select sd.id
  into v_day_id
  from public.structure_days sd
  where sd.day_number = p_day_of_week
  limit 1;

  if v_day_id is null then
    return jsonb_build_object('ok', false, 'error', 'BAD_DAY_OF_WEEK');
  end if;

  -- Special targets
  if p_target in ('waiting','go-home') then
    v_resolved_course_id := null;
  else
    -- 1) Prefer resolving as a window in the same context
    begin
      select crw.course_id
      into v_resolved_course_id
      from public.course_registration_windows crw
      where crw.id = p_target::uuid
        and crw.registration_period_id = p_registration_period_id
        and crw.semester_id = p_semester_id
        and crw.school_id = p_school_id
      limit 1;
    exception when invalid_text_representation then
      v_resolved_course_id := null;
    end;

    -- 2) If not a window match, try treating p_target as a course_id (uuid)
    if v_resolved_course_id is null then
      begin
        -- Only accept as course_id if such a course actually exists
        select c.id
        into v_resolved_course_id
        from public.course_list c
        where c.id = p_target::uuid
        limit 1;
      exception when invalid_text_representation then
        v_resolved_course_id := null;
      end;
    end if;

    if v_resolved_course_id is null then
      return jsonb_build_object('ok', false, 'error', 'TARGET_NOT_FOUND_OR_BAD_ID');
    end if;

    -- 3) Guard: course must actually run on p_day_of_week
    if not exists (
      select 1
      from public.course_schedules cs
      join public.structure_days sd on sd.id = cs.day_id
      where cs.course_id = v_resolved_course_id
        and sd.day_number = p_day_of_week
    ) then
      return jsonb_build_object('ok', false, 'error', 'COURSE_NOT_SCHEDULED_ON_DAY');
    end if;
  end if;

  insert into public.course_allocation_drafts (
    registration_period_id, semester_id, school_id, day_id, day_of_week, student_id,
    target_course_id, special_target, updated_by
  ) values (
    p_registration_period_id, p_semester_id, p_school_id, v_day_id, p_day_of_week, p_student_id,
    v_resolved_course_id,
    case when p_target in ('waiting','go-home') then p_target else null end,
    p_updated_by
  )
  on conflict (registration_period_id, semester_id, school_id, day_of_week, student_id)
  do update set
    day_id          = excluded.day_id,
    day_of_week     = excluded.day_of_week,
    target_course_id= excluded.target_course_id,
    special_target  = excluded.special_target,
    updated_by      = excluded.updated_by,
    updated_at      = now();

  return jsonb_build_object('ok', true, 'course_id', v_resolved_course_id, 'day_id', v_day_id);
end;
$$;


ALTER FUNCTION public.app_move_student_in_draft(p_registration_period_id uuid, p_semester_id uuid, p_school_id uuid, p_day_of_week smallint, p_student_id uuid, p_target text, p_updated_by uuid) OWNER TO supabase_admin;

--
-- Name: assign_main_role(uuid, uuid); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.assign_main_role(p_user_profile_id uuid, p_role_id uuid) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    v_existing_main_role_id UUID;
    v_is_subrole BOOLEAN;
BEGIN
    -- Check if the provided role is actually a main role (not a subrole)
    SELECT is_subrole INTO v_is_subrole
    FROM roles
    WHERE id = p_role_id;
    
    -- If role doesn't exist, return false
    IF v_is_subrole IS NULL THEN
        RAISE EXCEPTION 'Role with id % does not exist', p_role_id;
    END IF;
    
    -- If the role is a subrole, return false
    IF v_is_subrole = TRUE THEN
        RAISE EXCEPTION 'Role with id % is a subrole, not a main role', p_role_id;
    END IF;
    
    -- Check if user profile exists
    IF NOT EXISTS (SELECT 1 FROM user_profiles WHERE id = p_user_profile_id) THEN
        RAISE EXCEPTION 'User profile with id % does not exist', p_user_profile_id;
    END IF;
    
    -- Find existing main role for this user
    SELECT r.id INTO v_existing_main_role_id
    FROM user_roles ur
    JOIN roles r ON ur.role_id = r.id
    WHERE ur.user_profile_id = p_user_profile_id 
    AND r.is_subrole = FALSE;
    
    -- If there's an existing main role and it's different from the new one
    IF v_existing_main_role_id IS NOT NULL AND v_existing_main_role_id != p_role_id THEN
        -- Remove the existing main role
        DELETE FROM user_roles 
        WHERE user_roles.user_profile_id = p_user_profile_id 
        AND user_roles.role_id = v_existing_main_role_id;
    END IF;
    
    -- If the user doesn't already have this main role, add it
    IF v_existing_main_role_id IS NULL OR v_existing_main_role_id != p_role_id THEN
        INSERT INTO user_roles (user_profile_id, role_id)
        VALUES (p_user_profile_id, p_role_id)
        ON CONFLICT (user_profile_id, role_id) DO NOTHING;
    END IF;
    
    RETURN TRUE;
    
EXCEPTION
    WHEN OTHERS THEN
        -- Log the error and re-raise
        RAISE;
END;
$$;


ALTER FUNCTION public.assign_main_role(p_user_profile_id uuid, p_role_id uuid) OWNER TO supabase_admin;

--
-- Name: assign_substitute(uuid, uuid[], uuid[], text, uuid); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.assign_substitute(p_lesson_id uuid, p_substitute_staff_ids uuid[], p_absent_teacher_ids uuid[], p_reason text, p_created_by uuid DEFAULT NULL::uuid) RETURNS SETOF uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_created_by uuid := COALESCE(p_created_by, auth.uid());
  v_existing_id uuid;
  v_status text;
  v_sub_id uuid;
BEGIN
  -- If no substitute chosen, check if a PENDING substitution exists for this lesson, and delete them all
  IF array_length(p_substitute_staff_ids, 1) IS NULL OR array_length(p_substitute_staff_ids, 1) = 0 THEN
    FOR v_existing_id, v_status IN
      SELECT id, status FROM substitutions WHERE original_lesson_id = p_lesson_id
    LOOP
      IF v_status IS NULL OR v_status IN ('pending', 'draft') THEN
        DELETE FROM substitutions WHERE id = v_existing_id;
      END IF;
    END LOOP;
    RETURN;
  END IF;

  -- Upsert logic: for each substitute, make sure a row exists (update if needed)
  FOREACH v_sub_id IN ARRAY p_substitute_staff_ids LOOP
    SELECT id INTO v_existing_id
    FROM substitutions
    WHERE original_lesson_id = p_lesson_id
      AND substitute_staff_id = v_sub_id;

    IF v_existing_id IS NOT NULL THEN
      UPDATE substitutions
      SET
        absent_teacher_ids = p_absent_teacher_ids,
        reason = p_reason,
        created_by = v_created_by,
        created_at = now()
      WHERE id = v_existing_id;
      RETURN NEXT v_existing_id;
    ELSE
      v_existing_id := gen_random_uuid();
      INSERT INTO substitutions (
        id, original_lesson_id, substitute_staff_id, absent_teacher_ids, reason, created_by, created_at
      )
      VALUES (
        v_existing_id, p_lesson_id, v_sub_id, p_absent_teacher_ids, p_reason, v_created_by, now()
      );
      RETURN NEXT v_existing_id;
    END IF;
  END LOOP;

  -- Clean up: delete any other substitutions for this lesson not in the new array
  DELETE FROM substitutions
  WHERE original_lesson_id = p_lesson_id
    AND (substitute_staff_id IS NULL OR NOT (substitute_staff_id = ANY(p_substitute_staff_ids)));

END;
$$;


ALTER FUNCTION public.assign_substitute(p_lesson_id uuid, p_substitute_staff_ids uuid[], p_absent_teacher_ids uuid[], p_reason text, p_created_by uuid) OWNER TO supabase_admin;

--
-- Name: assign_unique_colors_to_classes(uuid[]); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.assign_unique_colors_to_classes(class_ids uuid[]) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
  preset_colors TEXT[] := ARRAY[
    '#e6194b', '#3cb44b', '#ffe119', '#4363d8', '#f58231',
    '#911eb4', '#46f0f0', '#f032e6', '#bcf60c', '#fabebe',
    '#008080', '#e6beff', '#9a6324', '#fffac8', '#800000',
    '#aaffc3', '#808000', '#ffd8b1', '#000075', '#a9a9ff',
    '#ffb3ba', '#bae1ff', '#baffc9', '#ffdfba', '#cbaacb',
    '#ff9cee', '#ffffb5', '#c2f0c2', '#d9b3ff', '#f4cccc',
    '#ff6961', '#77dd77', '#fdfd96', '#84b6f4', '#fdcae1',
    '#40e0d0', '#ffb347', '#d2691e', '#dda0dd', '#00ced1',
    '#f0e68c', '#98fb98', '#ffa07a', '#afeeee', '#ffdab9',
    '#ff7f50', '#da70d6', '#ff69b4', '#cd5c5c', '#ffd700'
  ];
  used_indexes INTEGER[] := '{}';
  max_index INTEGER := array_length(preset_colors, 1);
  i INTEGER := 1;
  random_index INTEGER;
  class_id UUID;
BEGIN
  IF array_length(class_ids, 1) > max_index THEN
    RAISE EXCEPTION 'Not enough unique colors for % classes (only % available)', array_length(class_ids, 1), max_index;
  END IF;

  FOREACH class_id IN ARRAY class_ids LOOP
    LOOP
      random_index := floor(random() * max_index + 1);
      IF NOT random_index = ANY (used_indexes) THEN
        used_indexes := used_indexes || random_index;
        EXIT;
      END IF;
    END LOOP;

    UPDATE structure_classes
    SET color = preset_colors[random_index]
    WHERE id = class_id;
  END LOOP;
END;
$$;


ALTER FUNCTION public.assign_unique_colors_to_classes(class_ids uuid[]) OWNER TO supabase_admin;

--
-- Name: attempt_role_deletion(uuid); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.attempt_role_deletion(p_role_id uuid) RETURNS TABLE(can_delete boolean, block_reason text, usage_count integer, protection_level text, recommendations text[])
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    v_usage_count integer;
    v_protection_level text;
    v_protection_reason text;
    v_role_name text;
    v_current_user_role text;
    v_recommendations text[] := ARRAY[]::text[];
BEGIN
    -- Get role details
    SELECT name INTO v_role_name FROM roles WHERE id = p_role_id;
    
    IF v_role_name IS NULL THEN
        RETURN QUERY SELECT false, 'Role not found', 0, NULL::text, ARRAY['Role does not exist']::text[];
        RETURN;
    END IF;

    -- Get current user role
    SELECT r.name INTO v_current_user_role
    FROM user_profiles up
    JOIN roles r ON up.role_id = r.id
    WHERE up.id = auth.uid()::uuid;

    -- Get usage count
    SELECT total_usage INTO v_usage_count FROM get_role_usage_count(p_role_id);

    -- Get protection info
    SELECT protection_level, protection_reason 
    INTO v_protection_level, v_protection_reason
    FROM protected_roles WHERE role_id = p_role_id;

    -- Check deletion possibility
    IF v_protection_level = 'CRITICAL' THEN
        v_recommendations := array_append(v_recommendations, 'Contact system administrator to unprotect this critical role');
        RETURN QUERY SELECT false, 'Critical system role cannot be deleted', v_usage_count, v_protection_level, v_recommendations;
        RETURN;
    END IF;

    IF v_usage_count > 0 THEN
        v_recommendations := array_append(v_recommendations, format('Remove role from %s users first', v_usage_count));
        v_recommendations := array_append(v_recommendations, 'Use bulk role reassignment functions');
        RETURN QUERY SELECT false, format('Role is assigned to %s users', v_usage_count), v_usage_count, v_protection_level, v_recommendations;
        RETURN;
    END IF;

    IF v_protection_level = 'IMPORTANT' AND v_current_user_role != 'Admin' THEN
        v_recommendations := array_append(v_recommendations, 'Admin permission required for important roles');
        RETURN QUERY SELECT false, 'Insufficient permissions', v_usage_count, v_protection_level, v_recommendations;
        RETURN;
    END IF;

    -- If we get here, deletion should be possible
    v_recommendations := array_append(v_recommendations, 'Role can be safely deleted');
    v_recommendations := array_append(v_recommendations, 'Deletion will be logged in audit trail');
    
    RETURN QUERY SELECT true, 'Deletion allowed', v_usage_count, v_protection_level, v_recommendations;
END;
$$;


ALTER FUNCTION public.attempt_role_deletion(p_role_id uuid) OWNER TO supabase_admin;

--
-- Name: bulk_generate_parent_student_codes(jsonb[]); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.bulk_generate_parent_student_codes(code_requests jsonb[]) RETURNS json
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    code_request JSONB;
    child_profile_id UUID;
    code_instance INTEGER;
    created_by UUID;
    notes TEXT;
    result JSON;
    generated_codes JSON[] := '{}';
    existing_codes JSON[] := '{}';
    error_messages TEXT[] := '{}';
    code_result JSON;
BEGIN
    -- Process each code request
    FOREACH code_request IN ARRAY code_requests LOOP
        child_profile_id := (code_request->>'child_profile_id')::UUID;
        code_instance := (code_request->>'code_instance')::INTEGER;
        created_by := (code_request->>'created_by')::UUID;
        notes := code_request->>'notes';

        -- Generate code for this instance
        SELECT generate_user_code(
            child_profile_id,
            code_instance,
            created_by,
            notes
        ) INTO code_result;

        -- Categorize result
        IF (code_result->>'success')::BOOLEAN THEN
            IF (code_result->>'is_new')::BOOLEAN THEN
                generated_codes := array_append(generated_codes,
                    json_build_object(
                        'child_profile_id', child_profile_id,
                        'code_instance', code_instance,
                        'code', code_result->>'code',
                        'is_new', true
                    )
                );
            ELSE
                existing_codes := array_append(existing_codes,
                    json_build_object(
                        'child_profile_id', child_profile_id,
                        'code_instance', code_instance,
                        'code', code_result->>'code',
                        'is_new', false
                    )
                );
            END IF;
        ELSE
            error_messages := array_append(error_messages,
                format('Failed for %s (instance %s): %s',
                    child_profile_id,
                    code_instance,
                    code_result->>'error'
                )
            );
        END IF;
    END LOOP;

    -- Build final result
    result := json_build_object(
        'success', true,
        'total_requested', array_length(code_requests, 1),
        'codes', array_cat(existing_codes, generated_codes),
        'errors', error_messages,
        'summary', json_build_object(
            'total_codes_returned', array_length(existing_codes, 1) + array_length(generated_codes, 1),
            'existing_count', array_length(existing_codes, 1),
            'generated_count', array_length(generated_codes, 1),
            'error_count', array_length(error_messages, 1)
        )
    );

    RETURN result;

EXCEPTION
    WHEN OTHERS THEN
        RETURN json_build_object(
            'success', false,
            'error', SQLERRM,
            'total_requested', array_length(code_requests, 1),
            'codes', '[]'::json,
            'errors', array_append(error_messages, SQLERRM)
        );
END;
$$;


ALTER FUNCTION public.bulk_generate_parent_student_codes(code_requests jsonb[]) OWNER TO supabase_admin;

--
-- Name: bulk_get_or_generate_user_codes(uuid[]); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.bulk_get_or_generate_user_codes(profile_ids uuid[]) RETURNS json
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$DECLARE
    current_profile_id UUID;
    existing_code VARCHAR(6);
    new_code VARCHAR(6);
    code_exists BOOLEAN;
    attempt_count INTEGER := 0;
    max_attempts INTEGER := 100;
    result JSON;
    results JSON[] := '{}';
    valid_profile_ids UUID[] := '{}';
    invalid_profile_ids UUID[] := '{}';
    generated_codes JSON[] := '{}';
    existing_codes JSON[] := '{}';
    error_messages TEXT[] := '{}';
BEGIN
    -- Validate all profile IDs first
    FOREACH current_profile_id IN ARRAY profile_ids LOOP
        IF EXISTS(SELECT 1 FROM public.user_profiles WHERE id = current_profile_id) THEN
            valid_profile_ids := array_append(valid_profile_ids, current_profile_id);
        ELSE
            invalid_profile_ids := array_append(invalid_profile_ids, current_profile_id);
            error_messages := array_append(error_messages, format('User profile not found: %s', current_profile_id));
        END IF;
    END LOOP;

    -- Process valid profile IDs
    FOREACH current_profile_id IN ARRAY valid_profile_ids LOOP
        -- Check if there's an existing unused code for this profile (instance 1, not expired)
        SELECT code INTO existing_code
        FROM user_codes
        WHERE user_codes.profile_id = current_profile_id
        AND code_instance = 1
        AND used_at IS NULL
        AND revoked_at IS NULL
        AND expires_at > NOW()
        ORDER BY created_at DESC
        LIMIT 1;

        -- If existing code found, add to existing codes
        IF existing_code IS NOT NULL THEN
            existing_codes := array_append(existing_codes,
                json_build_object(
                    'profile_id', current_profile_id,
                    'code', existing_code,
                    'is_new', false
                )
            );
        ELSE
            -- Generate unique code (retry if collision occurs)
            attempt_count := 0;
            LOOP
                new_code := generate_random_code();
                attempt_count := attempt_count + 1;

                -- Check if code already exists (not expired)
                SELECT EXISTS(
                    SELECT 1 FROM user_codes
                    WHERE code = new_code
                    AND used_at IS NULL
                    AND revoked_at IS NULL
                    AND expires_at > NOW()
                ) INTO code_exists;

                -- Exit loop if code is unique or max attempts reached
                IF NOT code_exists OR attempt_count >= max_attempts THEN
                    EXIT;
                END IF;
            END LOOP;

            -- If we couldn't generate a unique code after max attempts
            IF code_exists AND attempt_count >= max_attempts THEN
                error_messages := array_append(error_messages,
                    format('Unable to generate unique code for profile: %s', current_profile_id)
                );
            ELSE
                -- Insert the new code
                INSERT INTO user_codes (profile_id, code, code_instance)
                VALUES (current_profile_id, new_code, 1);

                -- Add to generated codes
                generated_codes := array_append(generated_codes,
                    json_build_object(
                        'profile_id', current_profile_id,
                        'code', new_code,
                        'is_new', true
                    )
                );
            END IF;
        END IF;
    END LOOP;

    -- Build final result
    result := json_build_object(
        'success', true,
        'total_requested', array_length(profile_ids, 1),
        'valid_profiles', array_length(valid_profile_ids, 1),
        'invalid_profiles', array_length(invalid_profile_ids, 1),
        'codes', array_cat(existing_codes, generated_codes),
        'errors', error_messages,
        'summary', json_build_object(
            'total_codes_returned', array_length(existing_codes, 1) + array_length(generated_codes, 1),
            'existing_count', array_length(existing_codes, 1),
            'generated_count', array_length(generated_codes, 1),
            'error_count', array_length(error_messages, 1)
        )
    );

    RETURN result;

EXCEPTION
    WHEN OTHERS THEN
        RETURN json_build_object(
            'success', false,
            'error', SQLERRM,
            'total_requested', array_length(profile_ids, 1),
            'codes', '[]'::json,
            'errors', array_append(error_messages, SQLERRM)
        );
END;$$;


ALTER FUNCTION public.bulk_get_or_generate_user_codes(profile_ids uuid[]) OWNER TO supabase_admin;

--
-- Name: bulk_upsert_enrollments_with_logging(jsonb, uuid, uuid, uuid); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.bulk_upsert_enrollments_with_logging(p_enrollments jsonb, p_school_id uuid, p_user_id uuid, p_change_group_id uuid DEFAULT gen_random_uuid()) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
  enrollment JSONB;
  v_id UUID;
  v_existing RECORD;
  v_schedule_ids UUID[];
BEGIN
  FOR enrollment IN SELECT * FROM jsonb_array_elements(p_enrollments)
  LOOP
    v_id := COALESCE((enrollment->>'id')::uuid, gen_random_uuid());

    -- Convert schedule_ids if they exist
    v_schedule_ids := NULL;
    IF enrollment ? 'schedule_ids' THEN
      SELECT ARRAY(
        SELECT jsonb_array_elements_text(enrollment->'schedule_ids')::uuid
      ) INTO v_schedule_ids;
    END IF;

    -- Check if enrollment exists
    SELECT * INTO v_existing FROM public.course_enrollments WHERE id = v_id;

    IF FOUND THEN
      -- Log update
      PERFORM log_manual_change(
        'course_enrollments',
        v_id,
        'update',
        p_user_id,
        p_school_id,
        jsonb_build_object('before', to_jsonb(v_existing), 'after', enrollment),
        p_change_group_id
      );

      -- Update
      UPDATE public.course_enrollments
      SET
        student_id   = (enrollment->>'student_id')::uuid,
        course_id    = (enrollment->>'course_id')::uuid,
        schedule_ids = v_schedule_ids,
        is_trial     = COALESCE((enrollment->>'is_trial')::boolean, false),
        start_date   = (enrollment->>'start_date')::date,
        end_date     = (enrollment->>'end_date')::date
      WHERE id = v_id;

    ELSE
      -- Insert
      INSERT INTO public.course_enrollments (
        id, student_id, course_id, schedule_ids,
        is_trial, start_date, end_date, school_id
      ) VALUES (
        v_id,
        (enrollment->>'student_id')::uuid,
        (enrollment->>'course_id')::uuid,
        v_schedule_ids,
        COALESCE((enrollment->>'is_trial')::boolean, false),
        (enrollment->>'start_date')::date,
        (enrollment->>'end_date')::date,
        p_school_id
      );

      -- Log insert
      PERFORM log_manual_change(
        'course_enrollments',
        v_id,
        'insert',
        p_user_id,
        p_school_id,
        to_jsonb(enrollment),
        p_change_group_id
      );
    END IF;
  END LOOP;
END;
$$;


ALTER FUNCTION public.bulk_upsert_enrollments_with_logging(p_enrollments jsonb, p_school_id uuid, p_user_id uuid, p_change_group_id uuid) OWNER TO supabase_admin;

--
-- Name: bulletin_delete_series(uuid, uuid, uuid); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.bulletin_delete_series(_user_id uuid, _post_id uuid, _change_group_id uuid DEFAULT gen_random_uuid()) RETURNS TABLE(deleted_post_id uuid, deleted_display_from timestamp without time zone)
    LANGUAGE plpgsql
    AS $$
DECLARE
  rec_id        uuid;
  start_date    timestamp without time zone;
  school_id_var uuid;
BEGIN
  -- A) set audit context once
  PERFORM set_config('my.user_id',         _user_id::text,        true);
  PERFORM set_config('my.change_group_id', _change_group_id::text, true);

  -- B) load the target posts series info
  SELECT bp.school_id, bp.recurrence_id, bp.display_from
    INTO school_id_var, rec_id, start_date
    FROM public.bulletin_posts bp
   WHERE bp.id = _post_id;
  IF NOT FOUND THEN
    RAISE EXCEPTION 'Post with id % does not exist.', _post_id;
  END IF;

  -- C) include school in the context
  PERFORM set_config('my.school_id', school_id_var::text, true);

  -- D) if no recurrence, delete just this post
  IF rec_id IS NULL THEN
    DELETE FROM public.bulletin_post_users
     WHERE post_id = _post_id;

    RETURN QUERY
    DELETE FROM public.bulletin_posts
     WHERE id = _post_id
    RETURNING id, display_from;

  ELSE
    -- E) delete all future posts in the series
    DELETE FROM public.bulletin_post_users
     WHERE post_id IN (
       SELECT id FROM public.bulletin_posts
        WHERE recurrence_id = rec_id
          AND display_from >= start_date
     );

    RETURN QUERY
    DELETE FROM public.bulletin_posts
     WHERE recurrence_id = rec_id
       AND display_from >= start_date
    RETURNING id, display_from;
  END IF;
END;
$$;


ALTER FUNCTION public.bulletin_delete_series(_user_id uuid, _post_id uuid, _change_group_id uuid) OWNER TO supabase_admin;

--
-- Name: bulletin_edit_series(uuid, text, text, timestamp without time zone, uuid, jsonb, uuid, boolean, boolean, boolean, uuid[], uuid[]); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.bulletin_edit_series(_post_id uuid, _title text, _body text, _display_from timestamp without time zone, _edited_by uuid, _recurrence jsonb, _change_group_id uuid DEFAULT gen_random_uuid(), _is_important boolean DEFAULT false, _notify_on_post boolean DEFAULT false, _read_required boolean DEFAULT false, _visible_users uuid[] DEFAULT '{}'::uuid[], _visible_groups uuid[] DEFAULT '{}'::uuid[]) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
  old_post           public.bulletin_posts%ROWTYPE;
  _recurrence_id     uuid;
  post_ids_to_delete uuid[];
BEGIN
  -- A) set audit context once
  PERFORM set_config('my.change_group_id', _change_group_id::text, true);
  PERFORM set_config('my.user_id',         _edited_by::text,        true);

  -- B) load the existing post & set school context
  SELECT * INTO old_post
    FROM public.bulletin_posts
   WHERE id = _post_id;
  IF NOT FOUND THEN
    RAISE EXCEPTION 'Post % not found', _post_id;
  END IF;
  PERFORM set_config('my.school_id', old_post.school_id::text, true);

  -- C) prevent editing past posts
  IF old_post.display_from < CURRENT_DATE THEN
    RAISE EXCEPTION 'Cannot edit past posts. This post has already started.';
  END IF;

  -- D) update the current post
  UPDATE public.bulletin_posts
     SET title          = _title,
         body           = _body,
         display_from   = _display_from,
         is_important   = _is_important,
         notify_on_post = _notify_on_post,
         read_required  = _read_required,
         visible_groups = _visible_groups
   WHERE id = _post_id;

  -- E) replace visibleusers links
  DELETE FROM public.bulletin_post_users WHERE post_id = _post_id;
  IF array_length(_visible_users,1) IS NOT NULL THEN
    INSERT INTO public.bulletin_post_users(post_id,user_id)
    SELECT _post_id, unnest(_visible_users);
  END IF;

  -- F) fetch the series ID
  SELECT recurrence_id
    INTO _recurrence_id
    FROM public.bulletin_posts
   WHERE id = _post_id;
  IF _recurrence_id IS NULL THEN
    RAISE EXCEPTION 'This post is not part of a recurring series.';
  END IF;

  -- G) update the recurrence record
  UPDATE public.bulletin_recurrences
     SET start_date          = (_recurrence->>'startDate')::timestamp,
         end_date            = (_recurrence->>'endDate')::timestamp,
         repeat_every_unit   = _recurrence->>'repeatEveryUnit',
         repeat_every_number = (_recurrence->>'repeatEveryNumber')::smallint,
         week_days           = ARRAY(SELECT jsonb_array_elements_text(_recurrence->'weekDays'))::smallint[],
         monthly_text        = _recurrence->>'monthlyText'
   WHERE id = _recurrence_id;

  -- H) delete all future instances (excluding the current one)
  SELECT array_agg(id) INTO post_ids_to_delete
    FROM public.bulletin_posts
   WHERE recurrence_id = _recurrence_id
     AND display_from >= CURRENT_DATE
     AND id <> _post_id;

  IF post_ids_to_delete IS NOT NULL THEN
    DELETE FROM public.bulletin_post_users
     WHERE post_id = ANY(post_ids_to_delete);
    DELETE FROM public.bulletin_posts
     WHERE id = ANY(post_ids_to_delete);
  END IF;

  -- I) regenerate future posts under the same change_group_id
  PERFORM public.bulletin_recurrences_generate(_recurrence_id);
END;
$$;


ALTER FUNCTION public.bulletin_edit_series(_post_id uuid, _title text, _body text, _display_from timestamp without time zone, _edited_by uuid, _recurrence jsonb, _change_group_id uuid, _is_important boolean, _notify_on_post boolean, _read_required boolean, _visible_users uuid[], _visible_groups uuid[]) OWNER TO supabase_admin;

--
-- Name: bulletin_post_add(text, text, uuid, uuid, timestamp without time zone, uuid, text[], boolean, boolean, boolean, boolean, uuid[], uuid[], jsonb); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.bulletin_post_add(_title text, _body text, _school_id uuid, _created_by uuid, _display_from timestamp without time zone, _change_group_id uuid DEFAULT gen_random_uuid(), _attachments text[] DEFAULT '{}'::text[], _is_important boolean DEFAULT false, _notify_on_post boolean DEFAULT false, _is_recurring boolean DEFAULT false, _read_required boolean DEFAULT false, _visible_users uuid[] DEFAULT '{}'::uuid[], _visible_groups uuid[] DEFAULT '{}'::uuid[], _add_recurrence jsonb DEFAULT NULL::jsonb) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
  new_post_id       uuid;
  new_recurrence_id uuid;
BEGIN
  -- 1) Set up context once:
  PERFORM set_config('my.change_group_id', _change_group_id::text, true);
  PERFORM set_config('my.user_id',         _created_by::text,        true);
  PERFORM set_config('my.school_id',       _school_id::text,         true);

  -- 2) Validate
  IF array_length(_visible_users, 1) IS NULL
     AND array_length(_visible_groups, 1) IS NULL THEN
    RAISE EXCEPTION 'Bulletin post must target at least one user or group.';
  END IF;

  -- 3) Insert the base post
  INSERT INTO public.bulletin_posts (
    title, body, school_id, created_by, display_from,
    attachments, is_important, notify_on_post, is_recurring,
    read_required, visible_groups
  ) VALUES (
    _title, _body, _school_id, _created_by, _display_from,
    _attachments, _is_important, _notify_on_post, _is_recurring,
    _read_required, _visible_groups
  )
  RETURNING id INTO new_post_id;

  -- 4) Handle recurrence
  IF _is_recurring AND _add_recurrence IS NOT NULL THEN
    INSERT INTO public.bulletin_recurrences (
      start_date, end_date, repeat_every_unit,
      repeat_every_number, week_days, monthly_text,
      original_post_id
    )
    VALUES (
      (_add_recurrence->>'startDate')::timestamp,
      (_add_recurrence->>'endDate')::timestamp,
      _add_recurrence->>'repeatEveryUnit',
      (_add_recurrence->>'repeatEveryNumber')::smallint,
      ARRAY(SELECT jsonb_array_elements_text(_add_recurrence->'weekDays'))::smallint[],
      _add_recurrence->>'monthlyText',
      new_post_id
    )
    RETURNING id INTO new_recurrence_id;

    UPDATE public.bulletin_posts
      SET recurrence_id = new_recurrence_id
     WHERE id = new_post_id;

    PERFORM public.bulletin_recurrences_generate(new_recurrence_id);
  END IF;

  -- 5) Link visible users
  IF array_length(_visible_users, 1) IS NOT NULL THEN
    INSERT INTO public.bulletin_post_users(post_id, user_id)
    SELECT new_post_id, unnest(_visible_users);
  END IF;

  RETURN new_post_id;
END;
$$;


ALTER FUNCTION public.bulletin_post_add(_title text, _body text, _school_id uuid, _created_by uuid, _display_from timestamp without time zone, _change_group_id uuid, _attachments text[], _is_important boolean, _notify_on_post boolean, _is_recurring boolean, _read_required boolean, _visible_users uuid[], _visible_groups uuid[], _add_recurrence jsonb) OWNER TO supabase_admin;

--
-- Name: bulletin_recurrences_generate(uuid); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.bulletin_recurrences_generate(p_recurrence_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
  rec bulletin_recurrences%ROWTYPE;
BEGIN
  -- load the recurrence record
  SELECT * INTO rec
    FROM public.bulletin_recurrences
   WHERE id = p_recurrence_id;

  IF rec IS NULL THEN
    RAISE EXCEPTION 'Recurrence ID % not found', p_recurrence_id;
  END IF;

  CASE rec.repeat_every_unit
    WHEN 'day' THEN
      IF rec.week_days IS NULL OR coalesce(array_length(rec.week_days,1),0) = 0 THEN
        -- consecutive days
        PERFORM public.bulletin_recurrences_generate_daily_consecutive(rec.id);
      ELSE
        -- only on certain weekdays
        PERFORM public.bulletin_recurrences_generate_daily_on_weekdays(rec.id);
      END IF;

    WHEN 'week' THEN
      PERFORM public.bulletin_recurrences_generate_weekly(rec.id);

    WHEN 'month' THEN
      PERFORM public.bulletin_recurrences_generate_monthly(rec.id);

    ELSE
      RAISE EXCEPTION 'Unsupported repeat_every_unit: %', rec.repeat_every_unit;
  END CASE;
END;
$$;


ALTER FUNCTION public.bulletin_recurrences_generate(p_recurrence_id uuid) OWNER TO supabase_admin;

--
-- Name: bulletin_recurrences_generate_daily_consecutive(uuid); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.bulletin_recurrences_generate_daily_consecutive(p_recurrence_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
  rec bulletin_recurrences%ROWTYPE;
  post bulletin_posts%ROWTYPE;
  current_day date;
BEGIN
  SELECT * INTO rec FROM bulletin_recurrences WHERE id = p_recurrence_id;
  SELECT * INTO post FROM bulletin_posts WHERE id = rec.original_post_id;

  current_day := rec.start_date::date;

  WHILE current_day <= rec.end_date::date LOOP
    IF NOT EXISTS (
      SELECT 1 FROM bulletin_posts WHERE recurrence_id = p_recurrence_id AND display_from = current_day
    ) THEN
      INSERT INTO bulletin_posts (
        title, body, school_id, created_by, display_from, attachments,
        is_important, notify_on_post, is_recurring, read_required, visible_groups,
        recurrence_id
      ) VALUES (
        post.title, post.body, post.school_id, post.created_by, current_day, post.attachments,
        post.is_important, post.notify_on_post, true, post.read_required, post.visible_groups,
        p_recurrence_id
      );
    END IF;
    current_day := current_day + 1;
  END LOOP;
END;
$$;


ALTER FUNCTION public.bulletin_recurrences_generate_daily_consecutive(p_recurrence_id uuid) OWNER TO supabase_admin;

--
-- Name: bulletin_recurrences_generate_daily_on_weekdays(uuid); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.bulletin_recurrences_generate_daily_on_weekdays(p_recurrence_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
  rec bulletin_recurrences%ROWTYPE;
  post bulletin_posts%ROWTYPE;
  current_day date;
BEGIN
  SELECT * INTO rec FROM bulletin_recurrences WHERE id = p_recurrence_id;
  SELECT * INTO post FROM bulletin_posts WHERE id = rec.original_post_id;

  current_day := rec.start_date::date;

  WHILE current_day <= rec.end_date::date LOOP
    IF EXTRACT(DOW FROM current_day)::smallint = ANY (rec.week_days) THEN
      IF NOT EXISTS (
        SELECT 1 FROM bulletin_posts WHERE recurrence_id = p_recurrence_id AND display_from = current_day
      ) THEN
        INSERT INTO bulletin_posts (
          title, body, school_id, created_by, display_from, attachments,
          is_important, notify_on_post, is_recurring, read_required, visible_groups,
          recurrence_id
        ) VALUES (
          post.title, post.body, post.school_id, post.created_by, current_day, post.attachments,
          post.is_important, post.notify_on_post, true, post.read_required, post.visible_groups,
          p_recurrence_id
        );
      END IF;
    END IF;

    current_day := current_day + 1;
  END LOOP;
END;
$$;


ALTER FUNCTION public.bulletin_recurrences_generate_daily_on_weekdays(p_recurrence_id uuid) OWNER TO supabase_admin;

--
-- Name: bulletin_recurrences_generate_monthly(uuid); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.bulletin_recurrences_generate_monthly(p_recurrence_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
  rec bulletin_recurrences%ROWTYPE;
  post bulletin_posts%ROWTYPE;
  current_month date;
  target_date date;
  weekday_idx int;
  nth_week int;
  first_day_of_month date;
  day_of_week_start int;
BEGIN
  SELECT * INTO rec FROM bulletin_recurrences WHERE id = p_recurrence_id;
  SELECT * INTO post FROM bulletin_posts WHERE id = rec.original_post_id;

  current_month := date_trunc('month', rec.start_date)::date;

  WHILE current_month <= rec.end_date::date LOOP
    IF rec.monthly_text = 'day' THEN
      -- Repeat on the same day of the month as start_date
      target_date := make_date(
        EXTRACT(YEAR FROM current_month)::int,
        EXTRACT(MONTH FROM current_month)::int,
        EXTRACT(DAY FROM rec.start_date)::int
      );

      IF target_date >= rec.start_date::date AND target_date <= rec.end_date::date THEN
        IF NOT EXISTS (
          SELECT 1 FROM bulletin_posts WHERE recurrence_id = rec.id AND display_from = target_date
        ) THEN
          INSERT INTO bulletin_posts (
            title, body, school_id, created_by, display_from, attachments,
            is_important, notify_on_post, is_recurring, read_required, visible_groups,
            recurrence_id
          ) VALUES (
            post.title, post.body, post.school_id, post.created_by, target_date, post.attachments,
            post.is_important, post.notify_on_post, true, post.read_required, post.visible_groups,
            rec.id
          );
        END IF;
      END IF;

    ELSIF rec.monthly_text = 'weekday' THEN
      -- Repeat on the nth weekday of the month, e.g., 3rd Tuesday

      weekday_idx := EXTRACT(DOW FROM rec.start_date)::int; -- 0=Sunday ... 6=Saturday
      nth_week := ((EXTRACT(DAY FROM rec.start_date) - 1) / 7) + 1;

      first_day_of_month := date_trunc('month', current_month)::date;
      day_of_week_start := EXTRACT(DOW FROM first_day_of_month)::int;

      target_date := first_day_of_month + ((7 + weekday_idx - day_of_week_start) % 7) + ((nth_week - 1) * 7);

      IF target_date >= rec.start_date::date AND target_date <= rec.end_date::date THEN
        IF NOT EXISTS (
          SELECT 1 FROM bulletin_posts WHERE recurrence_id = rec.id AND display_from = target_date
        ) THEN
          INSERT INTO bulletin_posts (
            title, body, school_id, created_by, display_from, attachments,
            is_important, notify_on_post, is_recurring, read_required, visible_groups,
            recurrence_id
          ) VALUES (
            post.title, post.body, post.school_id, post.created_by, target_date, post.attachments,
            post.is_important, post.notify_on_post, true, post.read_required, post.visible_groups,
            rec.id
          );
        END IF;
      END IF;

    END IF;

    current_month := current_month + INTERVAL '1 month' * rec.repeat_every_number;
  END LOOP;
END;
$$;


ALTER FUNCTION public.bulletin_recurrences_generate_monthly(p_recurrence_id uuid) OWNER TO supabase_admin;

--
-- Name: bulletin_recurrences_generate_weekly(uuid); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.bulletin_recurrences_generate_weekly(p_recurrence_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
  rec bulletin_recurrences%ROWTYPE;
  post bulletin_posts%ROWTYPE;
  current_week_start date;
  i int;
  target_date date;
BEGIN
  SELECT * INTO rec FROM bulletin_recurrences WHERE id = p_recurrence_id;
  SELECT * INTO post FROM bulletin_posts WHERE id = rec.original_post_id;

  -- Calculate Sunday before or equal to startDate (0 = Sunday)
  current_week_start := rec.start_date::date - EXTRACT(DOW FROM rec.start_date::date)::int;

  WHILE current_week_start <= rec.end_date::date LOOP
    FOR i IN 0..6 LOOP
      IF (i = ANY (rec.week_days)) THEN
        target_date := current_week_start + i;

        -- Only create post if on or after startDate and before or equal to endDate
        IF target_date >= rec.start_date::date AND target_date <= rec.end_date::date THEN
          IF NOT EXISTS (
            SELECT 1 FROM bulletin_posts WHERE recurrence_id = rec.id AND display_from = target_date
          ) THEN
            INSERT INTO bulletin_posts (
              title, body, school_id, created_by, display_from, attachments,
              is_important, notify_on_post, is_recurring, read_required, visible_groups,
              recurrence_id
            ) VALUES (
              post.title, post.body, post.school_id, post.created_by, target_date, post.attachments,
              post.is_important, post.notify_on_post, true, post.read_required, post.visible_groups,
              rec.id
            );
          END IF;
        END IF;
      END IF;
    END LOOP;

    -- Move to next recurrence week block
    current_week_start := current_week_start + (rec.repeat_every_number * 7);
  END LOOP;
END;
$$;


ALTER FUNCTION public.bulletin_recurrences_generate_weekly(p_recurrence_id uuid) OWNER TO supabase_admin;

--
-- Name: cad_set_updated_at(); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.cad_set_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
  new.updated_at := now();
  return new;
end;
$$;


ALTER FUNCTION public.cad_set_updated_at() OWNER TO supabase_admin;

--
-- Name: check_bucket_privacy_settings(); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.check_bucket_privacy_settings() RETURNS TABLE(bucket_name text, current_public boolean, intended_public boolean, matches boolean, description text, needs_update boolean, bucket_id text, created_at timestamp with time zone, file_size_limit bigint)
    LANGUAGE sql STABLE SECURITY DEFINER
    AS $$
    WITH intended_settings AS (
        -- SECURE DEFAULTS - Everything private unless specifically needed
        SELECT 
            'school-logo'::TEXT AS name,
            FALSE AS public_setting,  -- CHANGED: Private by default
            'School logos and branding assets (PRIVATE for security)'::TEXT AS description
        UNION ALL SELECT 'student-profile-pictures', FALSE, 'Student profile photos (PRIVATE - contains student data)'
        UNION ALL SELECT 'subject-icons', FALSE, 'Icons for academic subjects (PRIVATE by default)'  
        UNION ALL SELECT 'staff-profile-pictures', FALSE, 'Staff member profile photos (PRIVATE)'
        UNION ALL SELECT 'staff-documents', FALSE, 'Staff documents and files (PRIVATE)'
        UNION ALL SELECT 'bulletin-attachments', FALSE, 'Bulletin board attachments (PRIVATE)'
        UNION ALL SELECT 'absence-documents', FALSE, 'Absence related documents (PRIVATE - sensitive student data)'
        UNION ALL SELECT 'course-pictures', FALSE, 'Course and class photos (PRIVATE - may contain student faces)'
    ),
    bucket_comparison AS (
        SELECT 
            b.name,
            b.public AS current_public,
            i.public_setting AS intended_public,
            (b.public = i.public_setting) AS matches,
            i.description,
            (b.public != i.public_setting) AS needs_update,
            b.id,
            b.created_at,
            b.file_size_limit
        FROM storage.buckets b
        INNER JOIN intended_settings i ON b.name = i.name
    )
    SELECT 
        bc.name,
        bc.current_public,
        bc.intended_public,
        bc.matches,
        bc.description,
        bc.needs_update,
        bc.id,
        bc.created_at,
        bc.file_size_limit
    FROM bucket_comparison bc
    ORDER BY bc.name;
$$;


ALTER FUNCTION public.check_bucket_privacy_settings() OWNER TO supabase_admin;

--
-- Name: FUNCTION check_bucket_privacy_settings(); Type: COMMENT; Schema: public; Owner: supabase_admin
--

COMMENT ON FUNCTION public.check_bucket_privacy_settings() IS 'Checks bucket privacy settings against intended configurations and returns detailed comparison';


--
-- Name: check_existing_auth_user(text); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.check_existing_auth_user(p_email text) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_user_exists BOOLEAN;
BEGIN
  -- Check if user exists in auth.users table
  SELECT EXISTS(
    SELECT 1
    FROM auth.users
    WHERE email = p_email
  ) INTO v_user_exists;

  RETURN v_user_exists;
END;
$$;


ALTER FUNCTION public.check_existing_auth_user(p_email text) OWNER TO supabase_admin;

--
-- Name: check_in_student(jsonb); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.check_in_student(data jsonb) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  student UUID := (data->>'student_id')::UUID;
  staff UUID := (data->>'staff_id')::UUID;
  method TEXT := COALESCE(data->>'method', 'manual');
  today_log_id UUID;
  student_school_id UUID;
BEGIN
  -- Get the student's school_id
  SELECT school_id INTO student_school_id
  FROM user_profiles
  WHERE id = student;
  
  IF student_school_id IS NULL THEN
    RAISE EXCEPTION 'Student school_id not found for student_id: %', student;
  END IF;

  SELECT id INTO today_log_id
  FROM student_daily_log
  WHERE student_id = student AND date = CURRENT_DATE;

  IF NOT FOUND THEN
    INSERT INTO student_daily_log (
      id, student_id, date, check_in_time, check_in_by, check_in_method, presence_status
    ) VALUES (
      gen_random_uuid(), student, CURRENT_DATE, now(), staff, method, 'present'
    )
    RETURNING id INTO today_log_id;
  ELSE
    UPDATE student_daily_log
    SET
      check_in_time = now(),
      check_in_by = staff,
      check_in_method = method,
      presence_status = 'present',
      updated_at = now()
    WHERE id = today_log_id;
  END IF;

  -- FIX: Add school_id to the insert
  INSERT INTO student_presence_events (
    id, daily_log_id, student_id, event_type, timestamp, method, performed_by, school_id
  ) VALUES (
    gen_random_uuid(), today_log_id, student, 'check_in', now(), method, staff, student_school_id
  );
END;
$$;


ALTER FUNCTION public.check_in_student(data jsonb) OWNER TO supabase_admin;

--
-- Name: cleanup_old_codes(integer); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.cleanup_old_codes(expiry_days integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    deleted_count INTEGER;
BEGIN
    -- Delete unused codes that have expired
    DELETE FROM user_codes
    WHERE used_at IS NULL
    AND revoked_at IS NULL
    AND expires_at < NOW();

    GET DIAGNOSTICS deleted_count = ROW_COUNT;

    RETURN deleted_count;
END;
$$;


ALTER FUNCTION public.cleanup_old_codes(expiry_days integer) OWNER TO supabase_admin;

--
-- Name: create_course_secure(text, date, date, integer[], text, uuid, integer, text, text, text[]); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.create_course_secure(_name text, _start_date date, _end_date date, _is_for_year_g integer[], _course_code text DEFAULT NULL::text, _subject_id uuid DEFAULT NULL::uuid, _max_students integer DEFAULT NULL::integer, _description text DEFAULT NULL::text, _wichtige_infos text DEFAULT NULL::text, _pictures text[] DEFAULT ARRAY[]::text[]) RETURNS TABLE(course_id uuid, course_name text)
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
declare
  current_user_id uuid := auth.uid();
  current_school_id uuid;
begin
  if current_user_id is null then
    raise exception 'Not authenticated';
  end if;

  select school_id
  into current_school_id
  from user_profiles
  where id = current_user_id;

  if current_school_id is null then
    raise exception 'No school assigned to this user';
  end if;

  insert into public.course_list (
    name,
    course_code,
    subject_id,
    max_students,
    start_date,
    end_date,
    is_for_year_g,
    description,
    wichtige_infos,
    pictures,
    school_id
  )
  values (
    _name,
    _course_code,
    _subject_id,
    _max_students,
    _start_date,
    _end_date,
    _is_for_year_g,
    _description,
    _wichtige_infos,
    coalesce(_pictures, array[]::text[]),
    current_school_id
  )
  returning course_list.id, course_list.name into course_id, course_name;
end;
$$;


ALTER FUNCTION public.create_course_secure(_name text, _start_date date, _end_date date, _is_for_year_g integer[], _course_code text, _subject_id uuid, _max_students integer, _description text, _wichtige_infos text, _pictures text[]) OWNER TO supabase_admin;

--
-- Name: create_course_with_options(uuid, text, text, uuid, integer, date, date, integer[], text, text, text[], uuid[], text[], boolean, uuid); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.create_course_with_options(_user_id uuid, _name text, _course_code text, _subject_id uuid, _max_students integer, _start_date date, _end_date date, _is_for_year_g integer[], _description text, _wichtige_infos text, _pictures text[], _possible_staff_members uuid[], _possible_times text[], _description_visible_to_parents boolean, _possible_room_id uuid DEFAULT NULL::uuid) RETURNS TABLE(course_id uuid, course_name text)
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
declare
  current_school_id uuid;
  current_profile_id uuid;
  p_entry text;
  weekday smallint;
  schedule_period_id uuid;
  start_time time;
  duration_minutes int;
begin
  -- 1. Auth check
  if _user_id is null then
    raise exception 'User ID must be provided';
  end if;

  -- 2. Set session variable for audit logging
  perform set_config('my.user_id', _user_id::text, true);

  -- 3. Resolve profile + school directly from auth.users
  select u.id, u.school_id
  into current_profile_id, current_school_id
  from auth.users au
  join user_profiles u
    on (au.raw_user_meta_data->>'profile_id')::uuid = u.id
  where au.id = _user_id;

  if current_school_id is null then
    raise exception 'No school assigned to this user';
  end if;

  -- Optional: validate possible_room_id belongs to this school (and is active)
  if _possible_room_id is not null then
    perform 1
    from public.structure_rooms r
    where r.id = _possible_room_id
      and r.school_id = current_school_id
      and coalesce(r.is_active, true);
    if not found then
      raise exception 'possible_room_id % not found for this school or is inactive', _possible_room_id;
    end if;
  end if;

  -- 4. Insert course (including parent visibility and possible_room_id)
  insert into public.course_list (
    name,
    course_code,
    subject_id,
    max_students,
    start_date,
    end_date,
    is_for_year_g,
    description,
    description_visible_to_parents,
    wichtige_infos,
    pictures,
    school_id,
    possible_staff_members,
    possible_room_id
  )
  values (
    _name,
    _course_code,
    _subject_id,
    _max_students,
    _start_date,
    _end_date,
    _is_for_year_g,
    _description,
    coalesce(_description_visible_to_parents, false),
    _wichtige_infos,
    coalesce(_pictures, array[]::text[]),
    current_school_id,
    coalesce(_possible_staff_members, array[]::uuid[]),
    _possible_room_id
  )
  returning id, name into course_id, course_name;

  -- 5. Insert possible times
  foreach p_entry in array _possible_times
  loop
    begin
      weekday := split_part(p_entry, '|', 1)::smallint;
      schedule_period_id := split_part(p_entry, '|', 2)::uuid;
      start_time := null;
      duration_minutes := null;

      if weekday < 1 or weekday > 6 then
        raise exception 'Invalid weekday in possible time: %', p_entry;
      end if;

      if array_length(string_to_array(p_entry, '|'), 1) >= 4 then
        start_time := nullif(split_part(p_entry, '|', 3), '')::time;
        duration_minutes := nullif(split_part(p_entry, '|', 4), '')::int;
      end if;

      insert into course_possible_times (
        course_id,
        school_id,
        weekday,
        schedule_period_id,
        is_custom_time,
        custom_start,
        custom_duration,
        created_by
      )
      values (
        course_id,
        current_school_id,
        weekday,
        schedule_period_id,
        start_time is not null,
        start_time,
        case
          when duration_minutes is not null then (duration_minutes || ' minutes')::interval
          else null
        end,
        current_profile_id
      );

    exception when others then
      raise exception 'Failed to insert possible time %: %', p_entry, sqlerrm;
    end;
  end loop;

end;
$$;


ALTER FUNCTION public.create_course_with_options(_user_id uuid, _name text, _course_code text, _subject_id uuid, _max_students integer, _start_date date, _end_date date, _is_for_year_g integer[], _description text, _wichtige_infos text, _pictures text[], _possible_staff_members uuid[], _possible_times text[], _description_visible_to_parents boolean, _possible_room_id uuid) OWNER TO supabase_admin;

--
-- Name: create_course_with_options_alt(uuid, text, text, uuid, integer, date, date, integer[], text, text, text[], uuid[], text[]); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.create_course_with_options_alt(_user_id uuid, _name text, _course_code text, _subject_id uuid, _max_students integer, _start_date date, _end_date date, _is_for_year_g integer[], _description text, _wichtige_infos text, _pictures text[], _possible_staff_members uuid[], _possible_times text[]) RETURNS TABLE(course_id uuid, course_name text)
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$declare
  current_school_id uuid;
  current_profile_id uuid;
  p_entry text;
  weekday smallint;
  schedule_period_id uuid;
  start_time time;
  duration_minutes int;
begin
  -- 1. Auth check
  if _user_id is null then
    raise exception 'User ID must be provided';
  end if;

  -- 2. Set session variable for audit logging
  perform set_config('my.user_id', _user_id::text, true);

  -- 3. Resolve profile + school directly from auth.users
  select u.id, u.school_id
  into current_profile_id, current_school_id
  from auth.users au
  join user_profiles u
    on (au.raw_user_meta_data->>'profile_id')::uuid = u.id
  where au.id = _user_id;

  if current_school_id is null then
    raise exception 'No school assigned to this user';
  end if;

  -- 4. Insert course
  insert into public.course_list (
    name,
    course_code,
    subject_id,
    max_students,
    start_date,
    end_date,
    is_for_year_g,
    description,
    wichtige_infos,
    pictures,
    school_id,
    possible_staff_members
  )
  values (
    _name,
    _course_code,
    _subject_id,
    _max_students,
    _start_date,
    _end_date,
    _is_for_year_g,
    _description,
    _wichtige_infos,
    coalesce(_pictures, array[]::text[]),
    current_school_id,
    coalesce(_possible_staff_members, array[]::uuid[])
  )
  returning id, name into course_id, course_name;

  -- 5. Insert possible times
  foreach p_entry in array _possible_times
  loop
    begin
      weekday := split_part(p_entry, '|', 1)::smallint;
      schedule_period_id := split_part(p_entry, '|', 2)::uuid;
      start_time := null;
      duration_minutes := null;

      if weekday < 1 or weekday > 6 then
        raise exception 'Invalid weekday in possible time: %', p_entry;
      end if;

      if array_length(string_to_array(p_entry, '|'), 1) >= 4 then
        start_time := nullif(split_part(p_entry, '|', 3), '')::time;
        duration_minutes := nullif(split_part(p_entry, '|', 4), '')::int;
      end if;

      insert into course_possible_times (
        course_id,
        school_id,
        weekday,
        schedule_period_id,
        is_custom_time,
        custom_start,
        custom_duration
      )
      values (
        course_id,
        current_school_id,
        weekday,
        schedule_period_id,
        start_time is not null,
        start_time,
        case
          when duration_minutes is not null then (duration_minutes || ' minutes')::interval
          else null
        end
      );

    exception when others then
      raise exception 'Failed to insert possible time %: %', p_entry, sqlerrm;
    end;
  end loop;

end;$$;


ALTER FUNCTION public.create_course_with_options_alt(_user_id uuid, _name text, _course_code text, _subject_id uuid, _max_students integer, _start_date date, _end_date date, _is_for_year_g integer[], _description text, _wichtige_infos text, _pictures text[], _possible_staff_members uuid[], _possible_times text[]) OWNER TO supabase_admin;

--
-- Name: create_course_with_options_alt(uuid, text, text, uuid, integer, date, date, integer[], text, text, text[], uuid[], text[], boolean); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.create_course_with_options_alt(_user_id uuid, _name text, _course_code text, _subject_id uuid, _max_students integer, _start_date date, _end_date date, _is_for_year_g integer[], _description text, _wichtige_infos text, _pictures text[], _possible_staff_members uuid[], _possible_times text[], _description_visible_to_parents boolean DEFAULT false) RETURNS TABLE(course_id uuid, course_name text)
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$declare
  current_school_id uuid;
  current_profile_id uuid;
  p_entry text;
  weekday smallint;
  schedule_period_id uuid;
  start_time time;
  duration_minutes int;
begin
  -- 1. Auth check
  if _user_id is null then
    raise exception 'User ID must be provided';
  end if;

  -- 2. Set session variable for audit logging
  perform set_config('my.user_id', _user_id::text, true);

  -- 3. Resolve profile + school directly from auth.users
  select u.id, u.school_id
  into current_profile_id, current_school_id
  from auth.users au
  join user_profiles u
    on (au.raw_user_meta_data->>'profile_id')::uuid = u.id
  where au.id = _user_id;

  if current_school_id is null then
    raise exception 'No school assigned to this user';
  end if;

  -- 4. Insert course (including description and parent visibility flag)
  insert into public.course_list (
    name,
    course_code,
    subject_id,
    max_students,
    start_date,
    end_date,
    is_for_year_g,
    description,
    description_visible_to_parents,
    wichtige_infos,
    pictures,
    school_id,
    possible_staff_members
  )
  values (
    _name,
    _course_code,
    _subject_id,
    _max_students,
    _start_date,
    _end_date,
    _is_for_year_g,
    _description,
    coalesce(_description_visible_to_parents, false),
    _wichtige_infos,
    coalesce(_pictures, array[]::text[]),
    current_school_id,
    coalesce(_possible_staff_members, array[]::uuid[])
  )
  returning id, name into course_id, course_name;

  -- 5. Insert possible times
  foreach p_entry in array _possible_times
  loop
    begin
      weekday := split_part(p_entry, '|', 1)::smallint;
      schedule_period_id := split_part(p_entry, '|', 2)::uuid;
      start_time := null;
      duration_minutes := null;

      if weekday < 1 or weekday > 6 then
        raise exception 'Invalid weekday in possible time: %', p_entry;
      end if;

      if array_length(string_to_array(p_entry, '|'), 1) >= 4 then
        start_time := nullif(split_part(p_entry, '|', 3), '')::time;
        duration_minutes := nullif(split_part(p_entry, '|', 4), '')::int;
      end if;

      insert into course_possible_times (
        course_id,
        school_id,
        weekday,
        schedule_period_id,
        is_custom_time,
        custom_start,
        custom_duration,
        created_by
      )
      values (
        course_id,
        current_school_id,
        weekday,
        schedule_period_id,
        start_time is not null,
        start_time,
        case
          when duration_minutes is not null then (duration_minutes || ' minutes')::interval
          else null
        end,
        current_profile_id
      );

    exception when others then
      raise exception 'Failed to insert possible time %: %', p_entry, sqlerrm;
    end;
  end loop;

end;$$;


ALTER FUNCTION public.create_course_with_options_alt(_user_id uuid, _name text, _course_code text, _subject_id uuid, _max_students integer, _start_date date, _end_date date, _is_for_year_g integer[], _description text, _wichtige_infos text, _pictures text[], _possible_staff_members uuid[], _possible_times text[], _description_visible_to_parents boolean) OWNER TO supabase_admin;

--
-- Name: create_family_and_link_student(text, uuid, uuid); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.create_family_and_link_student(in_family_name text, in_student_id uuid, in_user_id uuid) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
declare
  new_family_id uuid;
  student_school_id uuid;
  existing_family_id uuid;
  new_family_code text;
  school_short text;
begin
  -- Check if student already has a family
  select family_id into existing_family_id
  from family_members
  where profile_id = in_student_id and role = 'student' and removed_at is null;

  if existing_family_id is not null then
    return existing_family_id;
  end if;

  -- Get school ID from student profile
  select school_id into student_school_id
  from profile_info_student
  where profile_id = in_student_id;

  -- Get short code from school (first 2 letters of name)
  select upper(left(name, 2)) into school_short
  from structure_schools
  where id = student_school_id;

  -- Generate a unique family_code (e.g. DE12345)
  loop
    new_family_code := school_short || lpad((trunc(random() * 100000)::int)::text, 5, '0');
    exit when not exists (
      select 1 from families where family_code = new_family_code
    );
  end loop;

  -- Insert new family
  insert into families (school_id, family_name, family_code, created_by)
  values (student_school_id, in_family_name, new_family_code, in_user_id)
  returning id into new_family_id;

  -- Add student to family
  insert into family_members (
    family_id,
    profile_id,
    role,
    is_primary_contact,
    added_by
  )
  values (
    new_family_id,
    in_student_id,
    'student',
    false,
    in_user_id
  );

  -- Log to change_log
  insert into change_log (
    user_id,
    school_id,
    table_name,
    record_id,
    action_type,
    after_data
  )
  values (
    in_user_id,
    student_school_id,
    'families',
    new_family_id,
    'insert',
    jsonb_build_object(
      'school_id', student_school_id,
      'family_name', in_family_name,
      'family_code', new_family_code,
      'created_by', in_user_id
    )
  );

  return new_family_id;
end;
$$;


ALTER FUNCTION public.create_family_and_link_student(in_family_name text, in_student_id uuid, in_user_id uuid) OWNER TO supabase_admin;

--
-- Name: create_or_update_subject_schedule(uuid, uuid, uuid, integer, uuid, uuid[], uuid, date, date, time without time zone, time without time zone); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.create_or_update_subject_schedule(_subject_id uuid, _class_id uuid, _period_id uuid, _day_id integer, _room_id uuid, _staff_ids uuid[], _school_id uuid, _start_date date, _end_date date, _start_time time without time zone, _end_time time without time zone) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
  existing_schedule_id uuid;
  v_course_id uuid;  -- Declare the course_id variable
BEGIN
  -- If start_time or end_time are NULL, provide default values
  IF _start_time IS NULL THEN
    _start_time := '08:00:00'::time;  -- Default start time
  END IF;

  IF _end_time IS NULL THEN
    _end_time := '09:00:00'::time;  -- Default end time
  END IF;

  -- Ensure that either course_id or subject_id is set, if one is NULL, use the other
  IF _subject_id IS NULL AND v_course_id IS NULL THEN
    RAISE EXCEPTION 'Both subject_id and course_id cannot be NULL for schedule';
  ELSIF v_course_id IS NULL THEN
    v_course_id := NULL;  -- Ensure it's explicitly NULL for subject-based schedules
  ELSIF _subject_id IS NULL THEN
    _subject_id := NULL;  -- Ensure it's explicitly NULL for course-based schedules
  END IF;

  -- Log the updated start_time, end_time, course_id and subject_id
  INSERT INTO debug_logs(message) VALUES (
    'Using start_time: ' || _start_time || ', end_time: ' || _end_time ||
    ', course_id: ' || COALESCE(v_course_id::text, 'NULL') ||
    ', subject_id: ' || COALESCE(_subject_id::text, 'NULL')
  );

  -- Check if a matching subject-based schedule already exists
  SELECT cs.id INTO existing_schedule_id
  FROM public.course_schedules cs
  WHERE cs.school_id = _school_id
    AND cs.period_id = _period_id
    AND cs.day_id = _day_id
    AND cs.course_id IS NULL  -- subject-based schedule
    AND cs.subject_id = _subject_id
    AND cs.class_id = _class_id
  LIMIT 1;

  IF existing_schedule_id IS NOT NULL THEN
    -- Update existing subject-based schedule
    UPDATE public.course_schedules
    SET teacher_ids = _staff_ids,
        room_id = _room_id,
        start_time = _start_time,
        end_time = _end_time
    WHERE id = existing_schedule_id;

    -- Update lessons tied to this subject-based schedule
    UPDATE public.course_lessons
    SET teacher_ids = _staff_ids,
        room_id = _room_id
    WHERE schedule_id = existing_schedule_id
      AND start_datetime >= _start_date;

    RAISE NOTICE 'Subject-based schedule and lessons updated: %', existing_schedule_id;
  ELSE
    -- Insert new subject-based schedule if it doesn't exist
    INSERT INTO public.course_schedules (
      course_id, subject_id, class_id, day_id, start_date, end_date,
      start_time, end_time, teacher_ids, room_id, school_id, period_id
    )
    VALUES (
      NULL, _subject_id, _class_id, _day_id, _start_date, _end_date,
      _start_time, _end_time, _staff_ids, _room_id, _school_id, _period_id
    )
    RETURNING id INTO existing_schedule_id;

    -- Insert lessons for the new subject-based schedule
    INSERT INTO public.course_lessons (
      course_id, subject_id, class_id, schedule_id, start_datetime, end_datetime,
      school_id, teacher_ids, room_id, period_id, period_ids, is_lesson_based
    )
    SELECT
      NULL, _subject_id, _class_id, existing_schedule_id,
      gs::date + _start_time,
      gs::date + _end_time,
      _school_id, _staff_ids, _room_id,
      _period_id, ARRAY[_period_id], true
    FROM generate_series(_start_date, _end_date, interval '1 day') AS gs
    WHERE extract(dow FROM gs) = _day_id;

    RAISE NOTICE 'Created new subject-based schedule and lessons: %', existing_schedule_id;
  END IF;
END;
$$;


ALTER FUNCTION public.create_or_update_subject_schedule(_subject_id uuid, _class_id uuid, _period_id uuid, _day_id integer, _room_id uuid, _staff_ids uuid[], _school_id uuid, _start_date date, _end_date date, _start_time time without time zone, _end_time time without time zone) OWNER TO supabase_admin;

--
-- Name: create_parent_profile(text, text, uuid, jsonb); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.create_parent_profile(p_first_name text, p_last_name text, p_school_id uuid, p_contact jsonb) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_new_profile_id UUID;
  v_parent_role_id UUID;
  v_result JSONB;
BEGIN
  -- Start transaction
  BEGIN
    -- Get Parent role ID
    SELECT id INTO v_parent_role_id
    FROM roles
    WHERE name = 'Parent'
    LIMIT 1;

    IF v_parent_role_id IS NULL THEN
      RAISE EXCEPTION 'Parent role not found in roles table';
    END IF;

    -- Create user profile
    INSERT INTO user_profiles (first_name, last_name, school_id, role_id, account_status)
    VALUES (p_first_name, p_last_name, p_school_id, v_parent_role_id, 'none')
    RETURNING id INTO v_new_profile_id;

    -- Add user role
    INSERT INTO user_roles (user_profile_id, role_id)
    VALUES (v_new_profile_id, v_parent_role_id)
    ON CONFLICT (user_profile_id, role_id) DO NOTHING;

    -- Add single contact with safer boolean handling
    INSERT INTO contacts (
      profile_id,
      profile_type,
      type,
      value,
      is_primary,
      notes,
      is_linked_to_user_login
    )
    VALUES (
      v_new_profile_id,
      'parent',
      (p_contact->>'contact_type')::TEXT,
      (p_contact->>'contact_value')::TEXT,
      CASE
        WHEN (p_contact->>'is_primary')::TEXT = 'true' THEN TRUE
        WHEN (p_contact->>'is_primary')::TEXT = 'false' THEN FALSE
        WHEN (p_contact->>'is_primary') IS NULL THEN FALSE
        ELSE FALSE
      END,
      (p_contact->>'notes')::TEXT,
      CASE
        WHEN (p_contact->>'is_linked_to_user_login')::TEXT = 'true' THEN TRUE
        WHEN (p_contact->>'is_linked_to_user_login')::TEXT = 'false' THEN FALSE
        WHEN (p_contact->>'is_linked_to_user_login') IS NULL THEN FALSE
        ELSE FALSE
      END
    );

    -- Prepare result
    v_result := jsonb_build_object(
      'success', TRUE,
      'profile_id', v_new_profile_id,
      'role_id', v_parent_role_id,
      'first_name', p_first_name,
      'last_name', p_last_name,
      'school_id', p_school_id
    );

    -- Commit transaction
    RETURN v_result;

  EXCEPTION
    WHEN OTHERS THEN
      -- Rollback transaction on any error
      RAISE EXCEPTION 'Transaction failed: %', SQLERRM;
  END;
END;
$$;


ALTER FUNCTION public.create_parent_profile(p_first_name text, p_last_name text, p_school_id uuid, p_contact jsonb) OWNER TO supabase_admin;

--
-- Name: create_registration_period(uuid, uuid, text, text, text, timestamp with time zone, timestamp with time zone, uuid[], uuid); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.create_registration_period(p_school_id uuid, p_semester_id uuid, p_title text, p_instructions text, p_internal_notes text, p_opens_at timestamp with time zone, p_closes_at timestamp with time zone, p_course_ids uuid[], p_user_id uuid) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_period_id uuid := gen_random_uuid();
    v_now timestamptz := now();
    v_status text;
    v_distinct_courses uuid[];
    v_course_id uuid;
    v_course_grades int[];
BEGIN
    IF p_user_id IS NULL THEN RAISE EXCEPTION 'p_user_id is required'; END IF;
    IF p_title IS NULL OR length(trim(p_title))=0 THEN RAISE EXCEPTION 'title required'; END IF;
    IF p_opens_at IS NULL OR p_closes_at IS NULL OR p_closes_at <= p_opens_at THEN
        RAISE EXCEPTION 'invalid opens/closes';
    END IF;
    IF p_course_ids IS NULL OR array_length(p_course_ids,1)=0 THEN RAISE EXCEPTION 'course_ids required'; END IF;

    SELECT array_agg(DISTINCT cid) INTO v_distinct_courses FROM unnest(p_course_ids) t(cid);

    IF (
        SELECT count(*) FROM public.course_list c
        WHERE c.school_id = p_school_id AND c.id = ANY(v_distinct_courses)
    ) <> array_length(v_distinct_courses,1) THEN
        RAISE EXCEPTION 'one or more course_ids invalid for this school';
    END IF;

    IF p_opens_at > v_now THEN
        v_status := 'scheduled';
    ELSIF p_closes_at > v_now THEN
        v_status := 'open';
    ELSE
        v_status := 'closed';
    END IF;

    INSERT INTO public.registration_periods
        (id, school_id, semester_id, title, instructions, internal_notes, status, created_by_id, updated_by_id)
    VALUES
        (v_period_id, p_school_id, p_semester_id, p_title, p_instructions, p_internal_notes, v_status, p_user_id, p_user_id);

    FOREACH v_course_id IN ARRAY v_distinct_courses LOOP
        SELECT c.is_for_year_g INTO v_course_grades
        FROM public.course_list c
        WHERE c.id = v_course_id AND c.school_id = p_school_id;

        IF v_course_grades IS NULL OR array_length(v_course_grades,1)=0 THEN
            RAISE EXCEPTION 'course % has no grade levels (is_for_year_g)', v_course_id;
        END IF;

        INSERT INTO public.course_registration_windows
            (id, school_id, semester_id, course_id, registration_period_id,
             opens_at, closes_at, grade_levels, created_at, created_by)
        VALUES
            (gen_random_uuid(), p_school_id, p_semester_id, v_course_id, v_period_id,
             p_opens_at, p_closes_at, v_course_grades, v_now, p_user_id);
    END LOOP;

    RETURN v_period_id;
END;
$$;


ALTER FUNCTION public.create_registration_period(p_school_id uuid, p_semester_id uuid, p_title text, p_instructions text, p_internal_notes text, p_opens_at timestamp with time zone, p_closes_at timestamp with time zone, p_course_ids uuid[], p_user_id uuid) OWNER TO supabase_admin;

--
-- Name: create_registration_period(uuid, uuid, text, text, text, timestamp with time zone, timestamp with time zone, uuid[], uuid, integer, integer); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.create_registration_period(p_school_id uuid, p_semester_id uuid, p_title text, p_instructions text, p_internal_notes text, p_opens_at timestamp with time zone, p_closes_at timestamp with time zone, p_course_ids uuid[], p_user_id uuid, p_max_wishes_total integer DEFAULT NULL::integer, p_max_wishes_per_day integer DEFAULT NULL::integer) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_period_id uuid := gen_random_uuid();
    v_now timestamptz := now();
    v_status text;
    v_distinct_courses uuid[];
    v_course_id uuid;
    v_course_grades int[];
BEGIN
    IF p_user_id IS NULL THEN RAISE EXCEPTION 'p_user_id is required'; END IF;
    IF p_title IS NULL OR length(trim(p_title)) = 0 THEN RAISE EXCEPTION 'title required'; END IF;
    IF p_opens_at IS NULL OR p_closes_at IS NULL OR p_closes_at <= p_opens_at THEN
        RAISE EXCEPTION 'invalid opens/closes'; END IF;
    IF p_course_ids IS NULL OR array_length(p_course_ids,1) = 0 THEN
        RAISE EXCEPTION 'course_ids required'; END IF;
    IF (p_max_wishes_total IS NOT NULL AND p_max_wishes_total < 0)
       OR (p_max_wishes_per_day IS NOT NULL AND p_max_wishes_per_day < 0) THEN
        RAISE EXCEPTION 'wish limits must be >= 0 when provided';
    END IF;

    SELECT array_agg(DISTINCT cid) INTO v_distinct_courses
    FROM unnest(p_course_ids) t(cid);

    IF (
        SELECT count(*) FROM public.course_list c
        WHERE c.school_id = p_school_id AND c.id = ANY(v_distinct_courses)
    ) <> array_length(v_distinct_courses,1) THEN
        RAISE EXCEPTION 'one or more course_ids invalid for this school';
    END IF;

    IF p_opens_at > v_now THEN
        v_status := 'scheduled';
    ELSIF p_closes_at > v_now THEN
        v_status := 'open';
    ELSE
        v_status := 'closed';
    END IF;

    INSERT INTO public.registration_periods
        (id, school_id, semester_id, title, instructions, internal_notes,
         status, created_by_id, updated_by_id, max_wishes_total, max_wishes_per_day)
    VALUES
        (v_period_id, p_school_id, p_semester_id, p_title, p_instructions, p_internal_notes,
         v_status, p_user_id, p_user_id, p_max_wishes_total, p_max_wishes_per_day);

    FOREACH v_course_id IN ARRAY v_distinct_courses LOOP
        SELECT c.is_for_year_g INTO v_course_grades
        FROM public.course_list c
        WHERE c.id = v_course_id AND c.school_id = p_school_id;

        IF v_course_grades IS NULL OR array_length(v_course_grades,1) = 0 THEN
            RAISE EXCEPTION 'course % has no grade levels (is_for_year_g)', v_course_id;
        END IF;

        INSERT INTO public.course_registration_windows
            (id, school_id, course_id, semester_id, opens_at, closes_at,
             created_by, registration_period_id, grade_levels)
        VALUES
            (gen_random_uuid(), p_school_id, v_course_id, p_semester_id, p_opens_at, p_closes_at,
             p_user_id, v_period_id, v_course_grades);
    END LOOP;

    RETURN v_period_id;
END;
$$;


ALTER FUNCTION public.create_registration_period(p_school_id uuid, p_semester_id uuid, p_title text, p_instructions text, p_internal_notes text, p_opens_at timestamp with time zone, p_closes_at timestamp with time zone, p_course_ids uuid[], p_user_id uuid, p_max_wishes_total integer, p_max_wishes_per_day integer) OWNER TO supabase_admin;

--
-- Name: create_schedule_and_generate_lessons(uuid, integer, date, date, time without time zone, time without time zone, uuid[], uuid, uuid, uuid, integer); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.create_schedule_and_generate_lessons(_course_id uuid, _day_id integer, _start_date date, _end_date date, _start_time time without time zone, _end_time time without time zone, _teacher_ids uuid[], _room_id uuid, _school_id uuid, _period_id uuid, _period_count integer) RETURNS TABLE(lesson_id uuid, start_datetime timestamp without time zone, end_datetime timestamp without time zone)
    LANGUAGE plpgsql
    AS $$
declare
  schedule_id uuid;
  weekday_number int;
  period_ids uuid[];
  start_block int;
begin
  -- Get weekday number (0 = Sunday, 1 = Monday, ...)
  select day_number into weekday_number
  from structure_days
  where id = _day_id;

  -- Get block number of the starting period
  select sp.block_number
  into start_block
  from schedule_periods sp
  where sp.id = _period_id;

  -- Get N consecutive period_ids (regardless of day)
  select array_agg(ordered.id order by ordered.block_number)
  into period_ids
  from (
    select sp.id, sp.block_number
    from schedule_periods sp
    where sp.school_id = _school_id
      and sp.block_number >= start_block
    order by sp.block_number
    limit _period_count
  ) as ordered;

  -- Insert schedule
  insert into course_schedules (
    course_id, day_id, start_date, end_date,
    start_time, end_time, teacher_ids, room_id,
    school_id, period_id, period_ids
  )
  values (
    _course_id, _day_id, _start_date, _end_date,
    _start_time, _end_time, _teacher_ids, _room_id,
    _school_id, _period_id, period_ids
  )
  returning id into schedule_id;

  -- Insert lessons on matching weekday
  return query
  insert into course_lessons (
    course_id, schedule_id, start_datetime, end_datetime,
    school_id, teacher_ids, period_id, period_ids
  )
  select
    _course_id,
    schedule_id,
    gs::date + _start_time,
    gs::date + _end_time,
    _school_id,
    _teacher_ids,
    _period_id,
    period_ids
  from generate_series(_start_date, _end_date, interval '1 day') as gs
  where extract(dow from gs) = weekday_number
  returning course_lessons.id as lesson_id,
            course_lessons.start_datetime,
            course_lessons.end_datetime;
end;
$$;


ALTER FUNCTION public.create_schedule_and_generate_lessons(_course_id uuid, _day_id integer, _start_date date, _end_date date, _start_time time without time zone, _end_time time without time zone, _teacher_ids uuid[], _room_id uuid, _school_id uuid, _period_id uuid, _period_count integer) OWNER TO supabase_admin;

--
-- Name: create_school_year_with_semesters_and_log(uuid, text, date, date, jsonb, uuid, text); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.create_school_year_with_semesters_and_log(_school_id uuid, _label text, _start_date date, _end_date date, _semesters jsonb, _user_id uuid, _reason text DEFAULT 'Added school year and semesters'::text) RETURNS uuid
    LANGUAGE plpgsql
    AS $$DECLARE
  new_school_year_id UUID := gen_random_uuid();
  new_semester_id UUID;
  semester_record JSONB;
  change_group_id UUID := gen_random_uuid();
BEGIN
  -- Insert the school year
  INSERT INTO public.structure_school_years (id, school_id, label, start_date, end_date)
  VALUES (new_school_year_id, _school_id, _label, _start_date, _end_date);

  -- Log the school year creation
  INSERT INTO public.change_log (
    change_group_id, user_id, school_id, table_name, record_id,
    action_type, before_data, after_data, reason
  ) VALUES (
    change_group_id, _user_id, _school_id, 'structure_school_years', new_school_year_id,
    'insert', NULL,
    jsonb_build_object(
      'id', new_school_year_id,
      'school_id', _school_id,
      'label', _label,
      'start_date', _start_date,
      'end_date', _end_date
    ),
    _reason
  );

  -- Insert and log each semester
  FOR semester_record IN SELECT * FROM jsonb_array_elements(_semesters)
  LOOP
    new_semester_id := gen_random_uuid();

    INSERT INTO public.structure_school_semesters (
      id, school_id, school_year_id, name, start_date, end_date
    ) VALUES (
      new_semester_id,
      _school_id,
      new_school_year_id,
      semester_record->>'name',
      (semester_record->>'start_date')::date,
      (semester_record->>'end_date')::date
    );

    INSERT INTO public.change_log (
      change_group_id, user_id, school_id, table_name, record_id,
      action_type, before_data, after_data, reason
    ) VALUES (
      change_group_id, _user_id, _school_id, 'structure_school_semesters', new_semester_id,
      'insert', NULL,
      jsonb_build_object(
        'id', new_semester_id,
        'school_id', _school_id,
        'school_year_id', new_school_year_id,
        'name', semester_record->>'name',
        'start_date', semester_record->>'start_date',
        'end_date', semester_record->>'end_date'
      ),
      _reason
    );
  END LOOP;

  RETURN new_school_year_id;
END;$$;


ALTER FUNCTION public.create_school_year_with_semesters_and_log(_school_id uuid, _label text, _start_date date, _end_date date, _semesters jsonb, _user_id uuid, _reason text) OWNER TO supabase_admin;

--
-- Name: create_staff_absence(uuid, date, date, integer, integer, text, text, text, boolean, uuid, uuid, text); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.create_staff_absence(p_staff_id uuid, p_start_date date, p_end_date date DEFAULT NULL::date, p_start_period integer DEFAULT NULL::integer, p_end_period integer DEFAULT NULL::integer, p_reason text DEFAULT NULL::text, p_notes text DEFAULT NULL::text, p_attachment_url text DEFAULT NULL::text, p_is_approved boolean DEFAULT false, p_approved_by uuid DEFAULT NULL::uuid, p_created_by uuid DEFAULT auth.uid(), p_substitution_status text DEFAULT 'pending'::text) RETURNS SETOF uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_school_id  uuid := (
    SELECT school_id
      FROM user_profiles
     WHERE id = p_staff_id
     LIMIT 1
  );
  v_user_id    uuid := p_created_by;     -- for change_log.user_id
  v_absence_id uuid;
  v_date       date;
BEGIN
  IF p_staff_id IS NULL OR p_start_date IS NULL THEN
    RAISE EXCEPTION 'staff_id and start_date are required.';
  END IF;
  IF p_end_date IS NULL THEN
    p_end_date := p_start_date;
  END IF;

  FOR v_date IN
    SELECT generate_series(p_start_date, p_end_date, '1 day'::interval)::date
  LOOP
    IF EXISTS (
      SELECT 1
        FROM public.staff_absences
       WHERE staff_id = p_staff_id
         AND date = v_date
         AND is_approved IS DISTINCT FROM TRUE
    ) THEN
      RAISE EXCEPTION 'Absence already exists on %.', v_date;
    END IF;

    v_absence_id := gen_random_uuid();
    INSERT INTO public.staff_absences (
      id, staff_id, date, start_period, end_period,
      reason, notes, created_at, school_id,
      substitution_status, is_approved, approved_by,
      attachment_url, created_by, end_date
    )
    VALUES (
      v_absence_id, p_staff_id, v_date, p_start_period, p_end_period,
      p_reason, p_notes, now(), v_school_id,
      p_substitution_status, p_is_approved, p_approved_by,
      p_attachment_url, p_created_by, p_end_date
    );
    RETURN NEXT v_absence_id;
  END LOOP;
END;
$$;


ALTER FUNCTION public.create_staff_absence(p_staff_id uuid, p_start_date date, p_end_date date, p_start_period integer, p_end_period integer, p_reason text, p_notes text, p_attachment_url text, p_is_approved boolean, p_approved_by uuid, p_created_by uuid, p_substitution_status text) OWNER TO supabase_admin;

--
-- Name: create_staff_member(uuid, uuid, uuid, jsonb); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.create_staff_member(_school_id uuid, _semester_id uuid, _role_id uuid, _data jsonb, OUT created_user_profile_id uuid, OUT created_staff_profile_id uuid, OUT created_preference_id uuid) RETURNS record
    LANGUAGE plpgsql
    AS $$
DECLARE
  raw_subjects_stud TEXT := _data ->> 'studied subjects';
  raw_subject_wishes TEXT := _data ->> 'subject wishes';
  raw_classes TEXT := _data ->> 'classes';
BEGIN
  -- 1. Create user_profile
  INSERT INTO user_profiles (school_id, first_name, last_name, role_id)
  VALUES (
    _school_id,
    _data ->> 'vorname',
    _data ->> 'Nachname',
    _role_id
  )
  RETURNING id INTO created_user_profile_id;

  -- 1b. Link role in user_roles table
  INSERT INTO user_roles (user_profile_id, role_id)
  VALUES (created_user_profile_id, _role_id);

  -- 2. Create profile_info_staff
  INSERT INTO profile_info_staff (
    profile_id,
    school_id,
    roles,
    kurzung,
    hours_account,
    credit_hours,
    credit_hours_note,
    age_reduction,
    subjects_stud
  ) VALUES (
    created_user_profile_id,
    _school_id,
    ARRAY['teacher'],
    _data ->> 'Init',
    (_data ->> 'Stundenkont.')::INTEGER,
    NULLIF(_data ->> 'Credit_hours', '')::INTEGER,
    NULLIF(_data ->> 'credit hour explanation', ''),
    NULLIF(_data ->> 'age_reduction', '')::INTEGER,
    CASE
      WHEN raw_subjects_stud IS NOT NULL AND LENGTH(TRIM(raw_subjects_stud)) > 0
      THEN string_to_array(
        regexp_replace(
          regexp_replace(raw_subjects_stud, '[\[\]"]', '', 'g'),
          '\s*,\s*', ',', 'g'
        ), ','
      )::UUID[]
      ELSE NULL
    END
  ) RETURNING profile_id INTO created_staff_profile_id;

  -- 3. Optionally create preferences if subject wishes exist
  IF (_data ? 'subject wishes') THEN
    INSERT INTO staff_yearly_preferences (
      staff_profile_id,
      semester_id,
      subject_pref,
      classes,
      clubs,
      team,
      efob_team,
      wishes,
      needs
    ) VALUES (
      created_staff_profile_id,
      _semester_id,
      CASE
        WHEN raw_subject_wishes IS NOT NULL AND LENGTH(TRIM(raw_subject_wishes)) > 0
        THEN string_to_array(
          regexp_replace(
            regexp_replace(raw_subject_wishes, '[\[\]"]', '', 'g'),
            '\s*,\s*', ',', 'g'
          ), ','
        )::UUID[]
        ELSE NULL
      END,
      CASE
        WHEN raw_classes IS NOT NULL AND LENGTH(TRIM(raw_classes)) > 0
        THEN string_to_array(
          regexp_replace(
            regexp_replace(raw_classes, '[\[\]"]', '', 'g'),
            '\s*,\s*', ',', 'g'
          ), ','
        )::UUID[]
        ELSE NULL
      END,
      _data ->> 'input_clubs',
      _data ->> 'Team',
      _data ->> 'eF철B Team',
      _data ->> 'wishes',
      _data ->> 'needs'
    ) RETURNING id INTO created_preference_id;
  ELSE
    created_preference_id := NULL;
  END IF;

END;
$$;


ALTER FUNCTION public.create_staff_member(_school_id uuid, _semester_id uuid, _role_id uuid, _data jsonb, OUT created_user_profile_id uuid, OUT created_staff_profile_id uuid, OUT created_preference_id uuid) OWNER TO supabase_admin;

--
-- Name: create_standard_pickup_rules(uuid, uuid, jsonb, date, uuid, date); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.create_standard_pickup_rules(p_student_id uuid, p_school_id uuid, p_rules jsonb, p_valid_from date, p_created_by uuid, p_valid_until date DEFAULT NULL::date) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    AS $_$
DECLARE
    v_rule jsonb;
    v_weekday integer;
    v_pickup_type text;
    v_notes text;
    v_arrangement_id uuid;
    v_results jsonb := '[]'::jsonb;
    v_result jsonb;
    v_semester_id uuid;
BEGIN
    -- Validate inputs
    IF p_student_id IS NULL OR p_school_id IS NULL OR p_rules IS NULL OR p_valid_from IS NULL OR p_created_by IS NULL THEN
        RAISE EXCEPTION 'Required parameters cannot be null';
    END IF;

    -- If valid_for is provided in the JSON, use it as semester/valid_until reference
    -- Extract semester_id from the first rule if present (only if not empty)
    IF p_rules->0->'valid_for' IS NOT NULL AND 
       p_rules->0->>'valid_for' IS NOT NULL AND 
       p_rules->0->>'valid_for' != '' THEN
        v_semester_id := (p_rules->0->>'valid_for')::uuid;
        -- For now, we'll use the provided valid_until or set it to end of academic year
        IF p_valid_until IS NULL THEN
            p_valid_until := p_valid_from + INTERVAL '1 year';
        END IF;
    END IF;

    -- Process each rule in the JSON array
    FOR v_rule IN SELECT jsonb_array_elements(p_rules)
    LOOP
        -- Extract weekday (key) and rule details
        v_weekday := (SELECT key::integer FROM jsonb_each_text(v_rule) WHERE key ~ '^[0-6]$' LIMIT 1);
        
        -- Skip if no valid weekday found or if pickup_type is empty
        CONTINUE WHEN v_weekday IS NULL;
        
        v_pickup_type := v_rule->>v_weekday::text;
        v_notes := v_rule->>'note';
        
        -- Skip empty pickup types
        CONTINUE WHEN v_pickup_type IS NULL OR v_pickup_type = '';
        
        -- Validate pickup type
        IF v_pickup_type NOT IN ('self_dismissal', 'public_transport', 'school_bus', 'authorized_person') THEN
            RAISE EXCEPTION 'Invalid pickup_type: %. Must be one of: self_dismissal, public_transport, school_bus, authorized_person', v_pickup_type;
        END IF;

        -- Delete existing rule for this student/weekday/period if any
        DELETE FROM student_weekly_pickup_arrangements 
        WHERE student_id = p_student_id 
        AND school_id = p_school_id 
        AND weekday = v_weekday
        AND (valid_until IS NULL OR valid_until >= p_valid_from);

        -- Generate UUID for the new arrangement
        v_arrangement_id := gen_random_uuid();

        -- Insert new arrangement
        INSERT INTO student_weekly_pickup_arrangements (
            id,
            student_id,
            school_id, 
            weekday,
            pickup_type,
            notes,
            valid_from,
            valid_until,
            created_by
        ) VALUES (
            v_arrangement_id,
            p_student_id,
            p_school_id,
            v_weekday,
            v_pickup_type,
            v_notes,
            p_valid_from,
            p_valid_until,
            p_created_by
        );

        -- Add to results
        v_result := jsonb_build_object(
            'id', v_arrangement_id,
            'weekday', v_weekday,
            'pickup_type', v_pickup_type,
            'notes', v_notes,
            'valid_from', p_valid_from,
            'valid_until', p_valid_until
        );
        v_results := v_results || v_result;

        -- Log the change
        INSERT INTO change_log (
            user_id,
            school_id,
            table_name,
            record_id,
            action_type,
            before_data,
            after_data,
            reason
        ) VALUES (
            p_created_by,
            p_school_id,
            'student_weekly_pickup_arrangements',
            v_arrangement_id,
            'insert',
            NULL,
            v_result,
            'Created standard pickup rule'
        );
    END LOOP;

    RETURN jsonb_build_object(
        'success', true,
        'message', 'Standard pickup rules created successfully',
        'arrangements', v_results,
        'student_id', p_student_id,
        'school_id', p_school_id,
        'valid_from', p_valid_from,
        'valid_until', p_valid_until
    );

EXCEPTION WHEN OTHERS THEN
    RAISE EXCEPTION 'Error creating standard pickup rules: %', SQLERRM;
END;
$_$;


ALTER FUNCTION public.create_standard_pickup_rules(p_student_id uuid, p_school_id uuid, p_rules jsonb, p_valid_from date, p_created_by uuid, p_valid_until date) OWNER TO supabase_admin;

--
-- Name: delete_course_by_id(uuid, uuid, uuid); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.delete_course_by_id(p_course_id uuid, p_user_id uuid, p_school_id uuid DEFAULT NULL::uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
begin
  -- Set session variables for logging
  perform set_config('my.user_id', p_user_id::text, true);
  if p_school_id is not null then
    perform set_config('my.school_id', p_school_id::text, true);
  end if;

  -- First delete any linked data (e.g. possible times)
  delete from public.course_possible_times where course_id = p_course_id;

  -- Then delete the course itself
  delete from public.course_list where id = p_course_id;
end;
$$;


ALTER FUNCTION public.delete_course_by_id(p_course_id uuid, p_user_id uuid, p_school_id uuid) OWNER TO supabase_admin;

--
-- Name: delete_my_school_days(); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.delete_my_school_days() RETURNS void
    LANGUAGE sql SECURITY DEFINER
    AS $$
  delete from public.structure_school_days
  where school_id = (
    select school_id
    from public.user_profiles
    where id = auth.uid()
  );
$$;


ALTER FUNCTION public.delete_my_school_days() OWNER TO supabase_admin;

--
-- Name: delete_staff_absence(uuid, uuid); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.delete_staff_absence(p_absence_id uuid, p_user_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_before_data jsonb;
  v_school_id uuid;
BEGIN
  -- Capture the current row for audit log
  SELECT to_jsonb(sa.*), sa.school_id
    INTO v_before_data, v_school_id
    FROM staff_absences sa
   WHERE sa.id = p_absence_id;

  IF v_before_data IS NULL THEN
    RAISE EXCEPTION 'Absence with id % not found', p_absence_id;
  END IF;

  -- Delete the absence
  DELETE FROM staff_absences
   WHERE id = p_absence_id;

  -- Optionally: delete related substitutions
  -- DELETE FROM substitutions WHERE absent_teacher_id = (v_before_data->>'staff_id')::uuid AND original_lesson_id IN (...);

  -- Log the deletion
  INSERT INTO change_log (
    user_id,
    school_id,
    table_name,
    record_id,
    action_type,
    before_data,
    created_at,
    reason
  ) VALUES (
    p_user_id,
    v_school_id,
    'staff_absences',
    p_absence_id,
    'hard_delete',
    v_before_data,
    now(),
    'Absence deleted by function'
  );
END;
$$;


ALTER FUNCTION public.delete_staff_absence(p_absence_id uuid, p_user_id uuid) OWNER TO supabase_admin;

--
-- Name: delete_student_absence_with_cleanup(uuid, uuid, uuid, text); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.delete_student_absence_with_cleanup(p_absence_note_id uuid, p_school_id uuid, p_deleted_by uuid DEFAULT auth.uid(), p_deletion_reason text DEFAULT 'User requested deletion'::text) RETURNS TABLE(success boolean, message text, deleted_records json)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_absence_note RECORD;
  v_recurrence_id uuid;
  v_deleted_daily_logs integer := 0;
  v_reset_daily_logs integer := 0;
  v_deleted_attendance_logs integer := 0;
  v_deleted_recurrence boolean := false;
  v_affected_dates date[];
  v_result json;
  v_original_status text;
BEGIN
  -- Debug logging
  INSERT INTO debug_logs (step, message) VALUES 
    ('delete_student_absence_start', 
     format('Starting trackable deletion of absence note %s for school %s by user %s', 
            p_absence_note_id, p_school_id, p_deleted_by));

  -- Get the absence note details first with validation
  SELECT * INTO v_absence_note
  FROM student_absence_notes 
  WHERE id = p_absence_note_id 
    AND school_id = p_school_id 
    AND deleted_at IS NULL;

  -- Check if absence note exists and belongs to this school
  IF NOT FOUND THEN
    RETURN QUERY SELECT 
      false as success,
      'Absence note not found, already deleted, or does not belong to this school' as message,
      json_build_object(
        'absence_note_id', p_absence_note_id,
        'school_id', p_school_id,
        'error', 'NOT_FOUND'
      ) as deleted_records;
    RETURN;
  END IF;

  v_recurrence_id := v_absence_note.recurrence_id;
  v_original_status := v_absence_note.absence_status;

  -- Debug logging for found absence
  INSERT INTO debug_logs (step, message) VALUES 
    ('absence_note_found', 
     format('Found absence note %s, student: %s, dates: %s to %s, status: %s, recurrence: %s', 
            p_absence_note_id, v_absence_note.student_id, 
            v_absence_note.start_date, v_absence_note.end_date, 
            v_original_status, v_recurrence_id));

  -- Get all affected dates for tracking
  SELECT ARRAY_AGG(date) INTO v_affected_dates
  FROM student_daily_log 
  WHERE absence_note_id = p_absence_note_id;

  -- 1. DELETE STUDENT ATTENDANCE LOGS (lesson-level absences)
  -- Hard delete since these are system-generated records
  DELETE FROM student_attendance_logs 
  WHERE absence_note_id = p_absence_note_id;
  
  GET DIAGNOSTICS v_deleted_attendance_logs = ROW_COUNT;

  INSERT INTO debug_logs (step, message) VALUES 
    ('deleted_attendance_logs', 
     format('Deleted %s attendance log records', v_deleted_attendance_logs));

  -- 2. HANDLE STUDENT DAILY LOGS
  -- For single-day absences: Reset to normal state
  -- For multi-day absences: Some days might be completely removed, others reset
  
  -- Reset daily logs that have other attendance data (don't delete completely)
  UPDATE student_daily_log 
  SET 
    absence_note_id = NULL,
    presence_status = 'present',
    notes = CASE 
      WHEN notes LIKE '%Absent%' THEN 
        format('Previous absence deleted on %s by user %s. Reason: %s', 
               NOW()::date, p_deleted_by, p_deletion_reason)
      ELSE 
        COALESCE(notes, '') || format(' [Absence deleted on %s]', NOW()::date)
    END,
    expected_arrival_time = NULL,
    expected_checkout_time = NULL,
    updated_at = NOW(),
    last_updated_by = p_deleted_by
  WHERE absence_note_id = p_absence_note_id
    -- Only reset if there are other logs for this student on this day
    AND EXISTS (
      SELECT 1 FROM student_attendance_logs sal 
      WHERE sal.student_id = student_daily_log.student_id 
        AND sal.daily_log_id = student_daily_log.id
        AND sal.absence_note_id IS NULL  -- Not related to this absence
    );

  GET DIAGNOSTICS v_reset_daily_logs = ROW_COUNT;

  -- Delete daily logs that were created solely for this absence
  DELETE FROM student_daily_log 
  WHERE absence_note_id = p_absence_note_id
    -- Only delete if no other attendance logs reference this daily log
    AND NOT EXISTS (
      SELECT 1 FROM student_attendance_logs sal 
      WHERE sal.daily_log_id = student_daily_log.id
        AND sal.absence_note_id IS NULL  -- Not related to this absence
    );

  GET DIAGNOSTICS v_deleted_daily_logs = ROW_COUNT;

  INSERT INTO debug_logs (step, message) VALUES 
    ('processed_daily_logs', 
     format('Reset %s daily log records, deleted %s daily log records', 
            v_reset_daily_logs, v_deleted_daily_logs));

  -- 3. HANDLE RECURRENCE PATTERN
  IF v_recurrence_id IS NOT NULL THEN
    -- Check if this recurrence is used by other absence notes
    IF NOT EXISTS (
      SELECT 1 FROM student_absence_notes 
      WHERE recurrence_id = v_recurrence_id 
        AND id != p_absence_note_id 
        AND deleted_at IS NULL
    ) THEN
      -- Safe to soft delete the recurrence pattern
      UPDATE student_absence_recurrences 
      SET 
        deleted_at = NOW(),
        deleted_by = p_deleted_by,
        deletion_reason = p_deletion_reason
      WHERE id = v_recurrence_id;
      
      v_deleted_recurrence := true;

      INSERT INTO debug_logs (step, message) VALUES 
        ('deleted_recurrence', 
         format('Soft deleted recurrence pattern %s', v_recurrence_id));
    ELSE
      INSERT INTO debug_logs (step, message) VALUES 
        ('kept_recurrence', 
         format('Kept recurrence pattern %s (used by other absences)', v_recurrence_id));
    END IF;
  END IF;

  -- 4. SOFT DELETE THE MAIN ABSENCE NOTE WITH TRACKING
  UPDATE student_absence_notes 
  SET 
    deleted_at = NOW(),
    updated_by = p_deleted_by,
    updated_at = NOW(),
    status = 'deleted',
    -- Add deletion tracking to reason field
    reason = COALESCE(reason, '') || format(
      ' [DELETED on %s by %s. Reason: %s. Original status: %s]',
      NOW()::date, p_deleted_by, p_deletion_reason, v_original_status
    )
  WHERE id = p_absence_note_id;

  INSERT INTO debug_logs (step, message) VALUES 
    ('soft_deleted_absence_note', 
     format('Soft deleted absence note %s with tracking info', p_absence_note_id));

  -- 5. CREATE DELETION AUDIT LOG (if you have an audit table)
  -- INSERT INTO absence_deletion_audit (
  --   absence_note_id, deleted_by, deleted_at, deletion_reason, 
  --   original_status, affected_dates, cleanup_summary
  -- ) VALUES (
  --   p_absence_note_id, p_deleted_by, NOW(), p_deletion_reason,
  --   v_original_status, v_affected_dates, 
  --   format('Cleaned up %s attendance logs, %s daily logs', 
  --          v_deleted_attendance_logs, v_deleted_daily_logs + v_reset_daily_logs)
  -- );

  -- Prepare detailed result summary
  v_result := json_build_object(
    'absence_note_id', p_absence_note_id,
    'student_id', v_absence_note.student_id,
    'school_id', p_school_id,
    'original_status', v_original_status,
    'start_date', v_absence_note.start_date,
    'end_date', v_absence_note.end_date,
    'affected_dates', v_affected_dates,
    'cleanup_summary', json_build_object(
      'deleted_attendance_logs', v_deleted_attendance_logs,
      'reset_daily_logs', v_reset_daily_logs,
      'deleted_daily_logs', v_deleted_daily_logs,
      'deleted_recurrence', v_deleted_recurrence,
      'recurrence_id', v_recurrence_id
    ),
    'deletion_info', json_build_object(
      'deleted_at', NOW(),
      'deleted_by', p_deleted_by,
      'deletion_reason', p_deletion_reason
    )
  );

  -- Final debug logging
  INSERT INTO debug_logs (step, message) VALUES 
    ('delete_student_absence_complete', 
     format('Completed trackable deletion of absence %s: %s attendance logs, %s daily logs processed, recurrence deleted: %s', 
            p_absence_note_id, v_deleted_attendance_logs, 
            v_deleted_daily_logs + v_reset_daily_logs, v_deleted_recurrence));

  -- Return success with detailed tracking
  RETURN QUERY SELECT 
    true as success,
    format('Successfully deleted absence and cleaned up %s related records. All changes tracked for audit.', 
           v_deleted_attendance_logs + v_deleted_daily_logs + v_reset_daily_logs) as message,
    v_result as deleted_records;

EXCEPTION
  WHEN OTHERS THEN
    INSERT INTO debug_logs (step, message) VALUES 
      ('delete_student_absence_error', 
       format('Error in trackable deletion of absence %s: %s', p_absence_note_id, SQLERRM));

    RETURN QUERY SELECT 
      false as success,
      format('Failed to delete absence: %s', SQLERRM) as message,
      json_build_object(
        'error', SQLERRM, 
        'absence_note_id', p_absence_note_id,
        'school_id', p_school_id
      ) as deleted_records;
END;
$$;


ALTER FUNCTION public.delete_student_absence_with_cleanup(p_absence_note_id uuid, p_school_id uuid, p_deleted_by uuid, p_deletion_reason text) OWNER TO supabase_admin;

--
-- Name: delete_user_refresh_tokens(text); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.delete_user_refresh_tokens(user_email text) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
    -- Delete refresh tokens for the specified user
    DELETE FROM auth.refresh_tokens 
    USING auth.users
    WHERE 
        auth.refresh_tokens.user_id::UUID = auth.users.id
        AND auth.users.email = user_email;
END;
$$;


ALTER FUNCTION public.delete_user_refresh_tokens(user_email text) OWNER TO supabase_admin;

--
-- Name: demo_simplified_pickup_system(uuid); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.demo_simplified_pickup_system(p_demo_student_id uuid DEFAULT NULL::uuid) RETURNS TABLE(demo_step text, demo_action text, demo_result text)
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_student_id uuid;
    v_weekly_id uuid;
    v_override_id uuid;
    v_arrangement record;
BEGIN
    -- Use provided student or find any student
    IF p_demo_student_id IS NOT NULL THEN
        v_student_id := p_demo_student_id;
    ELSE
        SELECT id INTO v_student_id FROM user_profiles 
        WHERE id IN (SELECT profile_id FROM profile_info_student) 
        LIMIT 1;
    END IF;
    
    IF v_student_id IS NULL THEN
        RETURN QUERY SELECT 'ERROR'::text, 'No student found for demo'::text, 'Please provide a valid student ID'::text;
        RETURN;
    END IF;
    
    -- Demo Step 1: Create weekly default
    RETURN QUERY SELECT 
        'Step 1'::text, 
        'Create weekly default (Monday = bus pickup)'::text,
        'Setting up recurring Monday bus pickup'::text;
    
    BEGIN
        v_weekly_id := create_weekly_pickup_arrangement(
            p_student_id := v_student_id,
            p_weekday := 1,  -- Monday
            p_pickup_type := 'bus',
            p_notes := 'Demo: Regular Monday bus pickup'
        );
        
        RETURN QUERY SELECT 
            'Step 1'::text, 
            'Weekly arrangement created'::text,
            ('ID: ' || v_weekly_id::text)::text;
            
    EXCEPTION
        WHEN OTHERS THEN
            RETURN QUERY SELECT 
                'Step 1'::text, 
                'Error creating weekly arrangement'::text,
                SQLERRM::text;
    END;
    
    -- Demo Step 2: Query for Monday
    RETURN QUERY SELECT 
        'Step 2'::text, 
        'Query pickup for next Monday'::text,
        'Should return weekly default (bus)'::text;
    
    SELECT * INTO v_arrangement 
    FROM get_student_pickup_arrangement_for_date(v_student_id, CURRENT_DATE + (1 - EXTRACT(ISODOW FROM CURRENT_DATE) + 7)::integer);
    
    IF v_arrangement.id IS NOT NULL THEN
        RETURN QUERY SELECT 
            'Step 2'::text, 
            'Query result'::text,
            ('Type: ' || v_arrangement.pickup_type || ', Source: ' || v_arrangement.source_type)::text;
    ELSE
        RETURN QUERY SELECT 
            'Step 2'::text, 
            'Query result'::text,
            'No arrangement found'::text;
    END IF;
    
    -- Demo Step 3: Create override
    RETURN QUERY SELECT 
        'Step 3'::text, 
        'Create override for next Monday'::text,
        'Override with parent pickup instead of bus'::text;
    
    BEGIN
        v_override_id := create_pickup_arrangement_override(
            p_student_id := v_student_id,
            p_pickup_date := CURRENT_DATE + (1 - EXTRACT(ISODOW FROM CURRENT_DATE) + 7)::integer,
            p_pickup_type := 'parent',
            p_notes := 'Demo: Special parent pickup override'
        );
        
        RETURN QUERY SELECT 
            'Step 3'::text, 
            'Override created'::text,
            ('ID: ' || v_override_id::text)::text;
            
    EXCEPTION
        WHEN OTHERS THEN
            RETURN QUERY SELECT 
                'Step 3'::text, 
                'Error creating override'::text,
                SQLERRM::text;
    END;
    
    -- Demo Step 4: Query again
    SELECT * INTO v_arrangement 
    FROM get_student_pickup_arrangement_for_date(v_student_id, CURRENT_DATE + (1 - EXTRACT(ISODOW FROM CURRENT_DATE) + 7)::integer);
    
    RETURN QUERY SELECT 
        'Step 4'::text, 
        'Query same Monday again'::text,
        ('Now returns: ' || v_arrangement.pickup_type || ' (' || v_arrangement.source_type || ')')::text;
    
    -- Cleanup demo data
    DELETE FROM student_pickup_arrangement_overrides WHERE id = v_override_id;
    DELETE FROM student_weekly_pickup_arrangements WHERE id = v_weekly_id;
    
    RETURN QUERY SELECT 
        'Cleanup'::text, 
        'Demo data removed'::text,
        'Demo completed successfully'::text;
END;
$$;


ALTER FUNCTION public.demo_simplified_pickup_system(p_demo_student_id uuid) OWNER TO supabase_admin;

--
-- Name: edit_bulletin_post_instance(uuid, text, text, timestamp without time zone, uuid, text[], boolean, boolean, boolean, uuid[], uuid[]); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.edit_bulletin_post_instance(_post_id uuid, _title text, _body text, _display_from timestamp without time zone, _edited_by uuid, _attachments text[] DEFAULT '{}'::text[], _is_important boolean DEFAULT false, _notify_on_post boolean DEFAULT false, _read_required boolean DEFAULT false, _visible_users uuid[] DEFAULT '{}'::uuid[], _visible_groups uuid[] DEFAULT '{}'::uuid[]) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
  old_post bulletin_posts%ROWTYPE;
BEGIN
  -- Load existing post for logging and attachment diff
  SELECT * INTO old_post FROM bulletin_posts WHERE id = _post_id;

  IF old_post IS NULL THEN
    RAISE EXCEPTION 'Post % not found', _post_id;
  END IF;

  -- Update the bulletin post (no updated_at column)
  UPDATE bulletin_posts SET
    title = _title,
    body = _body,
    display_from = _display_from,
    attachments = _attachments,
    is_important = _is_important,
    notify_on_post = _notify_on_post,
    read_required = _read_required,
    visible_groups = _visible_groups
  WHERE id = _post_id;

  -- Replace visible users
  DELETE FROM bulletin_post_users WHERE post_id = _post_id;
  IF array_length(_visible_users, 1) IS NOT NULL THEN
    INSERT INTO bulletin_post_users (post_id, user_id)
    SELECT _post_id, unnest(_visible_users);
  END IF;

  -- Handle attachment deletion if attachments changed
  IF old_post.attachments IS DISTINCT FROM _attachments THEN
    -- TODO: Replace with your actual bucket cleanup logic
    PERFORM public.delete_attachments(old_post.attachments);
  END IF;

  -- Log the change in the change_log table
  INSERT INTO public.change_log (
    user_id,
    school_id,
    table_name,
    record_id,
    action_type,
    before_data,
    after_data,
    created_at,
    source
  ) VALUES (
    _edited_by,
    old_post.school_id,
    'bulletin_posts',
    _post_id,
    'update',
    to_jsonb(old_post),
    to_jsonb((SELECT bulletin_posts FROM bulletin_posts WHERE id = _post_id)),
    now(),
    'manual'
  );
END;
$$;


ALTER FUNCTION public.edit_bulletin_post_instance(_post_id uuid, _title text, _body text, _display_from timestamp without time zone, _edited_by uuid, _attachments text[], _is_important boolean, _notify_on_post boolean, _read_required boolean, _visible_users uuid[], _visible_groups uuid[]) OWNER TO supabase_admin;

--
-- Name: edit_student_absence(uuid, uuid, date, date, text, text, text, text, text); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.edit_student_absence(p_absence_id uuid, p_school_id uuid, p_start_date date DEFAULT NULL::date, p_end_date date DEFAULT NULL::date, p_absence_type text DEFAULT NULL::text, p_reason text DEFAULT NULL::text, p_attachment_url text DEFAULT NULL::text, p_time_range text DEFAULT NULL::text, p_duration text DEFAULT NULL::text) RETURNS json
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    current_absence record;
    result json;
BEGIN
    -- Get current absence record
    SELECT * INTO current_absence 
    FROM student_absence_notes 
    WHERE id = p_absence_id 
    AND school_id = p_school_id 
    AND deleted_at IS NULL;
    
    -- Check if absence exists
    IF NOT FOUND THEN
        RETURN json_build_object(
            'success', false,
            'error', 'Absence not found or access denied',
            'message', 'Could not find absence with given ID'
        );
    END IF;
    
    -- Validate absence_type if provided
    IF p_absence_type IS NOT NULL AND p_absence_type NOT IN ('krankgemeldet', 'unentschuldigt', 'beurlaubt', 'ungekl채rt', 'versp채tet') THEN
        RAISE EXCEPTION 'Invalid absence_type. Must be one of: krankgemeldet, unentschuldigt, beurlaubt, ungekl채rt, versp채tet';
    END IF;
    
    -- Update absence record
    UPDATE student_absence_notes SET
        start_date = COALESCE(p_start_date, start_date),
        end_date = COALESCE(p_end_date, end_date),
        absence_type = COALESCE(p_absence_type, absence_type),
        reason = COALESCE(p_reason, reason),
        attachment_url = CASE 
            WHEN p_attachment_url = '' THEN NULL 
            ELSE COALESCE(p_attachment_url, attachment_url) 
        END,
        updated_by = auth.uid(),
        updated_at = NOW(),
        is_excused = CASE 
            WHEN p_absence_type IS NOT NULL THEN 
                CASE WHEN p_absence_type IN ('krankgemeldet', 'beurlaubt') THEN true ELSE false END
            ELSE is_excused
        END
    WHERE id = p_absence_id 
    AND school_id = p_school_id 
    AND deleted_at IS NULL;
    
    -- Return success with updated data
    SELECT json_build_object(
        'success', true,
        'message', 'Absence updated successfully',
        'data', json_build_object(
            'id', p_absence_id,
            'start_date', COALESCE(p_start_date, current_absence.start_date),
            'end_date', COALESCE(p_end_date, current_absence.end_date),
            'absence_type', COALESCE(p_absence_type, current_absence.absence_type),
            'reason', COALESCE(p_reason, current_absence.reason),
            'duration', p_duration,
            'time_range', p_time_range,
            'updated_at', NOW()
        )
    ) INTO result;
    
    RETURN result;
    
EXCEPTION
    WHEN OTHERS THEN
        RETURN json_build_object(
            'success', false,
            'error', SQLERRM,
            'message', 'Failed to update absence'
        );
END;
$$;


ALTER FUNCTION public.edit_student_absence(p_absence_id uuid, p_school_id uuid, p_start_date date, p_end_date date, p_absence_type text, p_reason text, p_attachment_url text, p_time_range text, p_duration text) OWNER TO supabase_admin;

--
-- Name: finalize_lesson_substitutions(uuid, uuid, text); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.finalize_lesson_substitutions(p_lesson_id uuid, p_user_id uuid DEFAULT NULL::uuid, p_notes text DEFAULT NULL::text) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_sub RECORD;
  v_lesson RECORD;
  v_conflict_lesson_id uuid;
  v_absent_teacher_id uuid;
  v_substitute_staff_id uuid;
  v_now timestamp := now();
BEGIN
  -- 1. Load the lesson
  SELECT * INTO v_lesson FROM course_lessons WHERE id = p_lesson_id;
  IF NOT FOUND THEN
    RAISE EXCEPTION 'Lesson with id % not found', p_lesson_id::text;
  END IF;

  -- 2. Loop through all non-confirmed substitutions for this lesson
  FOR v_sub IN
    SELECT * FROM substitutions WHERE original_lesson_id = p_lesson_id AND status <> 'confirmed'
  LOOP
    -- 3. Validate no conflicting lesson/substitution for each absent teacher (on another lesson at same time)
    IF v_sub.absent_teacher_ids IS NOT NULL THEN
      FOREACH v_absent_teacher_id IN ARRAY v_sub.absent_teacher_ids LOOP
        SELECT cl.id INTO v_conflict_lesson_id
        FROM course_lessons cl
        LEFT JOIN substitutions s ON s.original_lesson_id = cl.id AND s.status = 'confirmed'
        WHERE cl.id <> v_lesson.id
          AND cl.start_datetime = v_lesson.start_datetime
          AND cl.period_id = v_lesson.period_id
          AND (v_absent_teacher_id = ANY(cl.teacher_ids))
          AND cl.is_cancelled = false
          AND (
            (s.id IS NULL) OR (s.absent_teacher_ids IS NULL) OR NOT (v_absent_teacher_id = ANY(s.absent_teacher_ids))
          )
        LIMIT 1;
        IF v_conflict_lesson_id IS NOT NULL THEN
          RAISE EXCEPTION 'Absent teacher % already has a lesson or substitution at this time (this lesson_id: %, teacher_id: %)', v_absent_teacher_id::text, v_lesson.id::text, v_absent_teacher_id::text;
        END IF;
      END LOOP;
    END IF;

    -- 4. Validate no conflicting lesson/substitution for the substitute (on another lesson at same time)
    v_substitute_staff_id := v_sub.substitute_staff_id;
    IF v_substitute_staff_id IS NOT NULL THEN
      SELECT cl.id INTO v_conflict_lesson_id
      FROM course_lessons cl
      LEFT JOIN substitutions s ON s.original_lesson_id = cl.id AND s.status = 'confirmed'
      WHERE cl.id <> v_lesson.id
        AND cl.start_datetime = v_lesson.start_datetime
        AND cl.period_id = v_lesson.period_id
        AND (v_substitute_staff_id = ANY(cl.teacher_ids)
          OR (s.substitute_staff_id = v_substitute_staff_id AND s.status = 'confirmed'))
        AND cl.is_cancelled = false
      LIMIT 1;
      IF v_conflict_lesson_id IS NOT NULL THEN
        RAISE EXCEPTION 'Substitute staff member % already has a lesson or substitution at this time (this lesson_id: %, staff_id: %)', v_substitute_staff_id::text, v_lesson.id::text, v_substitute_staff_id::text;
      END IF;
    END IF;

    -- 5. Update status to 'confirmed' and notes if provided
    UPDATE substitutions
    SET
      status = 'confirmed',
      created_at = v_now,
      notes = COALESCE(p_notes, notes)
    WHERE id = v_sub.id;

    -- 6. Log to change_log
    INSERT INTO change_log (
      user_id,
      table_name,
      record_id,
      action_type,
      before_data,
      after_data,
      created_at
    ) VALUES (
      COALESCE(p_user_id, v_sub.created_by),
      'substitutions',
      v_sub.id,
      'update',
      to_jsonb(v_sub),
      to_jsonb((SELECT row_to_json(t) FROM substitutions t WHERE t.id = v_sub.id)),
      v_now
    );
  END LOOP;
END;
$$;


ALTER FUNCTION public.finalize_lesson_substitutions(p_lesson_id uuid, p_user_id uuid, p_notes text) OWNER TO supabase_admin;

--
-- Name: generate_random_code(); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.generate_random_code() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
    chars TEXT := 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
    result VARCHAR(6) := '';
    i INTEGER;
BEGIN
    FOR i IN 1..6 LOOP
        result := result || substr(chars, floor(random() * length(chars) + 1)::int, 1);
    END LOOP;
    RETURN result;
END;
$$;


ALTER FUNCTION public.generate_random_code() OWNER TO supabase_admin;

--
-- Name: generate_user_code(uuid, integer, uuid, text); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.generate_user_code(p_profile_id uuid, p_code_instance integer DEFAULT 1, p_created_by uuid DEFAULT NULL::uuid, p_notes text DEFAULT NULL::text) RETURNS json
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    new_code VARCHAR(6);
    code_exists BOOLEAN;
    attempt_count INTEGER := 0;
    max_attempts INTEGER := 100;
    existing_code_id UUID;
    result JSON;
BEGIN
    -- Check if user profile exists
    IF NOT EXISTS(SELECT 1 FROM public.user_profiles WHERE id = p_profile_id) THEN
        RETURN json_build_object(
            'success', false,
            'error', 'User profile not found',
            'code', null
        );
    END IF;

    -- Check if a code already exists for this profile and instance (not expired)
    SELECT id INTO existing_code_id
    FROM user_codes
    WHERE user_codes.profile_id = p_profile_id
    AND user_codes.code_instance = p_code_instance
    AND used_at IS NULL
    AND revoked_at IS NULL
    AND expires_at > NOW();

    IF existing_code_id IS NOT NULL THEN
        -- Return existing code
        SELECT code INTO new_code
        FROM user_codes
        WHERE id = existing_code_id;

        RETURN json_build_object(
            'success', true,
            'error', null,
            'code', new_code,
            'is_new', false,
            'user_code_id', existing_code_id
        );
    END IF;

    -- Generate unique code (retry if collision occurs)
    LOOP
        new_code := generate_random_code();
        attempt_count := attempt_count + 1;

        -- Check if code already exists (not expired)
        SELECT EXISTS(
            SELECT 1 FROM user_codes
            WHERE code = new_code
            AND used_at IS NULL
            AND revoked_at IS NULL
            AND expires_at > NOW()
        ) INTO code_exists;

        -- Exit loop if code is unique or max attempts reached
        IF NOT code_exists OR attempt_count >= max_attempts THEN
            EXIT;
        END IF;
    END LOOP;

    -- If we couldn't generate a unique code after max attempts
    IF code_exists AND attempt_count >= max_attempts THEN
        RETURN json_build_object(
            'success', false,
            'error', 'Unable to generate unique code',
            'code', null
        );
    END IF;

    -- Insert the new code
    INSERT INTO user_codes (profile_id, code, code_instance, created_by, notes)
    VALUES (p_profile_id, new_code, p_code_instance, p_created_by, p_notes)
    RETURNING id INTO existing_code_id;

    -- Return success response
    RETURN json_build_object(
        'success', true,
        'error', null,
        'code', new_code,
        'is_new', true,
        'user_code_id', existing_code_id
    );

EXCEPTION
    WHEN OTHERS THEN
        RETURN json_build_object(
            'success', false,
            'error', SQLERRM,
            'code', null
        );
END;
$$;


ALTER FUNCTION public.generate_user_code(p_profile_id uuid, p_code_instance integer, p_created_by uuid, p_notes text) OWNER TO supabase_admin;

--
-- Name: get_all_policies(); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.get_all_policies() RETURNS TABLE(schemaname text, tablename text, policyname text, permissive text, roles text[], cmd text, qual text, with_check text)
    LANGUAGE sql STABLE SECURITY DEFINER
    AS $$
  SELECT 
    p.schemaname::text,
    p.tablename::text,
    p.policyname::text,
    p.permissive::text,
    p.roles,
    p.cmd::text,
    p.qual::text,
    p.with_check::text
  FROM pg_policies p
  WHERE p.schemaname = 'public'
  ORDER BY p.tablename::text, p.policyname::text;
$$;


ALTER FUNCTION public.get_all_policies() OWNER TO supabase_admin;

--
-- Name: get_bucket_privacy_summary(); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.get_bucket_privacy_summary() RETURNS json
    LANGUAGE sql STABLE SECURITY DEFINER
    AS $$
    SELECT json_build_object(
        'total_buckets', COUNT(*),
        'correct_buckets', COUNT(*) FILTER (WHERE matches = TRUE),
        'incorrect_buckets', COUNT(*) FILTER (WHERE matches = FALSE),
        'configuration_score', ROUND(
            (COUNT(*) FILTER (WHERE matches = TRUE)::DECIMAL / COUNT(*)) * 100, 0
        ),
        'needs_attention', COUNT(*) FILTER (WHERE matches = FALSE) > 0,
        'summary', CASE 
            WHEN COUNT(*) FILTER (WHERE matches = FALSE) = 0 THEN 'All bucket privacy settings are correct'
            ELSE COUNT(*) FILTER (WHERE matches = FALSE)::TEXT || ' buckets have incorrect privacy settings'
        END
    )
    FROM public.check_bucket_privacy_settings();
$$;


ALTER FUNCTION public.get_bucket_privacy_summary() OWNER TO supabase_admin;

--
-- Name: FUNCTION get_bucket_privacy_summary(); Type: COMMENT; Schema: public; Owner: supabase_admin
--

COMMENT ON FUNCTION public.get_bucket_privacy_summary() IS 'Returns summary statistics about bucket privacy configuration compliance';


--
-- Name: get_current_user_children(); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.get_current_user_children() RETURNS TABLE(child_id uuid)
    LANGUAGE sql STABLE SECURITY DEFINER
    AS $$
  SELECT CASE 
    WHEN auth.uid() IS NULL THEN NULL::uuid
    ELSE fmcl.child_profile_id
  END
  FROM family_member_child_links fmcl
  WHERE auth.uid() IS NOT NULL 
  AND fmcl.adult_profile_id = auth.uid()
  AND fmcl.access_restricted = false;
$$;


ALTER FUNCTION public.get_current_user_children() OWNER TO supabase_admin;

--
-- Name: get_current_user_family_ids(); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.get_current_user_family_ids() RETURNS TABLE(family_id uuid)
    LANGUAGE sql STABLE SECURITY DEFINER
    AS $$
  SELECT DISTINCT fmcl.family_id
  FROM family_member_child_links fmcl
  WHERE auth.uid() IS NOT NULL 
  AND fmcl.adult_profile_id = auth.uid()
  AND fmcl.access_restricted = false;
$$;


ALTER FUNCTION public.get_current_user_family_ids() OWNER TO supabase_admin;

--
-- Name: get_or_create_family(uuid, uuid, uuid, text); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.get_or_create_family(p_parent_profile_id uuid, p_student_profile_id uuid, p_school_id uuid, p_family_name text) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_family_id UUID;
  v_family_code TEXT;
  v_code_exists BOOLEAN;
  v_attempt_count INTEGER := 0;
  v_max_attempts INTEGER := 100;
  v_result JSONB;
BEGIN
  -- Start transaction
  BEGIN
    -- First, try to get existing family_id from family_members
    SELECT family_id INTO v_family_id
    FROM family_members
    WHERE profile_id = p_student_profile_id
    AND role = 'student'
    LIMIT 1;

    -- If family_id found, return it
    IF v_family_id IS NOT NULL THEN
      RETURN jsonb_build_object(
        'success', TRUE,
        'family_id', v_family_id,
        'is_new', FALSE,
        'from', 'student',
        'message', 'Existing family found'
      );
    END IF;

    -- First, try to get existing family_id from family_members
    IF p_parent_profile_id IS NOT NULL THEN
      SELECT family_id INTO v_family_id
      FROM family_members
      WHERE profile_id = p_parent_profile_id
      AND role = 'parent'
      LIMIT 1;

      -- If family_id found, return it
      IF v_family_id IS NOT NULL THEN
        RETURN jsonb_build_object(
          'success', TRUE,
          'family_id', v_family_id,
          'is_new', FALSE,
          'from', 'parent',
          'message', 'Existing family found'
        );
      END IF;
    END IF;

    -- No existing family found, create new family
    -- Generate unique family code in format "DE" + 6 random digits
    LOOP
      v_family_code := 'DE' || lpad(floor(random() * 1000000)::text, 6, '0');
      v_attempt_count := v_attempt_count + 1;

      -- Check if family code already exists
      SELECT EXISTS(
        SELECT 1 FROM families
        WHERE family_code = v_family_code
      ) INTO v_code_exists;

      -- Exit loop if code is unique or max attempts reached
      IF NOT v_code_exists OR v_attempt_count >= v_max_attempts THEN
        EXIT;
      END IF;
    END LOOP;

    -- If we couldn't generate a unique code after max attempts
    IF v_code_exists AND v_attempt_count >= v_max_attempts THEN
      RAISE EXCEPTION 'Unable to generate unique family code';
    END IF;

    -- Create new family
    INSERT INTO families (school_id, family_code, family_name)
    VALUES (p_school_id, v_family_code, p_family_name)
    RETURNING id INTO v_family_id;

    -- Create family_members record for student
    INSERT INTO family_members (
      family_id,
      profile_id,
      role,
      is_primary_guardian,
      is_primary_contact,
      notes
    )
    VALUES (
      v_family_id,
      p_student_profile_id,
      'student',
      FALSE,
      FALSE,
      'Added on parent first login'
    );

    -- Create profile_info_family_member record for student
    INSERT INTO profile_info_family_member (
      profile_id,
      school_id,
      can_log_in,
      is_primary_guardian
    )
    VALUES (
      p_student_profile_id,
      p_school_id,
      FALSE,
      FALSE
    )
    ON CONFLICT (profile_id) DO NOTHING;

    IF p_parent_profile_id IS NOT NULL THEN
      -- Create family_members record for parent
      INSERT INTO family_members (
        family_id,
        profile_id,
        role,
        is_primary_guardian,
        is_primary_contact,
        notes
      )
      VALUES (
        v_family_id,
        p_parent_profile_id,
        'parent',
        TRUE,
        TRUE,
        'Added on parent first login'
      );

      -- Create profile_info_family_member record for parent
      INSERT INTO profile_info_family_member (
        profile_id,
        school_id,
        can_log_in,
        is_primary_guardian
      )
      VALUES (
        p_parent_profile_id,
        p_school_id,
        TRUE,
        TRUE
      )
      ON CONFLICT (profile_id) DO NOTHING;
    END IF;

    -- Prepare result
    v_result := jsonb_build_object(
      'success', TRUE,
      'family_id', v_family_id,
      'family_code', v_family_code,
      'is_new', TRUE,
      'message', 'New family created successfully'
    );

    -- Commit transaction
    RETURN v_result;

  EXCEPTION
    WHEN OTHERS THEN
      -- Rollback transaction on any error
      RAISE EXCEPTION 'Transaction failed: %', SQLERRM;
  END;
END;
$$;


ALTER FUNCTION public.get_or_create_family(p_parent_profile_id uuid, p_student_profile_id uuid, p_school_id uuid, p_family_name text) OWNER TO supabase_admin;

--
-- Name: get_or_generate_user_code(uuid, integer); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.get_or_generate_user_code(profile_id uuid, code_instance integer DEFAULT 1) RETURNS json
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    existing_code VARCHAR(6);
    new_code VARCHAR(6);
    code_exists BOOLEAN;
    attempt_count INTEGER := 0;
    max_attempts INTEGER := 100;
    result JSON;
BEGIN
    -- Check if user profile exists
    IF NOT EXISTS(SELECT 1 FROM public.user_profiles WHERE id = profile_id) THEN
        RETURN json_build_object(
            'success', false,
            'error', 'User profile not found',
            'code', null
        );
    END IF;

    -- Check if there's an existing unused code for this profile and instance (not expired)
    SELECT code INTO existing_code
    FROM user_codes
    WHERE user_codes.profile_id = get_or_generate_user_code.profile_id
    AND user_codes.code_instance = get_or_generate_user_code.code_instance
    AND used_at IS NULL
    AND revoked_at IS NULL
    AND expires_at > NOW()
    ORDER BY created_at DESC
    LIMIT 1;

    -- If existing code found, return it
    IF existing_code IS NOT NULL THEN
        RETURN json_build_object(
            'success', true,
            'error', null,
            'code', existing_code
        );
    END IF;

    -- Generate unique code (retry if collision occurs)
    LOOP
        new_code := generate_random_code();
        attempt_count := attempt_count + 1;

        -- Check if code already exists (not expired)
        SELECT EXISTS(
            SELECT 1 FROM user_codes
            WHERE code = new_code
            AND used_at IS NULL
            AND revoked_at IS NULL
            AND expires_at > NOW()
        ) INTO code_exists;

        -- Exit loop if code is unique or max attempts reached
        IF NOT code_exists OR attempt_count >= max_attempts THEN
            EXIT;
        END IF;
    END LOOP;

    -- If we couldn't generate a unique code after max attempts
    IF code_exists AND attempt_count >= max_attempts THEN
        RETURN json_build_object(
            'success', false,
            'error', 'Unable to generate unique code',
            'code', null
        );
    END IF;

    -- Insert the new code
    INSERT INTO user_codes (profile_id, code, code_instance)
    VALUES (profile_id, new_code, code_instance);

    -- Return success response
    RETURN json_build_object(
        'success', true,
        'error', null,
        'code', new_code
    );

EXCEPTION
    WHEN OTHERS THEN
        RETURN json_build_object(
            'success', false,
            'error', SQLERRM,
            'code', null
        );
END;
$$;


ALTER FUNCTION public.get_or_generate_user_code(profile_id uuid, code_instance integer) OWNER TO supabase_admin;

--
-- Name: get_random_class_color(); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.get_random_class_color() RETURNS text
    LANGUAGE sql
    AS $$
  SELECT color FROM unnest(ARRAY[
    '#e6194b', '#3cb44b', '#ffe119', '#4363d8', '#f58231',
    '#911eb4', '#46f0f0', '#f032e6', '#bcf60c', '#fabebe',
    '#008080', '#e6beff', '#9a6324', '#fffac8', '#800000',
    '#aaffc3', '#808000', '#ffd8b1', '#000075', '#a9a9ff',
    '#ffb3ba', '#bae1ff', '#baffc9', '#ffdfba', '#cbaacb',
    '#ff9cee', '#ffffb5', '#c2f0c2', '#d9b3ff', '#f4cccc',
    '#ff6961', '#77dd77', '#fdfd96', '#84b6f4', '#fdcae1',
    '#40e0d0', '#ffb347', '#d2691e', '#dda0dd', '#00ced1',
    '#f0e68c', '#98fb98', '#ffa07a', '#afeeee', '#ffdab9',
    '#ff7f50', '#da70d6', '#ff69b4', '#cd5c5c', '#ffd700'
  ]) AS color
  OFFSET floor(random() * 50);
$$;


ALTER FUNCTION public.get_random_class_color() OWNER TO supabase_admin;

--
-- Name: get_role_protection_summary(); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.get_role_protection_summary() RETURNS TABLE(role_id uuid, role_name text, is_subrole boolean, protection_level text, protection_reason text, usage_count integer, can_delete boolean, last_used timestamp with time zone)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
    RETURN QUERY
    SELECT 
        r.id,
        r.name,
        r.is_subrole,
        COALESCE(pr.protection_level, 'NONE') as protection_level,
        pr.protection_reason,
        COALESCE(usage.total_usage, 0) as usage_count,
        CASE 
            WHEN pr.protection_level = 'CRITICAL' THEN false
            WHEN COALESCE(usage.total_usage, 0) > 0 THEN false
            WHEN pr.protection_level = 'IMPORTANT' THEN 
                EXISTS (
                    SELECT 1 FROM user_profiles up
                    JOIN roles admin_r ON up.role_id = admin_r.id
                    WHERE up.id = auth.uid()::uuid
                    AND admin_r.name = 'Admin'
                )
            ELSE true
        END as can_delete,
        (
            SELECT MAX(GREATEST(up.created_at, ur.created_at))
            FROM user_profiles up
            LEFT JOIN user_roles ur ON ur.user_profile_id = up.id
            WHERE up.role_id = r.id OR ur.role_id = r.id
        ) as last_used
    FROM roles r
    LEFT JOIN protected_roles pr ON r.id = pr.role_id
    LEFT JOIN LATERAL get_role_usage_count(r.id) usage ON true
    ORDER BY 
        CASE 
            WHEN pr.protection_level = 'CRITICAL' THEN 1
            WHEN pr.protection_level = 'IMPORTANT' THEN 2
            ELSE 3
        END,
        r.is_subrole,
        r.name;
END;
$$;


ALTER FUNCTION public.get_role_protection_summary() OWNER TO supabase_admin;

--
-- Name: get_role_usage_count(uuid); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.get_role_usage_count(p_role_id uuid) RETURNS TABLE(user_profiles_count integer, user_roles_count integer, total_usage integer, is_in_use boolean)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
    RETURN QUERY
    SELECT 
        (SELECT COUNT(*)::integer FROM user_profiles WHERE role_id = p_role_id) as user_profiles_count,
        (SELECT COUNT(*)::integer FROM user_roles WHERE role_id = p_role_id) as user_roles_count,
        (
            (SELECT COUNT(*)::integer FROM user_profiles WHERE role_id = p_role_id) +
            (SELECT COUNT(*)::integer FROM user_roles WHERE role_id = p_role_id)
        ) as total_usage,
        (
            (SELECT COUNT(*) FROM user_profiles WHERE role_id = p_role_id) +
            (SELECT COUNT(*) FROM user_roles WHERE role_id = p_role_id)
        ) > 0 as is_in_use;
END;
$$;


ALTER FUNCTION public.get_role_usage_count(p_role_id uuid) OWNER TO supabase_admin;

--
-- Name: get_storage_rls_policies(); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.get_storage_rls_policies() RETURNS TABLE(schema_name text, table_name text, policy_name text, policy_command text, policy_roles text[], policy_using text, policy_with_check text, is_permissive boolean)
    LANGUAGE sql STABLE SECURITY DEFINER
    AS $$
    SELECT 
        schemaname::TEXT,
        tablename::TEXT,
        policyname::TEXT,
        cmd::TEXT,
        roles::TEXT[],
        qual::TEXT,
        with_check::TEXT,
        permissive::BOOLEAN
    FROM pg_policies 
    WHERE schemaname = 'storage'
    ORDER BY tablename, policyname;
$$;


ALTER FUNCTION public.get_storage_rls_policies() OWNER TO supabase_admin;

--
-- Name: FUNCTION get_storage_rls_policies(); Type: COMMENT; Schema: public; Owner: supabase_admin
--

COMMENT ON FUNCTION public.get_storage_rls_policies() IS 'Returns all RLS policies applied to storage schema tables';


--
-- Name: get_student_interview_submission(uuid, uuid); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.get_student_interview_submission(p_student_id uuid, p_registration_period_id uuid) RETURNS jsonb
    LANGUAGE sql STABLE
    AS $$
  SELECT COALESCE(
           interview_raw,                       -- preferred
           payload->'interview',                -- fallback if older rows
           payload->'ui',                       -- older schema we used before
           payload                              -- absolute fallback
         )
  FROM public.student_course_wish_submissions
  WHERE student_id = p_student_id
    AND registration_period_id = p_registration_period_id
  LIMIT 1;
$$;


ALTER FUNCTION public.get_student_interview_submission(p_student_id uuid, p_registration_period_id uuid) OWNER TO supabase_admin;

--
-- Name: get_table_policies(text); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.get_table_policies(table_name text) RETURNS TABLE(schemaname text, tablename text, policyname text, permissive text, roles text[], cmd text, qual text, with_check text)
    LANGUAGE sql STABLE SECURITY DEFINER
    AS $$
  SELECT 
    p.schemaname::text,
    p.tablename::text,
    p.policyname::text,
    p.permissive::text,
    p.roles,
    p.cmd::text,
    p.qual::text,
    p.with_check::text
  FROM pg_policies p
  WHERE p.schemaname = 'public' 
    AND p.tablename = table_name
  ORDER BY p.policyname::text;
$$;


ALTER FUNCTION public.get_table_policies(table_name text) OWNER TO supabase_admin;

--
-- Name: get_tables_with_policies(); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.get_tables_with_policies() RETURNS TABLE(tablename text)
    LANGUAGE sql STABLE SECURITY DEFINER
    AS $$
  SELECT DISTINCT p.tablename::text
  FROM pg_policies p
  WHERE p.schemaname = 'public'
  ORDER BY p.tablename::text;
$$;


ALTER FUNCTION public.get_tables_with_policies() OWNER TO supabase_admin;

--
-- Name: get_unresolved_problems(text, text, text, integer); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.get_unresolved_problems(p_school_id text, p_registration_period_id text, p_semester_id text, p_day_of_week integer) RETURNS TABLE(note_id uuid, course_id text, course_name text, text text, author text, created_at timestamp with time zone)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    cn.id as note_id,
    cn.course_id,
    COALESCE(c.name, 'Unknown Course') as course_name,
    cn.text,
    cn.author,
    cn.created_at
  FROM course_notes cn
  LEFT JOIN w_registration_period_courses_by_day c ON cn.course_id = c.id
  WHERE cn.school_id = p_school_id
    AND cn.registration_period_id = p_registration_period_id
    AND cn.semester_id = p_semester_id
    AND cn.day_of_week = p_day_of_week
    AND cn.is_problem = true
    AND cn.is_resolved = false
  ORDER BY cn.created_at DESC;
END;
$$;


ALTER FUNCTION public.get_unresolved_problems(p_school_id text, p_registration_period_id text, p_semester_id text, p_day_of_week integer) OWNER TO supabase_admin;

--
-- Name: get_user_children_optimized(uuid); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.get_user_children_optimized(user_id uuid DEFAULT auth.uid()) RETURNS uuid[]
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    AS $$
BEGIN
  -- Early return if no user
  IF user_id IS NULL THEN
    RETURN ARRAY[]::uuid[];
  END IF;
  
  -- Return array of child IDs directly
  RETURN ARRAY(
    SELECT fmcl.child_profile_id
    FROM family_member_child_links fmcl
    WHERE fmcl.adult_profile_id = user_id
    AND fmcl.access_restricted = false
  );
END;
$$;


ALTER FUNCTION public.get_user_children_optimized(user_id uuid) OWNER TO supabase_admin;

--
-- Name: get_user_family_ids(); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.get_user_family_ids() RETURNS uuid[]
    LANGUAGE sql STABLE SECURITY DEFINER
    AS $$
    SELECT auth.get_user_family_ids();
$$;


ALTER FUNCTION public.get_user_family_ids() OWNER TO supabase_admin;

--
-- Name: get_user_family_ids_optimized(uuid); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.get_user_family_ids_optimized(user_id uuid DEFAULT auth.uid()) RETURNS uuid[]
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    AS $$
BEGIN
  IF user_id IS NULL THEN
    RETURN ARRAY[]::uuid[];
  END IF;
  
  RETURN ARRAY(
    SELECT DISTINCT fmcl.family_id
    FROM family_member_child_links fmcl
    WHERE fmcl.adult_profile_id = user_id
    AND fmcl.access_restricted = false
  );
END;
$$;


ALTER FUNCTION public.get_user_family_ids_optimized(user_id uuid) OWNER TO supabase_admin;

--
-- Name: get_user_profile_by_code(character varying); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.get_user_profile_by_code(input_code character varying) RETURNS json
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    profile_id UUID;
    code_created_at TIMESTAMP WITH TIME ZONE;
    code_used_at TIMESTAMP WITH TIME ZONE;
    code_instance INTEGER;
    code_attempts INTEGER;
    first_name TEXT;
    last_name TEXT;
    school_id UUID;
    date_of_birth DATE;
    role_name TEXT;
BEGIN
    -- Get code details with user profile information and role
    SELECT uc.profile_id, uc.created_at, uc.used_at, uc.code_instance, uc.code_attempts,
           up.first_name, up.last_name, up.school_id, up.date_of_birth,
           r.name
    INTO profile_id, code_created_at, code_used_at, code_instance,
         code_attempts, first_name, last_name, school_id, date_of_birth, role_name
    FROM user_codes uc
    JOIN user_profiles up ON uc.profile_id = up.id
    LEFT JOIN user_roles ur ON up.id = ur.user_profile_id
    LEFT JOIN roles r ON ur.role_id = r.id AND r.is_subrole = false
    WHERE uc.code = input_code
    AND uc.used_at IS NULL
    AND uc.revoked_at IS NULL
    AND uc.expires_at > NOW();

    -- Check if code exists
    IF profile_id IS NULL THEN
        RETURN json_build_object(
            'success', false,
            'error', 'Code not found, expired, revoked, or already used',
            'data', json_build_object(
              'profile_id', null,
              'code_attempts', null,
              'first_name', null,
              'last_name', null,
              'school_id', null,
              'date_of_birth', null,
              'code_instance', null,
              'role_name', null
            )
        );
    END IF;

    -- Return success response with code status
    RETURN json_build_object(
        'success', true,
        'error', null,
        'data', json_build_object(
          'profile_id', profile_id,
          'code_attempts', code_attempts,
          'first_name', first_name,
          'last_name', last_name,
          'school_id', school_id,
          'date_of_birth', date_of_birth,
          'code_instance', code_instance,
          'code_created_at', code_created_at,
          'role_name', role_name
        )
    );

EXCEPTION
    WHEN OTHERS THEN
        RETURN json_build_object(
            'success', false,
            'error', SQLERRM,
            'data', json_build_object(
              'profile_id', null,
              'code_attempts', null,
              'first_name', null,
              'last_name', null,
              'school_id', null,
              'date_of_birth', null,
              'code_instance', null,
              'role_name', null
            )
        );
END;
$$;


ALTER FUNCTION public.get_user_profile_by_code(input_code character varying) OWNER TO supabase_admin;

--
-- Name: get_user_school_id(); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.get_user_school_id() RETURNS uuid
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    AS $$
DECLARE
    v_profile_id uuid;
    v_school_id uuid;
BEGIN
    -- Extract profile_id from auth metadata
    SELECT (auth.jwt() -> 'user_metadata' ->> 'profile_id')::uuid 
    INTO v_profile_id;
    
    -- If no profile_id in metadata, return null
    IF v_profile_id IS NULL THEN
        RETURN NULL;
    END IF;
    
    -- Look up school_id using the profile_id
    SELECT school_id 
    INTO v_school_id
    FROM user_profiles 
    WHERE id = v_profile_id;
    
    RETURN v_school_id;
END;
$$;


ALTER FUNCTION public.get_user_school_id() OWNER TO supabase_admin;

--
-- Name: handle_new_user(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.handle_new_user() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO ''
    AS $$
begin
  insert into public.profiles (id, full_name, avatar_url)
  values (new.id, new.raw_user_meta_data->>'full_name', new.raw_user_meta_data->>'avatar_url');
  return new;
end;
$$;


ALTER FUNCTION public.handle_new_user() OWNER TO postgres;

--
-- Name: import_selected_holidays_to_calendar(uuid, uuid[]); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.import_selected_holidays_to_calendar(school_id uuid, selected_ids uuid[]) RETURNS void
    LANGUAGE plpgsql
    AS $$
begin
  insert into schedule_calendar_exceptions (
    id,
    school_id,
    date,
    end_date,
    type,
    notes,
    source,
    is_official
  )
  select
    gen_random_uuid(),
    school_id,
    phb.start_date,
    phb.end_date,
    case
      when phb.type = 'ferientag' then 'holiday'
      when phb.type = 'feiertag' then 'school_closed'
      when phb.type = 'unterrichtsfrei' then 'no_courses'
      else null
    end,
    phb.name,
    phb.source,
    coalesce(phb.is_official, true)
  from public_holiday_and_breaks phb
  where phb.id = any (selected_ids);
end;
$$;


ALTER FUNCTION public.import_selected_holidays_to_calendar(school_id uuid, selected_ids uuid[]) OWNER TO supabase_admin;

--
-- Name: ingest_interview_everything(uuid, uuid, jsonb, uuid, boolean); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.ingest_interview_everything(p_student_id uuid, p_registration_period_id uuid, p_payload jsonb, p_submitted_by uuid DEFAULT NULL::uuid, p_debug boolean DEFAULT false) RETURNS jsonb
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_now                  timestamptz := now();
  v_school_id            uuid;
  v_period_school_id     uuid;
  v_semester_id          uuid;
  v_status               text;
  v_opened_at            timestamptz;
  v_closed_at            timestamptz;

  v_submission_id        uuid;
  v_student_grade        integer;

  v_apps_upserted        integer := 0;
  v_apps_deleted         integer := 0;

  v_profiles_created     integer := 0;
  v_members_added        integer := 0;
  v_links_inserted       integer := 0;
  v_links_deleted        integer := 0;
  v_links_updated        integer := 0;
  v_siblings_processed   integer := 0;
  v_pickup_rules_applied boolean := false;

  v_family_id            uuid;
  v_primary_contact_id   uuid;

  v_choice               jsonb;
  v_day                  smallint;
  v_rank                 smallint;
  v_window_id            uuid;

  v_contact              jsonb;
  v_contact_type         text;
  v_existing_profile_id  uuid;
  v_local_first          text;
  v_local_last           text;
  v_local_phone          text;
  v_local_email          text;
  v_relation_label       text;

  v_new_profile_id       uuid;
  v_tmp_count            integer;

  v_submitted_by         uuid;

  v_payload_choices_count int := 0;
  v_payload_nooffers_count int := 0;
  v_rows_choices_after     int := 0;
  v_rows_nooffers_after    int := 0;

  v_initial_payload_keys text[];
BEGIN
  -- Local debug helper
  IF p_debug THEN
    INSERT INTO public.ingest_interview_debug_log(student_id, registration_period_id, stage, message, details)
    VALUES (p_student_id, p_registration_period_id, 'begin', 'payload received', p_payload);
    RAISE NOTICE '[ingest] begin payload: %', p_payload;
  END IF;

  -- Serialize per student to avoid racing writes
  PERFORM pg_advisory_xact_lock(hashtext(p_student_id::text));

  -- Resolve student's school
  SELECT up.school_id
  INTO v_school_id
  FROM public.user_profiles up
  WHERE up.id = p_student_id;
  IF v_school_id IS NULL THEN
    RAISE EXCEPTION 'Student % not found', p_student_id USING ERRCODE = 'foreign_key_violation';
  END IF;

  -- Registration period validation (allow open or scheduled, time-gated)
  SELECT rp.school_id, rp.semester_id, rp.status, rp.opened_at, rp.closed_at
  INTO v_period_school_id, v_semester_id, v_status, v_opened_at, v_closed_at
  FROM public.registration_periods rp
  WHERE rp.id = p_registration_period_id;

  IF v_semester_id IS NULL THEN
    RAISE EXCEPTION 'Registration period % not found', p_registration_period_id;
  END IF;
  IF v_period_school_id <> v_school_id THEN
    RAISE EXCEPTION 'Registration period % belongs to a different school', p_registration_period_id;
  END IF;
  IF v_now < v_opened_at OR v_now > v_closed_at OR lower(COALESCE(v_status,'')) NOT IN ('open','scheduled') THEN
    RAISE EXCEPTION 'Registration period is not open (status: %, window: %..%)', v_status, v_opened_at, v_closed_at;
  END IF;

  -- submitted_by guard (auto-nullify invalid)
  v_submitted_by := p_submitted_by;
  IF v_submitted_by IS NOT NULL AND NOT EXISTS (
    SELECT 1 FROM public.user_profiles WHERE id = v_submitted_by
  ) THEN
    IF p_debug THEN
      INSERT INTO public.ingest_interview_debug_log(student_id, registration_period_id, stage, message, details)
      VALUES (p_student_id, p_registration_period_id, 'guard', 'submitted_by not found -> NULL', jsonb_build_object('submitted_by', v_submitted_by));
      RAISE NOTICE '[ingest] submitted_by % not found -> NULL', v_submitted_by;
    END IF;
    v_submitted_by := NULL;
  END IF;

  -- Determine student's grade via class
  SELECT c.grade_level
  INTO v_student_grade
  FROM public.profile_info_student pis
  JOIN public.structure_classes c ON c.id = pis.class_id
  WHERE pis.profile_id = p_student_id;

  -- Family for authorized contacts
  SELECT fmcl.family_id
  INTO v_family_id
  FROM public.family_member_child_links fmcl
  WHERE fmcl.child_profile_id = p_student_id
  LIMIT 1;
  IF v_family_id IS NULL THEN
    RAISE EXCEPTION 'Student % is not linked to a family; cannot manage authorized contacts', p_student_id;
  END IF;

  v_primary_contact_id := NULLIF(p_payload->>'primary_contact_profile_id', '')::uuid;

  -- Quick payload stats
  SELECT array_agg(key) INTO v_initial_payload_keys
  FROM jsonb_object_keys(p_payload) AS key;
  v_payload_choices_count := COALESCE(jsonb_array_length(p_payload->'choices'),0);
  v_payload_nooffers_count := COALESCE(jsonb_array_length(p_payload->'no_offers'),0);

  IF p_debug THEN
    INSERT INTO public.ingest_interview_debug_log(student_id, registration_period_id, stage, message, details)
    VALUES (p_student_id, p_registration_period_id, 'payload.stats', 'keys + counts',
            jsonb_build_object('keys', v_initial_payload_keys, 'choices_len', v_payload_choices_count, 'no_offers_len', v_payload_nooffers_count));
    RAISE NOTICE '[ingest] payload keys: %, choices=% no_offers=%', v_initial_payload_keys, v_payload_choices_count, v_payload_nooffers_count;
  END IF;

  -- 1) Submission header
  INSERT INTO public.student_course_wish_submissions (
    student_id, school_id, registration_period_id, semester_id,
    submitted_at, submitted_by, payload, over_limit_total, over_limit_per_day
  )
  VALUES (
    p_student_id, v_school_id, p_registration_period_id, v_semester_id,
    v_now, v_submitted_by, p_payload, false, false
  )
  ON CONFLICT (student_id, registration_period_id)
  DO UPDATE SET
    semester_id = EXCLUDED.semester_id,
    submitted_at = EXCLUDED.submitted_at,
    submitted_by = EXCLUDED.submitted_by,
    payload = EXCLUDED.payload,
    over_limit_total = EXCLUDED.over_limit_total,
    over_limit_per_day = EXCLUDED.over_limit_per_day
  RETURNING id INTO v_submission_id;

  IF p_debug THEN
    INSERT INTO public.ingest_interview_debug_log(student_id, registration_period_id, stage, message, details)
    VALUES (p_student_id, p_registration_period_id, 'submission', 'upserted submission', jsonb_build_object('submission_id', v_submission_id));
  END IF;

  -- 2) Replace normalized choices
  DELETE FROM public.student_course_wish_choices WHERE submission_id = v_submission_id;

  -- insert "no offer"
  IF (p_payload ? 'no_offers') THEN
    INSERT INTO public.student_course_wish_choices (submission_id, day_of_week, rank, window_id, no_offer)
    SELECT v_submission_id, (elem)::smallint, 0, NULL::uuid, true
    FROM jsonb_array_elements_text(p_payload->'no_offers') AS t(elem)
    WHERE (elem)::int BETWEEN 1 AND 5;
  END IF;

  -- ranked choices
  FOR v_choice IN
    SELECT c FROM jsonb_array_elements(COALESCE(p_payload->'choices','[]'::jsonb)) AS t(c)
  LOOP
    v_day := NULLIF((v_choice->>'day_of_week'), '')::smallint;
    v_rank := NULLIF((v_choice->>'rank'), '')::smallint;
    v_window_id := NULLIF(v_choice->>'window_id','')::uuid;

    IF v_day IS NULL OR v_rank IS NULL OR v_window_id IS NULL THEN
      RAISE EXCEPTION 'Invalid choice payload element: %', v_choice;
    END IF;
    IF v_day < 1 OR v_day > 5 OR v_rank < 1 OR v_rank > 10 THEN
      RAISE EXCEPTION 'Invalid day/rank in choice: %', v_choice;
    END IF;

    PERFORM 1
    FROM public.course_registration_windows w
    WHERE w.id = v_window_id
      AND w.school_id = v_school_id
      AND w.registration_period_id = p_registration_period_id
      AND (w.grade_levels IS NULL OR v_student_grade IS NULL OR v_student_grade = ANY (w.grade_levels));
    IF NOT FOUND THEN
      RAISE EXCEPTION 'Window % invalid for student %', v_window_id, p_student_id;
    END IF;

    INSERT INTO public.student_course_wish_choices (submission_id, day_of_week, rank, window_id, no_offer)
    VALUES (v_submission_id, v_day, v_rank, v_window_id, false);
  END LOOP;

  -- rows after insert
  SELECT
    COALESCE(SUM(CASE WHEN no_offer=false THEN 1 ELSE 0 END),0),
    COALESCE(SUM(CASE WHEN no_offer=true THEN 1 ELSE 0 END),0)
  INTO v_rows_choices_after, v_rows_nooffers_after
  FROM public.student_course_wish_choices
  WHERE submission_id = v_submission_id;

  IF p_debug THEN
    INSERT INTO public.ingest_interview_debug_log(student_id, registration_period_id, stage, message, details)
    VALUES (p_student_id, p_registration_period_id, 'choices', 'rows after insert',
            jsonb_build_object('choices_rows', v_rows_choices_after, 'no_offer_rows', v_rows_nooffers_after));
    RAISE NOTICE '[ingest] choices rows=% no_offer rows=%', v_rows_choices_after, v_rows_nooffers_after;
  END IF;

  -- 3) Sync course_applications
  WITH current_choices AS (
    SELECT day_of_week, rank, window_id
    FROM public.student_course_wish_choices
    WHERE submission_id = v_submission_id AND no_offer = false
  ),
  choice_windows AS (
    SELECT cc.day_of_week, cc.rank, cc.window_id, w.course_id
    FROM current_choices cc
    JOIN public.course_registration_windows w ON w.id = cc.window_id
  ),
  upserted AS (
    INSERT INTO public.course_applications (
      student_id, school_id, course_id, window_id,
      registration_period_id, semester_id,
      day_of_week, rank, status, source, applied_at, created_by
    )
    SELECT
      p_student_id, v_school_id, cw.course_id, cw.window_id,
      p_registration_period_id, v_semester_id,
      cw.day_of_week, cw.rank, 'pending', 'interview', v_now, v_submitted_by
    FROM choice_windows cw
    ON CONFLICT (student_id, registration_period_id, window_id)
    WHERE (window_id IS NOT NULL)
    DO UPDATE SET
      day_of_week = EXCLUDED.day_of_week,
      rank = EXCLUDED.rank,
      status = 'pending',
      source = 'interview',
      applied_at = EXCLUDED.applied_at,
      created_by = EXCLUDED.created_by
    RETURNING id
  )
  SELECT COUNT(*)::int INTO v_apps_upserted FROM upserted;

  WITH del AS (
    DELETE FROM public.course_applications ca
    WHERE ca.student_id = p_student_id
      AND ca.registration_period_id = p_registration_period_id
      AND ca.source = 'interview'
      AND ca.window_id IS NOT NULL
      AND NOT EXISTS (
        SELECT 1
        FROM public.student_course_wish_choices c
        WHERE c.submission_id = v_submission_id
          AND c.no_offer = false
          AND c.window_id = ca.window_id
      )
    RETURNING 1
  )
  SELECT COUNT(*)::int INTO v_apps_deleted FROM del;

  IF p_debug THEN
    INSERT INTO public.ingest_interview_debug_log(student_id, registration_period_id, stage, message, details)
    VALUES (p_student_id, p_registration_period_id, 'applications', 'upsert/delete counts',
            jsonb_build_object('apps_upserted', v_apps_upserted, 'apps_deleted', v_apps_deleted));
    RAISE NOTICE '[ingest] apps upserted=% deleted=%', v_apps_upserted, v_apps_deleted;
  END IF;

  -- 4) Pickup rules (best-effort)
  IF (p_payload ? 'pickup_rules') THEN
    BEGIN
      PERFORM public.create_standard_pickup_rules_from_json(
        p_student_id, v_semester_id, p_payload->'pickup_rules', v_submitted_by
      );
      v_pickup_rules_applied := true;
      IF p_debug THEN
        INSERT INTO public.ingest_interview_debug_log(student_id, registration_period_id, stage, message, details)
        VALUES (p_student_id, p_registration_period_id, 'pickup_rules', 'applied', p_payload->'pickup_rules');
      END IF;
    EXCEPTION WHEN undefined_function THEN
      IF p_debug THEN
        INSERT INTO public.ingest_interview_debug_log(student_id, registration_period_id, stage, message, details)
        VALUES (p_student_id, p_registration_period_id, 'pickup_rules', 'helper missing', NULL);
      END IF;
    END;
  ELSE
    IF p_debug THEN
      INSERT INTO public.ingest_interview_debug_log(student_id, registration_period_id, stage, message, details)
      VALUES (p_student_id, p_registration_period_id, 'pickup_rules', 'not provided', NULL);
    END IF;
  END IF;

  -- 5) Authorized contacts (replace mode)
  IF (p_payload ? 'authorized_contacts') THEN
    FOR v_contact IN
      SELECT c FROM jsonb_array_elements(p_payload->'authorized_contacts') AS t(c)
    LOOP
      v_contact_type := lower(COALESCE(v_contact->>'type', 'existing'));

      IF v_contact_type = 'existing' THEN
        v_existing_profile_id := NULLIF(v_contact->>'profile_id', '')::uuid;
        v_relation_label := NULLIF(v_contact->>'relation_label', '');
        IF v_existing_profile_id IS NULL THEN
          RAISE EXCEPTION 'Existing contact missing profile_id: %', v_contact;
        END IF;

        INSERT INTO public.family_members (family_id, profile_id, role, relation_description)
        VALUES (v_family_id, v_existing_profile_id, 'parent', v_relation_label)
        ON CONFLICT (family_id, profile_id) DO UPDATE
          SET relation_description = COALESCE(EXCLUDED.relation_description, public.family_members.relation_description);
        v_members_added := v_members_added + 1;

      ELSIF v_contact_type = 'local' THEN
        v_local_first := COALESCE(NULLIF(v_contact->>'first_name', ''), '(Unbenannt)');
        v_local_last  := COALESCE(NULLIF(v_contact->>'last_name', ''), '(Kontakt)');
        v_relation_label := NULLIF(v_contact->>'relation_label', '');
        v_local_phone := NULLIF(v_contact->>'phone', '');
        v_local_email := NULLIF(v_contact->>'email', '');

        INSERT INTO public.user_profiles (school_id, first_name, last_name, account_status)
        VALUES (v_school_id, v_local_first, v_local_last, 'none')
        RETURNING id INTO v_new_profile_id;
        v_profiles_created := v_profiles_created + 1;

        BEGIN
          INSERT INTO public.profile_info_family_member (profile_id)
          VALUES (v_new_profile_id)
          ON CONFLICT (profile_id) DO NOTHING;
        EXCEPTION WHEN undefined_table THEN
          NULL;
        END;

        INSERT INTO public.family_members (family_id, profile_id, role, relation_description)
        VALUES (v_family_id, v_new_profile_id, 'parent', v_relation_label)
        ON CONFLICT (family_id, profile_id) DO NOTHING;

      ELSIF v_contact_type = 'sibling' THEN
        v_existing_profile_id := NULLIF(v_contact->>'student_id', '')::uuid;
        IF v_existing_profile_id IS NULL THEN
          RAISE EXCEPTION 'Sibling contact missing student_id: %', v_contact;
        END IF;
        BEGIN
          PERFORM public.set_sibling_pickup_authorization(
            p_student_id, v_existing_profile_id, true, v_submitted_by
          );
          v_siblings_processed := v_siblings_processed + 1;
        EXCEPTION WHEN undefined_function THEN
          NULL;
        END;
      ELSE
        RAISE EXCEPTION 'Unknown authorized_contacts.type: %', v_contact_type;
      END IF;
    END LOOP;

    -- Desired adult set
    CREATE TEMP TABLE tmp_desired_adults (adult_profile_id uuid PRIMARY KEY) ON COMMIT DROP;

    INSERT INTO tmp_desired_adults (adult_profile_id)
    SELECT DISTINCT NULLIF(c->>'profile_id','')::uuid
    FROM jsonb_array_elements(p_payload->'authorized_contacts') AS t(c)
    WHERE lower(COALESCE(c->>'type','existing')) = 'existing' AND c ? 'profile_id';

    INSERT INTO tmp_desired_adults (adult_profile_id)
    SELECT fm.profile_id
    FROM public.family_members fm
    WHERE fm.family_id = v_family_id
      AND fm.role = 'parent'
      AND NOT EXISTS (SELECT 1 FROM tmp_desired_adults d WHERE d.adult_profile_id = fm.profile_id);

    -- Replace links not in desired set
    WITH del AS (
      DELETE FROM public.family_member_child_links l
      WHERE l.family_id = v_family_id
        AND l.child_profile_id = p_student_id
        AND NOT EXISTS (SELECT 1 FROM tmp_desired_adults d WHERE d.adult_profile_id = l.adult_profile_id)
      RETURNING 1
    )
    SELECT COUNT(*)::int INTO v_links_deleted FROM del;

    -- Ensure links for desired adults, with primary priority
    WITH ins AS (
      INSERT INTO public.family_member_child_links (family_id, adult_profile_id, child_profile_id, pickup_priority)
      SELECT v_family_id, d.adult_profile_id, p_student_id,
             CASE WHEN d.adult_profile_id = v_primary_contact_id THEN 1 ELSE NULL END
      FROM tmp_desired_adults d
      ON CONFLICT (family_id, adult_profile_id, child_profile_id)
      DO NOTHING
      RETURNING 1
    )
    SELECT COALESCE(COUNT(*)::int, 0) INTO v_links_inserted FROM ins;

    UPDATE public.family_member_child_links l
    SET pickup_priority = CASE WHEN l.adult_profile_id = v_primary_contact_id THEN 1 ELSE NULL END
    WHERE l.family_id = v_family_id
      AND l.child_profile_id = p_student_id;

    GET DIAGNOSTICS v_links_updated = ROW_COUNT;

    IF p_debug THEN
      INSERT INTO public.ingest_interview_debug_log(student_id, registration_period_id, stage, message, details)
      VALUES (p_student_id, p_registration_period_id, 'contacts', 'processed counts',
              jsonb_build_object('profiles_created', v_profiles_created, 'members_added', v_members_added,
                                 'links_inserted', v_links_inserted, 'links_deleted', v_links_deleted,
                                 'links_updated', v_links_updated, 'siblings_processed', v_siblings_processed,
                                 'primary_contact_id', v_primary_contact_id));
    END IF;
  ELSE
    IF p_debug THEN
      INSERT INTO public.ingest_interview_debug_log(student_id, registration_period_id, stage, message, details)
      VALUES (p_student_id, p_registration_period_id, 'contacts', 'not provided', NULL);
    END IF;
  END IF;

  IF p_debug THEN
    INSERT INTO public.ingest_interview_debug_log(student_id, registration_period_id, stage, message, details)
    VALUES (p_student_id, p_registration_period_id, 'end', 'summary',
            jsonb_build_object(
              'submission_id', v_submission_id,
              'choices_rows', v_rows_choices_after,
              'no_offer_rows', v_rows_nooffers_after,
              'apps_upserted', v_apps_upserted,
              'apps_deleted', v_apps_deleted,
              'pickup_rules_applied', v_pickup_rules_applied
            ));
  END IF;

  RETURN jsonb_build_object(
    'submission_id', v_submission_id,
    'choices_rows', v_rows_choices_after,
    'no_offer_rows', v_rows_nooffers_after,
    'apps_upserted', v_apps_upserted,
    'apps_deleted', v_apps_deleted,
    'profiles_created', v_profiles_created,
    'family_members_added', v_members_added,
    'links_inserted', v_links_inserted,
    'links_deleted', v_links_deleted,
    'links_updated', v_links_updated,
    'siblings_processed', v_siblings_processed,
    'pickup_rules_applied', v_pickup_rules_applied
  );
END;
$$;


ALTER FUNCTION public.ingest_interview_everything(p_student_id uuid, p_registration_period_id uuid, p_payload jsonb, p_submitted_by uuid, p_debug boolean) OWNER TO supabase_admin;

--
-- Name: FUNCTION ingest_interview_everything(p_student_id uuid, p_registration_period_id uuid, p_payload jsonb, p_submitted_by uuid, p_debug boolean); Type: COMMENT; Schema: public; Owner: supabase_admin
--

COMMENT ON FUNCTION public.ingest_interview_everything(p_student_id uuid, p_registration_period_id uuid, p_payload jsonb, p_submitted_by uuid, p_debug boolean) IS 'Ingest full interview payload. p_debug=true writes to ingest_interview_debug_log and raises NOTICEs.';


--
-- Name: ingest_interview_ui_wrapper(uuid, uuid, jsonb, uuid, boolean); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.ingest_interview_ui_wrapper(p_student_id uuid, p_registration_period_id uuid, p_ui_payload jsonb, p_submitted_by uuid DEFAULT NULL::uuid, p_debug boolean DEFAULT false) RETURNS TABLE(ui_payload jsonb, normalized_payload jsonb, result jsonb)
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_school_id uuid;
  v_semester_id uuid;
  v_submission_id uuid;
  v_choices jsonb := '[]'::jsonb;
  v_no_offers jsonb := '[]'::jsonb;
  v_fallbacks jsonb := '[]'::jsonb;
  v_normalized jsonb := '{}'::jsonb;
  v_now timestamptz := now();
BEGIN
  -- If you already have a resolver, use it; otherwise keep NULLs where unknown
  SELECT scws.school_id, scws.semester_id
  INTO v_school_id, v_semester_id
  FROM public.student_course_wish_submissions scws
  WHERE scws.student_id = p_student_id
    AND scws.registration_period_id = p_registration_period_id
  LIMIT 1;

  -- Normalize course_choices, no_offers, pickup_fallbacks from the UI
  WITH raw AS (
    SELECT jsonb_array_elements(COALESCE(p_ui_payload->'course_choices','[]'::jsonb)) AS item
  ),
  mapped AS (
    SELECT
      CASE
        WHEN (item->>'day') ILIKE 'montag' THEN 1
        WHEN (item->>'day') ILIKE 'dienstag' THEN 2
        WHEN (item->>'day') ILIKE 'mittwoch' THEN 3
        WHEN (item->>'day') ILIKE 'donnerstag' THEN 4
        WHEN (item->>'day') ILIKE 'freitag' THEN 5
        ELSE NULL
      END AS dow,
      NULLIF(item->>'window_id','')::uuid AS window_id,
      NULLIF(item->>'rank','')::int AS rank,
      COALESCE((item->>'no_offer')::boolean, false) AS no_offer,
      COALESCE((item->>'pickup_fallback')::boolean, false) AS pickup_fallback
    FROM raw
  )
  SELECT
    COALESCE(
      jsonb_agg(
        jsonb_build_object('rank', rank, 'window_id', window_id, 'day_of_week', dow)
        ORDER BY dow, rank
      ) FILTER (WHERE window_id IS NOT NULL AND dow IS NOT NULL AND rank IS NOT NULL),
      '[]'::jsonb
    ) AS choices_json,
    COALESCE(
      jsonb_agg(DISTINCT to_jsonb(dow))
      FILTER (WHERE no_offer IS TRUE AND dow IS NOT NULL),
      '[]'::jsonb
    ) AS no_offers_json,
    COALESCE(
      jsonb_agg(
        jsonb_build_object('day_of_week', dow, 'rank', rank)
        ORDER BY dow, rank
      ) FILTER (WHERE pickup_fallback IS TRUE AND dow IS NOT NULL AND rank IS NOT NULL),
      '[]'::jsonb
    ) AS fallbacks_json
  INTO v_choices, v_no_offers, v_fallbacks
  FROM mapped;

  v_normalized := jsonb_build_object(
    'choices', v_choices,
    'no_offers', v_no_offers,
    'pickup_fallbacks', v_fallbacks,
    'heimweg', COALESCE(p_ui_payload->'heimweg','{}'::jsonb)
  );

  -- Optional debug logging (requires public.log_ingest_debug to exist)
  IF p_debug THEN
    BEGIN
      PERFORM public.log_ingest_debug('wrapper.normalize', p_student_id, p_registration_period_id, 'normalized payload', v_normalized);
    EXCEPTION WHEN undefined_function THEN
      NULL;
    END;
  END IF;

  -- Upsert the submission:
  -- - interview_raw stores the COMPLETE interview object exactly as received
  -- - payload keeps both interview and normalized for quick reads
  INSERT INTO public.student_course_wish_submissions (
    student_id, school_id, registration_period_id, semester_id,
    submitted_at, submitted_by, payload, interview_raw,
    over_limit_total, over_limit_per_day
  )
  VALUES (
    p_student_id, v_school_id, p_registration_period_id, v_semester_id,
    v_now, p_submitted_by,
    jsonb_build_object(
      'schema_version', 1,
      'interview', p_ui_payload,
      'normalized', v_normalized
    ),
    p_ui_payload,
    false, false
  )
  ON CONFLICT (student_id, registration_period_id)
  DO UPDATE SET
    semester_id = COALESCE(EXCLUDED.semester_id, public.student_course_wish_submissions.semester_id),
    submitted_at = EXCLUDED.submitted_at,
    submitted_by = EXCLUDED.submitted_by,
    payload = EXCLUDED.payload,
    interview_raw = EXCLUDED.interview_raw,
    over_limit_total = EXCLUDED.over_limit_total,
    over_limit_per_day = EXCLUDED.over_limit_per_day
  RETURNING id INTO v_submission_id;

  IF p_debug THEN
    BEGIN
      PERFORM public.log_ingest_debug('wrapper.submission_upsert', p_student_id, p_registration_period_id, 'submission upserted', jsonb_build_object('submission_id', v_submission_id));
    EXCEPTION WHEN undefined_function THEN
      NULL;
    END;
  END IF;

  -- Rebuild course_applications from normalized choices (adjust to your actual function)
  PERFORM public.ingest_interview_everything(
    p_student_id := p_student_id,
    p_registration_period_id := p_registration_period_id,
    p_payload := v_normalized,
    p_submitted_by := p_submitted_by,
    p_debug := p_debug
  );

  IF p_debug THEN
    BEGIN
      PERFORM public.log_ingest_debug('wrapper.done', p_student_id, p_registration_period_id, 'completed', NULL);
    EXCEPTION WHEN undefined_function THEN
      NULL;
    END;
  END IF;

  RETURN QUERY
  SELECT
    p_ui_payload AS ui_payload,
    v_normalized AS normalized_payload,
    jsonb_build_object(
      'submission_id', v_submission_id,
      'choices_rows', jsonb_array_length(v_choices),
      'no_offers_count', jsonb_array_length(v_no_offers),
      'pickup_fallbacks_count', jsonb_array_length(v_fallbacks)
    ) AS result;
END;
$$;


ALTER FUNCTION public.ingest_interview_ui_wrapper(p_student_id uuid, p_registration_period_id uuid, p_ui_payload jsonb, p_submitted_by uuid, p_debug boolean) OWNER TO supabase_admin;

--
-- Name: ingest_interview_ui_wrapper.alt(uuid, uuid, jsonb, uuid, boolean); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public."ingest_interview_ui_wrapper.alt"(p_student_id uuid, p_registration_period_id uuid, p_ui_payload jsonb, p_submitted_by uuid DEFAULT NULL::uuid, p_debug boolean DEFAULT false) RETURNS jsonb
    LANGUAGE plpgsql
    AS $$DECLARE
  v_norm jsonb;
  v_res  jsonb;
BEGIN
  v_norm := public.normalize_interview_ui_payload(p_ui_payload);

  IF p_debug THEN
    INSERT INTO public.ingest_interview_debug_log(student_id, registration_period_id, stage, message, details)
    VALUES (p_student_id, p_registration_period_id, 'wrapper.normalize', 'normalized payload', v_norm);
    RAISE NOTICE '[wrapper] normalized=%', v_norm;
  END IF;

  v_res := public.ingest_interview_everything(
    p_student_id,
    p_registration_period_id,
    v_norm,
    p_submitted_by,
    p_debug
  );

  RETURN jsonb_build_object(
    'normalized_payload', v_norm,
    'result', v_res
  );
END;$$;


ALTER FUNCTION public."ingest_interview_ui_wrapper.alt"(p_student_id uuid, p_registration_period_id uuid, p_ui_payload jsonb, p_submitted_by uuid, p_debug boolean) OWNER TO supabase_admin;

--
-- Name: FUNCTION "ingest_interview_ui_wrapper.alt"(p_student_id uuid, p_registration_period_id uuid, p_ui_payload jsonb, p_submitted_by uuid, p_debug boolean); Type: COMMENT; Schema: public; Owner: supabase_admin
--

COMMENT ON FUNCTION public."ingest_interview_ui_wrapper.alt"(p_student_id uuid, p_registration_period_id uuid, p_ui_payload jsonb, p_submitted_by uuid, p_debug boolean) IS 'Wrapper that normalizes UI payload (course_choices / flat/noOfferDays) then calls ingest_interview_everything.';


--
-- Name: is_current_user_staff(); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.is_current_user_staff() RETURNS boolean
    LANGUAGE sql STABLE SECURITY DEFINER
    AS $$
  SELECT CASE 
    WHEN auth.uid() IS NULL THEN false
    ELSE EXISTS (
      SELECT 1 FROM user_profiles up
      JOIN roles r ON r.id = up.role_id
      WHERE up.id = auth.uid()
      AND r.name IN ('Teacher', 'Admin', 'Staff')
    )
  END;
$$;


ALTER FUNCTION public.is_current_user_staff() OWNER TO supabase_admin;

--
-- Name: is_user_staff_optimized(uuid); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.is_user_staff_optimized(user_id uuid DEFAULT auth.uid()) RETURNS boolean
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    AS $$
BEGIN
  -- Early return if no user
  IF user_id IS NULL THEN
    RETURN false;
  END IF;
  
  -- Direct lookup with actual role IDs from the database
  RETURN EXISTS (
    SELECT 1 FROM user_profiles up
    WHERE up.id = user_id
    AND up.role_id IN (
      '8b8123fd-ee8e-429d-b6c6-579f82e7c306', -- Teacher
      '6b4ffe63-6384-497b-b40c-473af51dc26d'  -- Admin
    )
  );
END;
$$;


ALTER FUNCTION public.is_user_staff_optimized(user_id uuid) OWNER TO supabase_admin;

--
-- Name: link_and_invite_parent(uuid, text, text, uuid, uuid, jsonb, jsonb, uuid, boolean); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.link_and_invite_parent(p_parent_profile_id uuid, p_first_name text, p_last_name text, p_family_id uuid, p_school_id uuid, p_contacts jsonb, p_student_connections jsonb, p_added_by uuid, p_send_invite boolean DEFAULT false) RETURNS jsonb
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_new_profile_id UUID;
  v_user_code_data JSONB;
  v_primary_email TEXT;
  v_parent_role_id UUID;
  v_result JSONB;
  v_parent_family_member_key JSONB;
  v_student_family_member_keys JSONB[] := '{}';
  v_child_link_ids UUID[] := '{}';
  v_child_link_record RECORD;
BEGIN
  -- Start transaction
  BEGIN
    IF p_parent_profile_id IS NULL THEN
      -- Get Parent role ID
      SELECT id INTO v_parent_role_id
      FROM roles
      WHERE name = 'Parent'
      LIMIT 1;

      IF v_parent_role_id IS NULL THEN
        RAISE EXCEPTION 'Parent role not found in roles table';
      END IF;

      -- Create user profile
      INSERT INTO user_profiles (first_name, last_name, school_id, role_id, account_status)
      VALUES (p_first_name, p_last_name, p_school_id, v_parent_role_id, 'none')
      RETURNING id INTO v_new_profile_id;

      -- Add user role
      INSERT INTO user_roles (user_profile_id, role_id)
      VALUES (v_new_profile_id, v_parent_role_id)
      ON CONFLICT (user_profile_id, role_id) DO NOTHING;

      -- Add contacts with safer boolean handling
      INSERT INTO contacts (
        profile_id,
        profile_type,
        type,
        value,
        is_primary,
        notes,
        is_linked_to_user_login
      )
      SELECT
        v_new_profile_id,
        'parent',
        (contact->>'contact_type')::TEXT,
        (contact->>'contact_value')::TEXT,
        CASE
          WHEN (contact->>'is_primary')::TEXT = 'true' THEN TRUE
          WHEN (contact->>'is_primary')::TEXT = 'false' THEN FALSE
          WHEN (contact->>'is_primary') IS NULL THEN FALSE
          ELSE FALSE
        END,
        (contact->>'notes')::TEXT,
        CASE
          WHEN (contact->>'is_linked_to_user_login')::TEXT = 'true' THEN TRUE
          WHEN (contact->>'is_linked_to_user_login')::TEXT = 'false' THEN FALSE
          WHEN (contact->>'is_linked_to_user_login') IS NULL THEN FALSE
          ELSE FALSE
        END
      FROM jsonb_array_elements(p_contacts) AS contact;
    ELSE
      -- Use existing profile ID
      v_new_profile_id := p_parent_profile_id;
    END IF;

    -- Add family member for parent
    INSERT INTO family_members (
      family_id,
      profile_id,
      role,
      relation_description,
      is_primary_guardian,
      is_primary_contact,
      notes,
      added_by
    )
    VALUES (
      p_family_id,
      v_new_profile_id,
      'parent',
      'Parent',
      TRUE,
      TRUE,
      'Added via link-and-invite-parent function',
      p_added_by
    )
    ON CONFLICT (family_id, profile_id) DO NOTHING;

    -- Store parent family member composite key
    v_parent_family_member_key := jsonb_build_object(
      'family_id', p_family_id,
      'profile_id', v_new_profile_id
    );

    -- Add family member for student (if not already exists) and collect composite keys
    INSERT INTO family_members (
      family_id,
      profile_id,
      role,
      relation_description,
      is_primary_guardian,
      is_primary_contact,
      notes,
      added_by
    )
    SELECT
      p_family_id,
      (connection->>'profile_id')::UUID,
      'student',
      'Student',
      FALSE,
      FALSE,
      'Added via link-and-invite-parent function',
      p_added_by
    FROM jsonb_array_elements(p_student_connections) AS connection
    ON CONFLICT (family_id, profile_id) DO NOTHING;

    -- Store student family member composite keys
    SELECT array_agg(
      jsonb_build_object(
        'family_id', p_family_id,
        'profile_id', (connection->>'profile_id')::UUID
      )
    ) INTO v_student_family_member_keys
    FROM jsonb_array_elements(p_student_connections) AS connection;

    -- Add profile info family member
    INSERT INTO profile_info_family_member (profile_id, school_id)
    VALUES (v_new_profile_id, p_school_id)
    ON CONFLICT (profile_id) DO NOTHING;

    -- Add family member child links and collect IDs
    FOR v_child_link_record IN
      INSERT INTO family_member_child_links (
        family_id,
        adult_profile_id,
        child_profile_id,
        relationship,
        access_restricted,
        notes
      )
      SELECT
        p_family_id,
        v_new_profile_id,
        (connection->>'profile_id')::UUID,
        COALESCE((connection->>'relationship')::TEXT, 'Parent'),
        FALSE,
        'Linked via link-and-invite-parent function'
      FROM jsonb_array_elements(p_student_connections) AS connection
      ON CONFLICT (family_id, adult_profile_id, child_profile_id) DO NOTHING
      RETURNING id
    LOOP
      v_child_link_ids := array_append(v_child_link_ids, v_child_link_record.id);
    END LOOP;

    -- Handle invite if requested
    IF p_send_invite THEN
      -- Get primary email contact
      SELECT (contact->>'contact_value')::TEXT INTO v_primary_email
      FROM jsonb_array_elements(p_contacts) AS contact
      WHERE LOWER((contact->>'contact_type')::TEXT) = 'email'
      LIMIT 1;

      IF v_primary_email IS NOT NULL THEN
        -- Generate user code
        SELECT get_or_generate_user_code(v_new_profile_id) INTO v_user_code_data;

        -- Update account status to invited
        UPDATE user_profiles
        SET account_status = 'invited'
        WHERE id = v_new_profile_id;
      END IF;
    END IF;

    -- Prepare result with family member composite keys and child link IDs
    v_result := jsonb_build_object(
      'success', TRUE,
      'profile_id', v_new_profile_id,
      'family_id', p_family_id,
      'marked_as_invited', p_send_invite AND v_primary_email IS NOT NULL,
      'user_code', CASE WHEN p_send_invite AND v_primary_email IS NOT NULL THEN v_user_code_data ELSE NULL END,
      'invite_email_address', v_primary_email,
      'family_member_keys', jsonb_build_object(
        'parent_family_member_key', v_parent_family_member_key,
        'student_family_member_keys', v_student_family_member_keys
      ),
      'child_link_ids', v_child_link_ids
    );

    -- Commit transaction
    RETURN v_result;

  EXCEPTION
    WHEN OTHERS THEN
      -- Rollback transaction on any error
      RAISE EXCEPTION 'Transaction failed: %', SQLERRM;
  END;
END;
$$;


ALTER FUNCTION public.link_and_invite_parent(p_parent_profile_id uuid, p_first_name text, p_last_name text, p_family_id uuid, p_school_id uuid, p_contacts jsonb, p_student_connections jsonb, p_added_by uuid, p_send_invite boolean) OWNER TO supabase_admin;

--
-- Name: log_change(); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.log_change() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
declare
  v_user_id uuid := current_setting('request.user_id', true)::uuid;
  v_school_id uuid := null;
  v_action_type text;
begin
  -- Detect action type
  if (TG_OP = 'INSERT') then
    v_action_type := 'insert';
  elsif (TG_OP = 'UPDATE') then
    v_action_type := 'update';
  elsif (TG_OP = 'DELETE') then
    if (OLD.is_deleted is null or OLD.is_deleted = false) then
      v_action_type := 'hard_delete';
    else
      v_action_type := 'soft_delete';
    end if;
  else
    raise exception 'Unsupported operation: %', TG_OP;
  end if;

  -- Try to get school_id from current setting
  begin
    v_school_id := current_setting('request.school_id', true)::uuid;
  exception
    when others then
      -- Optional, skip if not set
      null;
  end;

  -- Insert change log
  insert into public.change_log (
    user_id,
    school_id,
    table_name,
    record_id,
    action_type,
    before_data,
    after_data
  ) values (
    v_user_id,
    v_school_id,
    TG_TABLE_NAME,
    coalesce(NEW.id, OLD.id),
    v_action_type,
    case when v_action_type in ('update', 'soft_delete', 'hard_delete') then to_jsonb(OLD) else null end,
    case when v_action_type in ('insert', 'update', 'soft_delete') then to_jsonb(NEW) else null end
  );

  return null;
end;
$$;


ALTER FUNCTION public.log_change() OWNER TO supabase_admin;

--
-- Name: log_change_generic(); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.log_change_generic() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  -- try to read an existing group, else generate one
  v_group   UUID := current_setting('my.change_group_id', true)::UUID;
  -- map the trigger operation
  v_action  TEXT := CASE TG_OP
    WHEN 'INSERT' THEN 'insert'
    WHEN 'UPDATE' THEN 'update'
    WHEN 'DELETE' THEN 'hard_delete'
    ELSE NULL
  END;
  v_user    UUID;
  v_school  UUID;
BEGIN
  -- 1) sanity check
  IF v_action IS NULL THEN
    RAISE EXCEPTION 'Unsupported TG_OP: %', TG_OP;
  END IF;

  -- 2) ensure we always have a change_group_id
  v_group := COALESCE(v_group, gen_random_uuid());

  -- 3) pick the actor & school
  IF TG_OP = 'INSERT' THEN
    v_user   := COALESCE(auth.uid(), NEW.created_by);
    v_school := NEW.school_id;
  ELSE
    v_user   := auth.uid();
    v_school := COALESCE(NEW.school_id, OLD.school_id);
  END IF;

  -- 4) write the audit row
  INSERT INTO public.change_log (
    change_group_id,
    user_id,
    school_id,
    table_name,
    record_id,
    action_type,
    before_data,
    after_data
  ) VALUES (
    v_group,
    v_user,
    v_school,
    TG_TABLE_NAME,
    COALESCE(NEW.id, OLD.id),
    v_action,
    CASE WHEN v_action IN ('update','hard_delete') THEN to_jsonb(OLD) ELSE NULL END,
    CASE WHEN v_action IN ('insert','update')    THEN to_jsonb(NEW) ELSE NULL END
  );

  -- 5) return control to the original DML
  RETURN COALESCE(NEW, OLD);
END;
$$;


ALTER FUNCTION public.log_change_generic() OWNER TO supabase_admin;

--
-- Name: log_ddl_command(); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.log_ddl_command() RETURNS event_trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    obj record;
BEGIN
    FOR obj IN SELECT * FROM pg_event_trigger_ddl_commands() LOOP
        INSERT INTO public.schema_change_log (
            event_type,
            object_type,
            object_name,
            executed_sql,
            username,
            session_user_name
        ) VALUES (
            obj.command_tag,
            obj.object_type,
            obj.object_identity,
            current_query(),
            current_user,
            session_user
        );
    END LOOP;
END;
$$;


ALTER FUNCTION public.log_ddl_command() OWNER TO supabase_admin;

--
-- Name: log_ingest_debug(text, uuid, uuid, text, jsonb); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.log_ingest_debug(p_stage text, p_student_id uuid, p_registration_period_id uuid, p_message text, p_details jsonb) RETURNS void
    LANGUAGE sql
    AS $$
  INSERT INTO public.ingest_interview_debug_log (
    student_id, registration_period_id, stage, message, details
  ) VALUES (p_student_id, p_registration_period_id, p_stage, p_message, p_details);
$$;


ALTER FUNCTION public.log_ingest_debug(p_stage text, p_student_id uuid, p_registration_period_id uuid, p_message text, p_details jsonb) OWNER TO supabase_admin;

--
-- Name: log_manual_change(text, uuid, text, uuid, uuid, jsonb, uuid); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.log_manual_change(p_table_name text, p_record_id uuid, p_action_type text, p_user_id uuid, p_school_id uuid, p_data jsonb, p_change_group_id uuid DEFAULT gen_random_uuid()) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
  INSERT INTO public.change_log (
    user_id,
    school_id,
    table_name,
    record_id,
    action_type,
    after_data,
    change_group_id
  )
  VALUES (
    p_user_id,
    p_school_id,
    p_table_name,
    p_record_id,
    p_action_type,
    p_data,
    p_change_group_id
  );
END;
$$;


ALTER FUNCTION public.log_manual_change(p_table_name text, p_record_id uuid, p_action_type text, p_user_id uuid, p_school_id uuid, p_data jsonb, p_change_group_id uuid) OWNER TO supabase_admin;

--
-- Name: log_recurrence_debug(uuid, text); Type: PROCEDURE; Schema: public; Owner: supabase_admin
--

CREATE PROCEDURE public.log_recurrence_debug(IN p_recurrence_id uuid, IN p_function_called text)
    LANGUAGE plpgsql
    AS $$
BEGIN
  INSERT INTO recurrence_debug_log (recurrence_id, function_called)
  VALUES (p_recurrence_id, p_function_called);
END;
$$;


ALTER PROCEDURE public.log_recurrence_debug(IN p_recurrence_id uuid, IN p_function_called text) OWNER TO supabase_admin;

--
-- Name: log_schema_change(); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.log_schema_change() RETURNS event_trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    rec record;
BEGIN
    FOR rec IN
        SELECT
            command_tag,
            object_type,
            object_identity
        FROM pg_event_trigger_ddl_commands()
        WHERE object_type IN ('table', 'view')
          -- Only log changes to objects in the public schema
          AND object_identity LIKE 'public.%'
    LOOP
        INSERT INTO public.schema_change_log(
            event_type, object_type, object_name, executed_sql, username, event_time
        )
        VALUES (
            rec.command_tag,
            rec.object_type,
            rec.object_identity,
            'SQL NOT AVAILABLE IN EVENT TRIGGER',
            session_user,
            now()
        );
    END LOOP;
END;
$$;


ALTER FUNCTION public.log_schema_change() OWNER TO supabase_admin;

--
-- Name: mark_all_students_present(uuid[], uuid, uuid, uuid); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.mark_all_students_present(p_student_ids uuid[], p_lesson_id uuid, p_school_id uuid, p_recorded_by uuid) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  student uuid;
  v_daily_log_id uuid;
BEGIN
  FOREACH student IN ARRAY p_student_ids
  LOOP
    -- 1. Upsert daily log
    SELECT id INTO v_daily_log_id
    FROM student_daily_log
    WHERE student_id = student
      AND date = current_date;

    IF v_daily_log_id IS NULL THEN
      INSERT INTO student_daily_log (
        student_id,
        school_id,
        date,
        presence_status,
        check_in_time,
        check_in_method,
        check_in_by,
        updated_at,
        last_updated_by
      ) VALUES (
        student,
        p_school_id,
        current_date,
        'present',
        now(),
        'manual',
        p_recorded_by,
        now(),
        p_recorded_by
      )
      RETURNING id INTO v_daily_log_id;
    ELSE
      UPDATE student_daily_log
      SET
        presence_status = 'present',
        check_in_time = now(),
        check_in_method = 'manual',
        check_in_by = p_recorded_by,
        updated_at = now(),
        last_updated_by = p_recorded_by
      WHERE id = v_daily_log_id;
    END IF;

    -- 2. Upsert attendance
    INSERT INTO student_attendance_logs (
      student_id,
      lesson_id,
      daily_log_id,
      status,
      method,
      recorded_by
    ) VALUES (
      student,
      p_lesson_id,
      v_daily_log_id,
      'present',
      'manual',
      p_recorded_by
    )
    ON CONFLICT (student_id, lesson_id) DO UPDATE
    SET
      status = excluded.status,
      method = excluded.method,
      recorded_by = excluded.recorded_by,
      daily_log_id = excluded.daily_log_id,
      timestamp = now();
  END LOOP;
END;
$$;


ALTER FUNCTION public.mark_all_students_present(p_student_ids uuid[], p_lesson_id uuid, p_school_id uuid, p_recorded_by uuid) OWNER TO supabase_admin;

--
-- Name: mark_student_attendance(uuid, uuid, uuid, uuid, public.attendance_status); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.mark_student_attendance(p_student_id uuid, p_lesson_id uuid, p_school_id uuid, p_recorded_by uuid, p_status public.attendance_status) RETURNS text
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_daily_log_id UUID;
  v_existing_status presence_status;
  v_is_late BOOLEAN := FALSE;
  v_first_lesson_ts TIMESTAMP;
  v_enrolled BOOLEAN;
BEGIN
  -- 1. Determine if student is late (only for status = 'late')
  IF p_status = 'late' THEN
    -- Check enrollment and earliest lesson for today
    SELECT true INTO v_enrolled
    FROM course_enrollments ce
    WHERE ce.student_id = p_student_id
      AND ce.school_id = p_school_id
      AND CURRENT_DATE BETWEEN ce.start_date AND ce.end_date
      AND EXISTS (
        SELECT 1
        FROM course_lessons cl
        WHERE cl.course_id = ce.course_id
          AND cl.school_id = p_school_id
          AND cl.is_cancelled IS NOT TRUE
          AND cl.start_datetime::DATE = CURRENT_DATE
      )
    LIMIT 1;

    IF v_enrolled THEN
      SELECT MIN(cl.start_datetime) INTO v_first_lesson_ts
      FROM course_enrollments ce
      JOIN course_lessons cl ON cl.course_id = ce.course_id
      WHERE ce.student_id = p_student_id
        AND ce.school_id = p_school_id
        AND CURRENT_DATE BETWEEN ce.start_date AND ce.end_date
        AND cl.is_cancelled IS NOT TRUE
        AND cl.start_datetime::DATE = CURRENT_DATE;

      IF v_first_lesson_ts IS NOT NULL AND now() > v_first_lesson_ts THEN
        v_is_late := TRUE;
      END IF;
    END IF;
  END IF;

  -- 2. Check for existing daily log
  SELECT id, presence_status INTO v_daily_log_id, v_existing_status
  FROM student_daily_log
  WHERE student_id = p_student_id
    AND date = CURRENT_DATE;

  -- 3. Insert or update daily log
  IF v_daily_log_id IS NULL THEN
    INSERT INTO student_daily_log (
      student_id,
      school_id,
      date,
      presence_status,
      is_late,
      check_in_time,
      check_in_method,
      check_in_by,
      updated_at,
      last_updated_by
    )
    VALUES (
      p_student_id,
      p_school_id,
      CURRENT_DATE,
      CASE 
        WHEN p_status = 'late' THEN 'present'::presence_status
        WHEN p_status = 'present' THEN 'present'::presence_status
        WHEN p_status = 'absent_excused' THEN 'absent_excused'::presence_status
        WHEN p_status = 'absent_unexcused' THEN 'absent_unexcused'::presence_status
        ELSE 'unmarked'::presence_status
      END,
      v_is_late,
      now(),
      'manual',
      p_recorded_by,
      now(),
      p_recorded_by
    )
    RETURNING id INTO v_daily_log_id;

  ELSIF v_existing_status = 'unmarked' THEN
    UPDATE student_daily_log
    SET
      presence_status = CASE 
        WHEN p_status = 'late' THEN 'present'::presence_status
        WHEN p_status = 'present' THEN 'present'::presence_status
        WHEN p_status = 'absent_excused' THEN 'absent_excused'::presence_status
        WHEN p_status = 'absent_unexcused' THEN 'absent_unexcused'::presence_status
        ELSE 'unmarked'::presence_status
      END,
      is_late = v_is_late,
      updated_at = now(),
      last_updated_by = p_recorded_by
    WHERE id = v_daily_log_id;
  END IF;

  -- 4. Upsert into student_attendance_logs
  INSERT INTO student_attendance_logs (
    student_id,
    lesson_id,
    daily_log_id,
    status,
    method,
    recorded_by,
    school_id
  )
  VALUES (
    p_student_id,
    p_lesson_id,
    v_daily_log_id,
    p_status,
    'manual',
    p_recorded_by,
    p_school_id
  )
  ON CONFLICT (student_id, lesson_id) DO UPDATE
  SET
    status = excluded.status,
    method = excluded.method,
    recorded_by = excluded.recorded_by,
    daily_log_id = excluded.daily_log_id,
    school_id = excluded.school_id,
    timestamp = now();

  RETURN 'OK';
END;
$$;


ALTER FUNCTION public.mark_student_attendance(p_student_id uuid, p_lesson_id uuid, p_school_id uuid, p_recorded_by uuid, p_status public.attendance_status) OWNER TO supabase_admin;

--
-- Name: mark_student_attendance_legacy(uuid, uuid, uuid, uuid, text); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.mark_student_attendance_legacy(p_student_id uuid, p_lesson_id uuid, p_school_id uuid, p_recorded_by uuid, p_status text) RETURNS TABLE(daily_log_was_created boolean, daily_log_already_existed boolean)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_daily_log_id uuid;
  v_log_exists boolean := false;
BEGIN
  -- 1. Check for existing daily log
  SELECT id INTO v_daily_log_id
  FROM student_daily_log
  WHERE student_id = p_student_id
    AND date = current_date;

  IF v_daily_log_id IS NULL THEN
    -- 1a. Insert new daily log
    INSERT INTO student_daily_log (
      student_id,
      school_id,
      date,
      presence_status,
      is_late,
      check_in_time,
      check_in_method,
      check_in_by,
      updated_at,
      last_updated_by
    )
    VALUES (
      p_student_id,
      p_school_id,
      current_date,
      CASE 
        WHEN p_status = 'late' THEN 'present'::attendance_status
        ELSE p_status::attendance_status
      END,
      p_status = 'late',
      now(),
      'manual',
      p_recorded_by,
      now(),
      p_recorded_by
    )
    RETURNING id INTO v_daily_log_id;

    daily_log_was_created := true;
    daily_log_already_existed := false;

  ELSE
    daily_log_was_created := false;
    daily_log_already_existed := true;
  END IF;

  -- 2. Upsert lesson attendance
  INSERT INTO student_attendance_logs (
    student_id,
    lesson_id,
    daily_log_id,
    status,
    method,
    recorded_by
  )
  VALUES (
    p_student_id,
    p_lesson_id,
    v_daily_log_id,
    p_status::attendance_status,
    'manual',
    p_recorded_by
  )
  ON CONFLICT (student_id, lesson_id) DO UPDATE
  SET
    status = excluded.status,
    method = excluded.method,
    recorded_by = excluded.recorded_by,
    daily_log_id = excluded.daily_log_id,
    timestamp = now();

  RETURN NEXT;
END;
$$;


ALTER FUNCTION public.mark_student_attendance_legacy(p_student_id uuid, p_lesson_id uuid, p_school_id uuid, p_recorded_by uuid, p_status text) OWNER TO supabase_admin;

--
-- Name: mark_student_present(uuid, uuid, uuid, uuid); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.mark_student_present(p_student_id uuid, p_lesson_id uuid, p_school_id uuid, p_recorded_by uuid) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
  v_daily_log_id uuid;
BEGIN
  -- 1. Upsert daily log
  SELECT id INTO v_daily_log_id
  FROM student_daily_log
  WHERE student_id = p_student_id
    AND date = current_date;

  IF v_daily_log_id IS NULL THEN
    INSERT INTO student_daily_log (
      student_id,
      school_id,
      date,
      presence_status,
      check_in_time,
      check_in_method,
      check_in_by,
      updated_at,
      last_updated_by
    ) VALUES (
      p_student_id,
      p_school_id,
      current_date,
      'present',
      now(),
      'manual',
      p_recorded_by,
      now(),
      p_recorded_by
    )
    RETURNING id INTO v_daily_log_id;
  ELSE
    UPDATE student_daily_log
    SET
      presence_status = 'present',
      check_in_time = now(),
      check_in_method = 'manual',
      check_in_by = p_recorded_by,
      updated_at = now(),
      last_updated_by = p_recorded_by
    WHERE id = v_daily_log_id;
  END IF;

  -- 2. Upsert lesson attendance
  INSERT INTO student_attendance_logs (
    student_id,
    lesson_id,
    daily_log_id,
    status,
    method,
    recorded_by
  ) VALUES (
    p_student_id,
    p_lesson_id,
    v_daily_log_id,
    'present',
    'manual',
    p_recorded_by
  )
  ON CONFLICT (student_id, lesson_id) DO UPDATE
  SET
    status = excluded.status,
    method = excluded.method,
    recorded_by = excluded.recorded_by,
    daily_log_id = excluded.daily_log_id,
    timestamp = now();
END;
$$;


ALTER FUNCTION public.mark_student_present(p_student_id uuid, p_lesson_id uuid, p_school_id uuid, p_recorded_by uuid) OWNER TO supabase_admin;

--
-- Name: normalize_interview_ui_payload(jsonb); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.normalize_interview_ui_payload(p_ui_payload jsonb) RETURNS jsonb
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_choice      jsonb;
  v_flat_item   jsonb;
  v_out_choices jsonb := '[]'::jsonb;
  v_no_offers   jsonb := '[]'::jsonb;
  v_day_name    text;
  v_day_num     int;
  v_rank        int;
  v_window_id   text;
BEGIN
  -- Helper day mapper
  -- Montag..Freitag  1..5
  -- Accept English fallback too, just in case.
  -- Returns NULL if unknown.
  CREATE TEMP TABLE IF NOT EXISTS _day_map(day_name text PRIMARY KEY, day_num int) ON COMMIT DROP;
  IF NOT EXISTS (SELECT 1 FROM _day_map) THEN
    INSERT INTO _day_map(day_name, day_num) VALUES
      ('Montag',1),('Dienstag',2),('Mittwoch',3),('Donnerstag',4),('Freitag',5),
      ('Monday',1),('Tuesday',2),('Wednesday',3),('Thursday',4),('Friday',5);
  END IF;

  -- If already normalized, just passthrough
  IF (p_ui_payload ? 'choices') OR (p_ui_payload ? 'no_offers') THEN
    RETURN jsonb_build_object(
      'choices', COALESCE(p_ui_payload->'choices','[]'::jsonb),
      'no_offers', COALESCE(p_ui_payload->'no_offers','[]'::jsonb)
    );
  END IF;

  -- Accept wrapper objects like { course_choices: [...] }
  IF (p_ui_payload ? 'course_choices') THEN
    FOR v_choice IN
      SELECT c FROM jsonb_array_elements(COALESCE(p_ui_payload->'course_choices','[]'::jsonb)) t(c)
    LOOP
      v_day_name := NULLIF(v_choice->>'day','');
      SELECT day_num INTO v_day_num FROM _day_map WHERE lower(day_name)=lower(v_day_name);
      v_rank := NULLIF(v_choice->>'rank','')::int;
      v_window_id := NULLIF(v_choice->>'window_id','');

      IF (COALESCE(v_choice->>'no_offer','false'))::boolean OR v_rank = 0 OR v_window_id IS NULL THEN
        IF v_day_num BETWEEN 1 AND 5 THEN
          v_no_offers := (SELECT jsonb_agg(DISTINCT x) FROM jsonb_array_elements(v_no_offers || to_jsonb(v_day_num)) x);
        END IF;
      ELSE
        IF v_day_num BETWEEN 1 AND 5 THEN
          v_out_choices := v_out_choices || jsonb_build_object(
            'day_of_week', v_day_num,
            'rank', v_rank,
            'window_id', v_window_id
          );
        END IF;
      END IF;
    END LOOP;

    RETURN jsonb_build_object('choices', v_out_choices, 'no_offers', v_no_offers);
  END IF;

  -- Accept event shape: { flat: [...], noOfferDays: [...] }
  IF (p_ui_payload ? 'flat') OR (p_ui_payload ? 'noOfferDays') THEN
    -- noOfferDays first
    IF (p_ui_payload ? 'noOfferDays') THEN
      FOR v_day_name IN SELECT elem::text FROM jsonb_array_elements_text(COALESCE(p_ui_payload->'noOfferDays','[]'::jsonb)) t(elem)
      LOOP
        SELECT day_num INTO v_day_num FROM _day_map WHERE lower(day_name)=lower(v_day_name);
        IF v_day_num BETWEEN 1 AND 5 THEN
          v_no_offers := (SELECT jsonb_agg(DISTINCT x) FROM jsonb_array_elements(v_no_offers || to_jsonb(v_day_num)) x);
        END IF;
      END LOOP;
    END IF;

    -- flat rows
    FOR v_flat_item IN
      SELECT c FROM jsonb_array_elements(COALESCE(p_ui_payload->'flat','[]'::jsonb)) t(c)
    LOOP
      v_day_name := NULLIF(v_flat_item->>'day','');
      SELECT day_num INTO v_day_num FROM _day_map WHERE lower(day_name)=lower(v_day_name);
      v_rank := NULLIF(v_flat_item->>'rank','')::int;
      v_window_id := NULLIF(v_flat_item->>'window_id','');

      IF (COALESCE(v_flat_item->>'no_offer','false'))::boolean OR v_rank = 0 OR v_window_id IS NULL THEN
        IF v_day_num BETWEEN 1 AND 5 THEN
          v_no_offers := (SELECT jsonb_agg(DISTINCT x) FROM jsonb_array_elements(v_no_offers || to_jsonb(v_day_num)) x);
        END IF;
      ELSE
        IF v_day_num BETWEEN 1 AND 5 THEN
          v_out_choices := v_out_choices || jsonb_build_object(
            'day_of_week', v_day_num,
            'rank', v_rank,
            'window_id', v_window_id
          );
        END IF;
      END IF;
    END LOOP;

    RETURN jsonb_build_object('choices', v_out_choices, 'no_offers', v_no_offers);
  END IF;

  -- Fallback: empty
  RETURN jsonb_build_object('choices','[]'::jsonb,'no_offers','[]'::jsonb);
END;
$$;


ALTER FUNCTION public.normalize_interview_ui_payload(p_ui_payload jsonb) OWNER TO supabase_admin;

--
-- Name: FUNCTION normalize_interview_ui_payload(p_ui_payload jsonb); Type: COMMENT; Schema: public; Owner: supabase_admin
--

COMMENT ON FUNCTION public.normalize_interview_ui_payload(p_ui_payload jsonb) IS 'Normalize UI payloads ({course_choices:[]}, {flat:[], noOfferDays:[]}) into {choices:[], no_offers:[]}.';


--
-- Name: process_first_login(character varying, uuid); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.process_first_login(input_code character varying, p_profile_id uuid) RETURNS json
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    code_updated INTEGER := 0;
    status_updated INTEGER := 0;
BEGIN
    -- Step 1: Mark the code as used
    UPDATE user_codes
    SET used_at = NOW()
    WHERE code = input_code
    AND profile_id = p_profile_id
    AND used_at IS NULL
    AND revoked_at IS NULL
    AND expires_at > NOW();

    GET DIAGNOSTICS code_updated = ROW_COUNT;

    IF code_updated = 0 THEN
        RAISE EXCEPTION 'Failed to mark code as used';
    END IF;

    -- Step 2: Update user profile status to active
    UPDATE user_profiles
    SET account_status = 'active'
    WHERE id = p_profile_id;

    GET DIAGNOSTICS status_updated = ROW_COUNT;

    IF status_updated = 0 THEN
        RAISE EXCEPTION 'Failed to update user profile status';
    END IF;

    -- If we get here, everything succeeded
    RETURN json_build_object(
        'success', true,
        'error', null,
        'profile_id', p_profile_id,
        'message', 'Database operations completed successfully'
    );

EXCEPTION
    WHEN OTHERS THEN
        -- The transaction will automatically rollback all changes
        RETURN json_build_object(
            'success', false,
            'error', SQLERRM,
            'profile_id', null
        );
END;
$$;


ALTER FUNCTION public.process_first_login(input_code character varying, p_profile_id uuid) OWNER TO supabase_admin;

--
-- Name: process_parent_student_first_login(character varying, uuid, uuid); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.process_parent_student_first_login(input_code character varying, p_child_profile_id uuid, p_adult_profile_id uuid) RETURNS json
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    code_updated INTEGER := 0;
    status_updated INTEGER := 0;
    child_profile_id UUID;
    family_id UUID;
BEGIN
    -- Step 1: Verify the code is linked to the child profile and check parent-student relationship
    SELECT uc.profile_id, fmcl.family_id
    INTO child_profile_id, family_id
    FROM user_codes uc
    JOIN user_profiles up ON uc.profile_id = up.id
    JOIN user_roles ur ON up.id = ur.user_profile_id
    JOIN roles r ON ur.role_id = r.id AND r.name = 'Student' AND r.is_subrole = false
    JOIN family_member_child_links fmcl ON fmcl.child_profile_id = uc.profile_id
    JOIN user_profiles adult_up ON fmcl.adult_profile_id = adult_up.id
    JOIN user_roles adult_ur ON adult_up.id = adult_ur.user_profile_id
    JOIN roles adult_r ON adult_ur.role_id = adult_r.id AND adult_r.name = 'Parent' AND adult_r.is_subrole = false
    WHERE uc.code = input_code
    AND uc.profile_id = p_child_profile_id
    AND fmcl.adult_profile_id = p_adult_profile_id
    AND uc.used_at IS NULL
    AND uc.revoked_at IS NULL
    AND uc.expires_at > NOW()
    AND up.account_status NOT IN ('deleted', 'suspended')
    AND adult_up.account_status NOT IN ('deleted', 'suspended');

    IF child_profile_id IS NULL THEN
        RAISE EXCEPTION 'Code not found, expired, revoked, already used, or not linked to the specified child profile';
    END IF;

    -- Step 2: Verify that the family_id was found (relationship already verified in Step 1)
    IF family_id IS NULL THEN
        RAISE EXCEPTION 'Family relationship not found between adult and child profiles';
    END IF;

    -- Step 3: Mark the code as used
    UPDATE user_codes
    SET used_at = NOW()
    WHERE code = input_code
    AND profile_id = p_child_profile_id
    AND used_at IS NULL
    AND revoked_at IS NULL
    AND expires_at > NOW();

    GET DIAGNOSTICS code_updated = ROW_COUNT;

    IF code_updated = 0 THEN
        RAISE EXCEPTION 'Failed to mark code as used';
    END IF;

    -- Step 4: Update adult profile status to active
    UPDATE user_profiles
    SET account_status = 'active'
    WHERE id = p_adult_profile_id;

    GET DIAGNOSTICS status_updated = ROW_COUNT;

    IF status_updated = 0 THEN
        RAISE EXCEPTION 'Failed to update adult profile status';
    END IF;

    -- If we get here, everything succeeded
    RETURN json_build_object(
        'success', true,
        'error', null,
        'adult_profile_id', p_adult_profile_id,
        'child_profile_id', p_child_profile_id,
        'family_id', family_id,
        'message', 'Parent first login processed successfully'
    );

EXCEPTION
    WHEN OTHERS THEN
        -- The transaction will automatically rollback all changes
        RETURN json_build_object(
            'success', false,
            'error', SQLERRM,
            'adult_profile_id', null,
            'child_profile_id', null,
            'family_id', null
        );
END;
$$;


ALTER FUNCTION public.process_parent_student_first_login(input_code character varying, p_child_profile_id uuid, p_adult_profile_id uuid) OWNER TO supabase_admin;

--
-- Name: protect_role_deletion(); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.protect_role_deletion() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    v_protection_level text;
    v_protection_reason text;
    v_usage_count integer;
    v_role_name text;
    v_is_subrole boolean;
    v_current_user_id uuid;
    v_current_user_role text;
    v_can_unprotect boolean;
BEGIN
    -- Get current user context
    v_current_user_id := auth.uid()::uuid;
    
    -- Get current user's primary role
    SELECT r.name INTO v_current_user_role
    FROM user_profiles up
    JOIN roles r ON up.role_id = r.id
    WHERE up.id = v_current_user_id;

    -- Get role details
    SELECT name, is_subrole INTO v_role_name, v_is_subrole
    FROM roles WHERE id = OLD.id;

    -- Check if role is in protected list
    SELECT protection_level, protection_reason, can_be_unprotected 
    INTO v_protection_level, v_protection_reason, v_can_unprotect
    FROM protected_roles 
    WHERE role_id = OLD.id;

    -- Check usage count
    SELECT total_usage INTO v_usage_count
    FROM get_role_usage_count(OLD.id);

    -- PROTECTION CHECK 1: Critical system roles cannot be deleted
    IF v_protection_level = 'CRITICAL' THEN
        IF v_can_unprotect = false OR v_current_user_role != 'Admin' THEN
            RAISE EXCEPTION 'ROLE_DELETE_BLOCKED: Critical system role "%" cannot be deleted. Reason: %', 
                v_role_name, v_protection_reason
                USING ERRCODE = 'P0001';
        END IF;
    END IF;

    -- PROTECTION CHECK 2: Roles in use cannot be deleted
    IF v_usage_count > 0 THEN
        RAISE EXCEPTION 'ROLE_DELETE_BLOCKED: Role "%" is currently assigned to % users and cannot be deleted. Remove all assignments first.', 
            v_role_name, v_usage_count
            USING ERRCODE = 'P0002';
    END IF;

    -- PROTECTION CHECK 3: Only admins can delete important roles
    IF v_protection_level = 'IMPORTANT' AND v_current_user_role != 'Admin' THEN
        RAISE EXCEPTION 'ROLE_DELETE_BLOCKED: Important role "%" can only be deleted by Admin users. Current user role: %', 
            v_role_name, COALESCE(v_current_user_role, 'Unknown')
            USING ERRCODE = 'P0003';
    END IF;

    -- PROTECTION CHECK 4: Main roles require special permission
    IF v_is_subrole = false AND v_current_user_role != 'Admin' THEN
        RAISE EXCEPTION 'ROLE_DELETE_BLOCKED: Main role "%" can only be deleted by Admin users.', 
            v_role_name
            USING ERRCODE = 'P0004';
    END IF;

    -- Log the successful deletion attempt
    INSERT INTO change_log (
        table_name, 
        operation_type, 
        record_id, 
        old_values, 
        user_id,
        details
    ) VALUES (
        'roles',
        'DELETE',
        OLD.id,
        jsonb_build_object(
            'name', OLD.name,
            'is_subrole', OLD.is_subrole,
            'permissions', OLD.permissions
        ),
        v_current_user_id,
        jsonb_build_object(
            'protection_level', v_protection_level,
            'usage_count', v_usage_count,
            'user_role', v_current_user_role,
            'warning', 'ROLE DELETION APPROVED - All protection checks passed'
        )
    );

    -- If all checks pass, allow the deletion
    RETURN OLD;
    
EXCEPTION
    WHEN OTHERS THEN
        -- Log the blocked deletion attempt
        INSERT INTO change_log (
            table_name, 
            operation_type, 
            record_id, 
            old_values, 
            user_id,
            details
        ) VALUES (
            'roles',
            'DELETE_BLOCKED',
            OLD.id,
            jsonb_build_object(
                'name', OLD.name,
                'is_subrole', OLD.is_subrole,
                'permissions', OLD.permissions
            ),
            v_current_user_id,
            jsonb_build_object(
                'error_code', SQLSTATE,
                'error_message', SQLERRM,
                'protection_level', v_protection_level,
                'usage_count', v_usage_count,
                'user_role', v_current_user_role
            )
        );
        
        -- Re-raise the exception
        RAISE;
END;
$$;


ALTER FUNCTION public.protect_role_deletion() OWNER TO supabase_admin;

--
-- Name: protect_role_modification(); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.protect_role_modification() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    v_protection_level text;
    v_current_user_id uuid;
    v_current_user_role text;
BEGIN
    v_current_user_id := auth.uid()::uuid;
    
    -- Get current user's primary role
    SELECT r.name INTO v_current_user_role
    FROM user_profiles up
    JOIN roles r ON up.role_id = r.id
    WHERE up.id = v_current_user_id;

    -- Check if role is protected
    SELECT protection_level INTO v_protection_level
    FROM protected_roles 
    WHERE role_id = NEW.id;

    -- Prevent modification of critical roles without admin permission
    IF v_protection_level = 'CRITICAL' AND v_current_user_role != 'Admin' THEN
        RAISE EXCEPTION 'ROLE_MODIFY_BLOCKED: Critical system role "%" cannot be modified. Admin permission required.', 
            OLD.name
            USING ERRCODE = 'P0005';
    END IF;

    -- Prevent changing role names for protected roles
    IF v_protection_level IN ('CRITICAL', 'IMPORTANT') AND OLD.name != NEW.name THEN
        IF v_current_user_role != 'Admin' THEN
            RAISE EXCEPTION 'ROLE_MODIFY_BLOCKED: Protected role name "%" cannot be changed. Admin permission required.', 
                OLD.name
                USING ERRCODE = 'P0006';
        END IF;
    END IF;

    -- Log the modification
    INSERT INTO change_log (
        table_name, 
        operation_type, 
        record_id, 
        old_values, 
        new_values,
        user_id
    ) VALUES (
        'roles',
        'UPDATE',
        NEW.id,
        jsonb_build_object(
            'name', OLD.name,
            'permissions', OLD.permissions,
            'is_subrole', OLD.is_subrole
        ),
        jsonb_build_object(
            'name', NEW.name,
            'permissions', NEW.permissions,
            'is_subrole', NEW.is_subrole
        ),
        v_current_user_id
    );

    RETURN NEW;
END;
$$;


ALTER FUNCTION public.protect_role_modification() OWNER TO supabase_admin;

--
-- Name: publish_all_pending_substitutions(uuid, date, uuid, jsonb); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.publish_all_pending_substitutions(p_school_id uuid, p_date date, p_user_id uuid DEFAULT NULL::uuid, p_notes jsonb DEFAULT NULL::jsonb) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_lesson RECORD;
  v_note text;
BEGIN
  -- Loop through all lessons with pending substitutions for the school and date
  FOR v_lesson IN
    SELECT cl.id AS lesson_id
    FROM course_lessons cl
    JOIN substitutions s ON s.original_lesson_id = cl.id
    WHERE cl.school_id = p_school_id
      AND cl.start_datetime::date = p_date
      AND s.status <> 'confirmed'
    GROUP BY cl.id
  LOOP
    -- For each lesson, try to find the note in p_notes (flat array of objects)
    IF p_notes IS NOT NULL THEN
      SELECT value->>'note'
      INTO v_note
      FROM jsonb_array_elements(p_notes) value
      WHERE value->>'lesson_id' = v_lesson.lesson_id::text
      LIMIT 1;
    ELSE
      v_note := NULL;
    END IF;

    -- For each lesson, finalize its substitutions with the found note
    PERFORM finalize_lesson_substitutions(
      v_lesson.lesson_id,
      p_user_id,
      v_note
    );
  END LOOP;
END;
$$;


ALTER FUNCTION public.publish_all_pending_substitutions(p_school_id uuid, p_date date, p_user_id uuid, p_notes jsonb) OWNER TO supabase_admin;

--
-- Name: publish_schedule_draft_v2(uuid, uuid, uuid); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.publish_schedule_draft_v2(_draft_id uuid, _school_id uuid, _published_by uuid DEFAULT NULL::uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$DECLARE
    -- Published draft tracking
    v_draft_title text;
    v_draft_notes text;
    v_semester_id uuid;
    
    -- Original function variables
    draft_data jsonb;
    schedule jsonb;
    schedule_index integer := 0;
    total_schedules integer;
    staff_ids uuid[];
    v_course_id uuid;
    v_period_id uuid;
    v_day_id integer;
    raw_day_id integer;
    v_room_id uuid;
    v_start_time time;
    v_end_time time;
    start_block int;
    period_count integer := 1;
    start_date date := current_date;
    end_date date := current_date + interval '6 months';
    lesson_count integer;
    existing_schedule_id uuid;
    v_class_id uuid;
    v_subject_id uuid;
    v_meeting_name text;
    v_notes text;
    is_termin boolean;
    termin_subject_uuid uuid;
    v_primary_teacher_id uuid;
    
    -- Audit variables (declared but optional)
    v_schedule_count integer := 0;
    v_lesson_count integer := 0;
    v_error_msg text;
    expected_schedule record;
    expected_schedules_count integer;
    actual_schedules_count integer;
    expected_lessons_count integer;
    actual_lessons_count integer;
    
    -- Attendance transfer variables
    v_attendance_transfer_count integer := 0;
    v_old_lesson_id uuid;
    v_new_lesson_id uuid;
    attendance_record RECORD;

    -- Performance helpers
    v_rows_deleted integer := 0;
BEGIN
    -- Session-local timeouts for this run
    PERFORM set_config('statement_timeout', '0', true);
    PERFORM set_config('lock_timeout', '5s', true);

    -- Input validation
    IF _draft_id IS NULL OR _school_id IS NULL THEN
        RAISE EXCEPTION 'Draft ID and School ID are required';
    END IF;
    
    -- Check if draft exists and get metadata
    SELECT sd.title, sd.notes, sd.semester_id, sd.current_version
    INTO v_draft_title, v_draft_notes, v_semester_id, draft_data
    FROM public.schedule_drafts sd
    WHERE sd.id = _draft_id AND sd.school_id = _school_id;
    
    IF NOT FOUND THEN
        RAISE EXCEPTION 'Schedule draft not found: %', _draft_id;
    END IF;
    
    IF draft_data IS NULL THEN
        RAISE EXCEPTION 'Draft has no current version data';
    END IF;

    INSERT INTO debug_logs (step, message) VALUES 
        ('publish_start', 
         format('Starting publish of draft %s (%s) by user %s', 
                _draft_id, v_draft_title, coalesce(_published_by::text, 'system')));

    -- Find the UUID for the 'Termin' subject (case insensitive)
    SELECT id INTO termin_subject_uuid FROM subjects WHERE lower(name) = 'termin' LIMIT 1;

    -- Create temporary table to track new schedule keys
    CREATE TEMP TABLE temp_draft_keys (
        course_id uuid,
        subject_id uuid,
        class_id uuid,
        period_id uuid,
        day_id integer
    ) ON COMMIT DROP;

    -- Helpful temp indexes for NOT EXISTS checks
    CREATE INDEX ON temp_draft_keys (course_id, period_id, day_id);
    CREATE INDEX ON temp_draft_keys (subject_id, class_id, period_id, day_id);
        
    CREATE TEMP TABLE temp_lessons_to_transfer (
        old_lesson_id uuid,
        lesson_date date,
        class_id uuid,
        period_id uuid,
        day_id int,
        start_time time,
        end_time time,
        new_lesson_id uuid DEFAULT NULL
    ) ON COMMIT DROP;

    total_schedules := jsonb_array_length(draft_data);
    
    INSERT INTO debug_logs (step, message) VALUES 
        ('draft_processing', format('Processing %s schedule entries', total_schedules));

    -- PHASE 1: Process all schedule entries and create/update schedules
    WHILE schedule_index < total_schedules LOOP
        schedule := draft_data -> schedule_index;
        
        -- Reset variables for each iteration
        v_course_id := NULL;
        v_class_id := NULL;
        v_subject_id := NULL;
        v_meeting_name := NULL;
        v_notes := NULL;
        is_termin := false;
        
        -- Parse schedule entry
        IF schedule ? 'course_id' AND (schedule ->> 'course_id') IS NOT NULL THEN
            v_course_id := (schedule ->> 'course_id')::uuid;
            v_class_id := NULL;
            v_subject_id := NULL;
            is_termin := false;
        ELSE
            v_course_id := NULL;
            IF lower(schedule ->> 'subject_id') = 'termin' THEN
                is_termin := true;
                v_subject_id := termin_subject_uuid;
                v_class_id := NULL;
            ELSE
                is_termin := false;
                v_subject_id := NULLIF(schedule ->> 'subject_id', '')::uuid;
                v_class_id := NULLIF(schedule ->> 'class_id', '')::uuid;
            END IF;
        END IF;
        
        v_period_id := NULLIF(schedule ->> 'period_id', '')::uuid;
        raw_day_id := (schedule ->> 'day_id')::int;
        v_day_id := (raw_day_id + 6) % 7;

        IF jsonb_typeof(schedule -> 'room_id') = 'object' THEN
            v_room_id := (schedule -> 'room_id' ->> 'id')::uuid;
        ELSE
            v_room_id := NULLIF(schedule ->> 'room_id', '')::uuid;
        END IF;

        SELECT array_agg(value::uuid)
        INTO staff_ids
        FROM jsonb_array_elements_text(schedule -> 'staff_ids');
        staff_ids := coalesce(staff_ids, ARRAY[]::uuid[]);

        v_meeting_name := schedule ->> 'meeting_name';
        v_notes := schedule ->> 'notes';

        INSERT INTO debug_logs (message, step)
        VALUES (
            format(
                'Processing entry %s: course_id=%s, subject_id=%s, class_id=%s, period_id=%s, day_id=%s, is_termin=%s, meeting_name=%s',
                schedule_index,
                coalesce(v_course_id::text, 'NULL'),
                coalesce(v_subject_id::text, 'NULL'),
                coalesce(v_class_id::text, 'NULL'),
                coalesce(v_period_id::text, 'NULL'),
                raw_day_id,
                is_termin::text,
                coalesce(v_meeting_name, '')
            ),
            'entry_parse'
        );

        -- Skip if no teachers assigned
        IF array_length(staff_ids, 1) IS NULL OR array_length(staff_ids, 1) = 0 THEN
            INSERT INTO debug_logs (message, step)
            VALUES (
                format(
                    ' Skipping schedule: course %s, period %s, day %s  no teachers assigned',
                    coalesce(v_course_id::text, 'NULL'),
                    coalesce(v_period_id::text, 'NULL'),
                    raw_day_id
                ),
                'no_teachers'
            );
            schedule_index := schedule_index + 1;
            CONTINUE;
        END IF;

        -- Get period details
        SELECT sp.block_number, sp.start_time, sp.end_time
        INTO start_block, v_start_time, v_end_time
        FROM public.schedule_periods sp
        WHERE sp.id = v_period_id;

        -- Track this schedule for cleanup purposes
        INSERT INTO temp_draft_keys (course_id, subject_id, class_id, period_id, day_id)
        VALUES (v_course_id, v_subject_id, v_class_id, v_period_id, raw_day_id);

        -- Check for existing schedule
        SELECT cs.id INTO existing_schedule_id
        FROM public.course_schedules cs
        WHERE cs.school_id = _school_id
          AND cs.period_id = v_period_id
          AND cs.day_id = raw_day_id
          AND (
            (v_course_id IS NOT NULL AND cs.course_id = v_course_id)
            OR
            (v_course_id IS NULL AND cs.course_id IS NULL AND cs.subject_id = v_subject_id AND cs.class_id IS NOT DISTINCT FROM v_class_id)
          )
        LIMIT 1;

        INSERT INTO debug_logs (message, step)
        VALUES (
            format('Matching schedule_id for entry %s: %s', schedule_index, coalesce(existing_schedule_id::text, 'NONE')),
            'match_check'
        );

        IF existing_schedule_id IS NOT NULL THEN
            -- Update existing schedule and unarchive if it was archived
            UPDATE public.course_schedules cs
            SET teacher_ids = staff_ids,
                room_id = v_room_id,
                start_time = v_start_time,
                end_time = v_end_time,
                meeting_name = CASE WHEN is_termin THEN v_meeting_name ELSE NULL END,
                notes = CASE WHEN is_termin THEN v_notes ELSE NULL END,
                is_archived = false
            WHERE cs.id = existing_schedule_id;

            -- Update and unarchive future lessons for the schedule
            UPDATE public.course_lessons cl
            SET teacher_ids = staff_ids,
                room_id = v_room_id,
                meeting_name = CASE WHEN is_termin THEN v_meeting_name ELSE NULL END,
                notes = CASE WHEN is_termin THEN v_notes ELSE NULL END,
                is_archived = false
            WHERE cl.schedule_id = existing_schedule_id
              AND cl.start_datetime >= current_date;

            INSERT INTO debug_logs (message, step)
            VALUES (
                format(' Updated and unarchived schedule %s and its future lessons', coalesce(existing_schedule_id::text, 'NULL')),
                'update'
            );

        ELSE
            -- Create new schedule
            IF v_course_id IS NOT NULL THEN
                PERFORM * FROM public.create_schedule_and_generate_lessons(
                    v_course_id,
                    raw_day_id,
                    start_date,
                    end_date,
                    v_start_time,
                    v_end_time,
                    staff_ids,
                    v_room_id,
                    _school_id,
                    v_period_id,
                    period_count
                );
                GET DIAGNOSTICS lesson_count = ROW_COUNT;

                INSERT INTO debug_logs (message, step)
                VALUES (
                    format(' Created %s lessons for new course schedule: course %s, period %s, day %s', 
                           lesson_count, coalesce(v_course_id::text, 'NULL'), coalesce(v_period_id::text, 'NULL'), raw_day_id),
                    'insert_course'
                );

            ELSE
                -- Insert school lesson schedule (explicitly unarchived)
                INSERT INTO public.course_schedules (
                    course_id, subject_id, class_id, day_id, start_date, end_date,
                    start_time, end_time, teacher_ids, room_id, school_id, period_id,
                    meeting_name, notes, is_archived
                )
                VALUES (
                    NULL, v_subject_id, v_class_id, raw_day_id, start_date, end_date,
                    v_start_time, v_end_time, staff_ids, v_room_id, _school_id, v_period_id,
                    CASE WHEN is_termin THEN v_meeting_name ELSE NULL END,
                    CASE WHEN is_termin THEN v_notes ELSE NULL END,
                    false
                )
                RETURNING id INTO existing_schedule_id;

                -- Generate lessons for school lesson
                INSERT INTO public.course_lessons (
                    schedule_id, start_datetime, end_datetime, teacher_ids, room_id,
                    meeting_name, notes, school_id, subject_id, class_id
                )
                SELECT 
                    existing_schedule_id,
                    date_trunc('day', d) + v_start_time,
                    date_trunc('day', d) + v_end_time,
                    staff_ids,
                    v_room_id,
                    CASE WHEN is_termin THEN v_meeting_name ELSE NULL END,
                    CASE WHEN is_termin THEN v_notes ELSE NULL END,
                    _school_id,
                    v_subject_id,
                    v_class_id
                FROM generate_series(start_date, end_date, '1 day'::interval) AS d
                WHERE extract(dow from d) = v_day_id;

                GET DIAGNOSTICS lesson_count = ROW_COUNT;

                INSERT INTO debug_logs (message, step)
                VALUES (
                    format(' Created %s lessons for new school schedule: subject %s, class %s, period %s, day %s', 
                           lesson_count, coalesce(v_subject_id::text, 'NULL'), coalesce(v_class_id::text, 'NULL'), 
                           coalesce(v_period_id::text, 'NULL'), raw_day_id),
                    'insert_school'
                );
            END IF;
        END IF;

        schedule_index := schedule_index + 1;
    END LOOP;

    INSERT INTO debug_logs (message, step)
    VALUES ('Completed creating/updating schedules and lessons', 'schedules_complete');

    -- PHASE 2: Identify lessons that need attendance transfer
    INSERT INTO debug_logs (step, message) VALUES 
        ('attendance_transfer_start', 'Starting attendance transfer analysis');

    -- Find lessons with attendance that will be deleted
    INSERT INTO temp_lessons_to_transfer (old_lesson_id, lesson_date, class_id, period_id, day_id, start_time, end_time)
    SELECT DISTINCT cl.id, cl.start_datetime::date, cs.class_id, cs.period_id, cs.day_id, cl.start_datetime::time, cl.end_datetime::time
    FROM public.course_lessons cl
    JOIN public.course_schedules cs ON cs.id = cl.schedule_id
    WHERE cs.school_id = _school_id
      AND cl.start_datetime >= current_date
      AND EXISTS (
        SELECT 1 FROM student_attendance_logs sal
        WHERE sal.lesson_id = cl.id
      )
      AND NOT EXISTS (
        SELECT 1 FROM temp_draft_keys dk
        WHERE
          (
            dk.course_id IS NOT NULL
            AND cs.course_id = dk.course_id
            AND cs.period_id = dk.period_id
            AND cs.day_id = dk.day_id
          )
          OR
          (
            dk.course_id IS NULL
            AND cs.course_id IS NULL
            AND cs.subject_id = dk.subject_id
            AND cs.class_id IS NOT DISTINCT FROM dk.class_id
            AND cs.period_id = dk.period_id
            AND cs.day_id = dk.day_id
          )
      );

    -- Attempt to find the new lesson for each old lesson
    UPDATE temp_lessons_to_transfer tlt
    SET new_lesson_id = l_new.id
    FROM public.course_lessons l_new
    JOIN public.course_schedules s_new ON l_new.schedule_id = s_new.id
    WHERE
        l_new.start_datetime::date = tlt.lesson_date
        AND l_new.start_datetime::time = tlt.start_time
        AND (l_new.end_datetime::time = tlt.end_time)
        AND s_new.class_id IS NOT DISTINCT FROM tlt.class_id
        AND s_new.period_id IS NOT DISTINCT FROM tlt.period_id
        AND s_new.day_id = tlt.day_id;

    UPDATE public.course_lessons old
    SET replaced_by_lesson_id = tlt.new_lesson_id
    FROM temp_lessons_to_transfer tlt
    WHERE old.id = tlt.old_lesson_id AND tlt.new_lesson_id IS NOT NULL;
    
    UPDATE public.course_lessons new
    SET replaces_lesson_id = tlt.old_lesson_id
    FROM temp_lessons_to_transfer tlt
    WHERE new.id = tlt.new_lesson_id AND tlt.old_lesson_id IS NOT NULL;

    -- Transfer attendance records to new lessons
    UPDATE student_attendance_logs sal
    SET lesson_id = tlt.new_lesson_id
    FROM temp_lessons_to_transfer tlt
    WHERE sal.lesson_id = tlt.old_lesson_id 
      AND tlt.new_lesson_id IS NOT NULL;

    GET DIAGNOSTICS v_attendance_transfer_count = ROW_COUNT;

    INSERT INTO debug_logs (step, message) VALUES 
        ('attendance_transfer_analysis', 
         format('Found %s lessons with attendance that need transfer', v_attendance_transfer_count));

    -- PHASE 5: Clean up outdated schedules and lessons
    INSERT INTO debug_logs (step, message) VALUES 
        ('cleanup_start', 'Starting cleanup of outdated schedules and lessons');

    -- Let planner know the temp table size after we populated it
    ANALYZE temp_draft_keys;

    -- Identify schedules that are NOT in the new draft
    CREATE TEMP TABLE temp_obsolete_schedules AS
    SELECT cs.id AS schedule_id
    FROM public.course_schedules cs
    WHERE cs.school_id = _school_id
      AND NOT EXISTS (
        SELECT 1 FROM temp_draft_keys dk
        WHERE
          (
            dk.course_id IS NOT NULL
            AND cs.course_id = dk.course_id
            AND cs.period_id = dk.period_id
            AND cs.day_id = dk.day_id
          )
          OR
          (
            dk.course_id IS NULL
            AND cs.course_id IS NULL
            AND cs.subject_id = dk.subject_id
            AND cs.class_id IS NOT DISTINCT FROM dk.class_id
            AND cs.period_id = dk.period_id
            AND cs.day_id = dk.day_id
          )
      );

    -- Index + analyze the temp list
    CREATE INDEX ON temp_obsolete_schedules (schedule_id);
    ANALYZE temp_obsolete_schedules;

    INSERT INTO debug_logs (step, message)
    SELECT 'cleanup_schedules_pending',
           format('Will clean schedule id=%s (not present in new draft)', schedule_id)
    FROM temp_obsolete_schedules;

    -- Delete FUTURE lessons for obsolete schedules that have no attendance, in batches
    LOOP
      WITH del AS (
        SELECT cl.id
        FROM public.course_lessons cl
        JOIN temp_obsolete_schedules tos ON cl.schedule_id = tos.schedule_id
        WHERE cl.start_datetime >= current_date
          AND NOT EXISTS (
            SELECT 1 FROM student_attendance_logs sal WHERE sal.lesson_id = cl.id
          )
        LIMIT 10000
      )
      DELETE FROM public.course_lessons cl
      USING del
      WHERE cl.id = del.id;

      GET DIAGNOSTICS v_rows_deleted = ROW_COUNT;
      EXIT WHEN v_rows_deleted = 0;
    END LOOP;

    INSERT INTO debug_logs (step, message)
    VALUES ('cleanup_lessons_deleted', 'Deleted future lessons without attendance for obsolete schedules');

    -- Log lessons we could not delete because attendance still exists
    INSERT INTO debug_logs (step, message)
    SELECT 
      'blocked_deletion_due_to_attendance',
      format('Lesson %s could not be deleted because attendance still exists', cl.id)
    FROM public.course_lessons cl
    JOIN temp_obsolete_schedules tos ON tos.schedule_id = cl.schedule_id
    WHERE cl.start_datetime >= current_date
      AND EXISTS (
        SELECT 1 FROM student_attendance_logs sal WHERE sal.lesson_id = cl.id
      );

    -- Now delete obsolete schedules that have no remaining lessons (past or future)
    DELETE FROM public.course_schedules cs
    USING temp_obsolete_schedules tos
    WHERE cs.id = tos.schedule_id
      AND NOT EXISTS (
        SELECT 1 FROM public.course_lessons cl WHERE cl.schedule_id = cs.id
      );

    INSERT INTO debug_logs (message, step)
    VALUES ('Deleted obsolete course_schedules with no remaining lessons', 'cleanup_schedules');

    -- Mark remaining obsolete schedules/lessons as archived
    UPDATE public.course_schedules cs
    SET is_archived = true
    WHERE cs.id IN (SELECT schedule_id FROM temp_obsolete_schedules)
      AND EXISTS (
        SELECT 1 FROM public.course_lessons cl WHERE cl.schedule_id = cs.id
      );

    UPDATE public.course_lessons cl
    SET is_archived = true
    WHERE cl.schedule_id IN (SELECT schedule_id FROM temp_obsolete_schedules)
      AND cl.start_datetime >= current_date
      AND EXISTS (
        SELECT 1 FROM public.student_attendance_logs sal
        WHERE sal.lesson_id = cl.id
      );

    INSERT INTO debug_logs (step, message)
    SELECT 
        'orphaned_attendance',
        format('Lesson %s still has attendance but no new lesson found', old_lesson_id)
    FROM temp_lessons_to_transfer
    WHERE new_lesson_id IS NULL;

    INSERT INTO debug_logs (message, step)
    VALUES ('Deleted/archived outdated schedules and lessons', 'cleanup_complete');

    -- PHASE 6: Finalize publication
    UPDATE public.schedule_drafts
    SET is_live = false
    WHERE school_id = _school_id;

    UPDATE public.schedule_drafts sd
    SET published_at = now(),
        updated_at = now(),
        is_live = true
    WHERE sd.id = _draft_id;

    INSERT INTO debug_logs (message, step)
    VALUES ('Draft published and marked as live', 'publish_complete');

    INSERT INTO debug_logs (step, message) VALUES 
        ('publish_success', 
         format('Successfully published draft %s with %s attendance transfers', 
                _draft_id, v_attendance_transfer_count));
   
    -- Extra safety archiving
    UPDATE public.course_schedules cs
    SET is_archived = true
    WHERE cs.school_id = _school_id
      AND NOT EXISTS (
        SELECT 1 FROM temp_draft_keys dk
        WHERE (
          dk.course_id IS NOT NULL
          AND cs.course_id = dk.course_id
          AND cs.period_id = dk.period_id
          AND cs.day_id = dk.day_id
        ) OR (
          dk.course_id IS NULL
          AND cs.course_id IS NULL
          AND cs.subject_id = dk.subject_id
          AND cs.class_id IS NOT DISTINCT FROM dk.class_id
          AND cs.period_id = dk.period_id
          AND cs.day_id = dk.day_id
        )
      )
      AND EXISTS (
        SELECT 1 FROM public.course_lessons cl
        WHERE cl.schedule_id = cs.id
      );

    UPDATE public.course_lessons cl
    SET is_archived = true
    WHERE cl.schedule_id IS NOT NULL
      AND cl.schedule_id NOT IN (
        SELECT cs.id FROM public.course_schedules cs
      )
      AND cl.start_datetime >= current_date
      AND EXISTS (
        SELECT 1 FROM public.student_attendance_logs sal
        WHERE sal.lesson_id = cl.id
      );

EXCEPTION
    WHEN OTHERS THEN
        v_error_msg := SQLERRM;
        INSERT INTO debug_logs (step, message) VALUES 
            ('publish_error', 
             format('Error publishing draft %s: %s', _draft_id, v_error_msg));
        RAISE;
END;$$;


ALTER FUNCTION public.publish_schedule_draft_v2(_draft_id uuid, _school_id uuid, _published_by uuid) OWNER TO supabase_admin;

--
-- Name: publish_schedule_draft_v2_Alt_new(uuid, uuid, uuid); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public."publish_schedule_draft_v2_Alt_new"(_draft_id uuid, _school_id uuid, _published_by uuid DEFAULT NULL::uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$DECLARE
    -- Published draft tracking
    v_draft_title text;
    v_draft_notes text;
    v_semester_id uuid;
    
    -- Original function variables
    draft_data jsonb;
    schedule jsonb;
    schedule_index integer := 0;
    total_schedules integer;
    staff_ids uuid[];
    v_course_id uuid;
    v_period_id uuid;
    v_day_id integer;
    raw_day_id integer;
    v_room_id uuid;
    v_start_time time;
    v_end_time time;
    start_block int;
    period_count integer := 1;
    start_date date := current_date;
    end_date date := current_date + interval '6 months';
    lesson_count integer;
    existing_schedule_id uuid;
    v_class_id uuid;
    v_subject_id uuid;
    v_meeting_name text;
    v_notes text;
    is_termin boolean;
    termin_subject_uuid uuid;
    v_primary_teacher_id uuid;
    
    -- Audit variables
    v_schedule_count integer := 0;
    v_lesson_count integer := 0;
    v_error_msg text;
    expected_schedule record;
    
    -- Audit comparison tables
    expected_schedules_count integer;
    actual_schedules_count integer;
    expected_lessons_count integer;
    actual_lessons_count integer;
    
    -- Attendance transfer variables
    v_attendance_transfer_count integer := 0;
    v_old_lesson_id uuid;
    v_new_lesson_id uuid;
    attendance_record RECORD;
BEGIN
    -- Input validation
    IF _draft_id IS NULL OR _school_id IS NULL THEN
        RAISE EXCEPTION 'Draft ID and School ID are required';
    END IF;
    
    -- Check if draft exists and get metadata
    SELECT sd.title, sd.notes, sd.semester_id, sd.current_version
    INTO v_draft_title, v_draft_notes, v_semester_id, draft_data
    FROM public.schedule_drafts sd
    WHERE sd.id = _draft_id AND sd.school_id = _school_id;
    
    IF NOT FOUND THEN
        RAISE EXCEPTION 'Schedule draft not found: %', _draft_id;
    END IF;
    
    IF draft_data IS NULL THEN
        RAISE EXCEPTION 'Draft has no current version data';
    END IF;

    INSERT INTO debug_logs (step, message) VALUES 
        ('publish_start', 
         format('Starting publish of draft %s (%s) by user %s', 
                _draft_id, v_draft_title, coalesce(_published_by::text, 'system')));

    -- Find the UUID for the 'Termin' subject (case insensitive)
    SELECT id INTO termin_subject_uuid FROM subjects WHERE lower(name) = 'termin' LIMIT 1;

    -- Create temporary table to track new schedule keys
    CREATE TEMP TABLE temp_draft_keys (
        course_id uuid,
        subject_id uuid,
        class_id uuid,
        period_id uuid,
        day_id integer
    ) ON COMMIT DROP;
        
    CREATE TEMP TABLE temp_lessons_to_transfer (
        old_lesson_id uuid,
        lesson_date date,
        class_id uuid,
        period_id uuid,
        day_id int,
        start_time time,
        end_time time,
        new_lesson_id uuid DEFAULT NULL
    ) ON COMMIT DROP;

    total_schedules := jsonb_array_length(draft_data);
    
    INSERT INTO debug_logs (step, message) VALUES 
        ('draft_processing', format('Processing %s schedule entries', total_schedules));

    -- PHASE 1: Process all schedule entries and create/update schedules
    WHILE schedule_index < total_schedules LOOP
        schedule := draft_data -> schedule_index;
        
        -- Reset variables for each iteration
        v_course_id := NULL;
        v_class_id := NULL;
        v_subject_id := NULL;
        v_meeting_name := NULL;
        v_notes := NULL;
        is_termin := false;
        
        -- Parse schedule entry
        IF schedule ? 'course_id' AND (schedule ->> 'course_id') IS NOT NULL THEN
            v_course_id := (schedule ->> 'course_id')::uuid;
            v_class_id := NULL;
            v_subject_id := NULL;
            is_termin := false;
        ELSE
            v_course_id := NULL;
            IF lower(schedule ->> 'subject_id') = 'termin' THEN
                is_termin := true;
                v_subject_id := termin_subject_uuid;
                v_class_id := NULL;
            ELSE
                is_termin := false;
                v_subject_id := NULLIF(schedule ->> 'subject_id', '')::uuid;
                v_class_id := NULLIF(schedule ->> 'class_id', '')::uuid;
            END IF;
        END IF;
        
        v_period_id := NULLIF(schedule ->> 'period_id', '')::uuid;
        raw_day_id := (schedule ->> 'day_id')::int;
        v_day_id := (raw_day_id + 6) % 7;

        IF jsonb_typeof(schedule -> 'room_id') = 'object' THEN
            v_room_id := (schedule -> 'room_id' ->> 'id')::uuid;
        ELSE
            v_room_id := NULLIF(schedule ->> 'room_id', '')::uuid;
        END IF;

        SELECT array_agg(value::uuid)
        INTO staff_ids
        FROM jsonb_array_elements_text(schedule -> 'staff_ids');
        staff_ids := coalesce(staff_ids, ARRAY[]::uuid[]);

        v_meeting_name := schedule ->> 'meeting_name';
        v_notes := schedule ->> 'notes';

        INSERT INTO debug_logs (message, step)
        VALUES (
            format(
                'Processing entry %s: course_id=%s, subject_id=%s, class_id=%s, period_id=%s, day_id=%s, is_termin=%s, meeting_name=%s',
                schedule_index,
                coalesce(v_course_id::text, 'NULL'),
                coalesce(v_subject_id::text, 'NULL'),
                coalesce(v_class_id::text, 'NULL'),
                coalesce(v_period_id::text, 'NULL'),
                raw_day_id,
                is_termin::text,
                coalesce(v_meeting_name, '')
            ),
            'entry_parse'
        );

        -- Skip if no teachers assigned
        IF array_length(staff_ids, 1) IS NULL OR array_length(staff_ids, 1) = 0 THEN
            INSERT INTO debug_logs (message, step)
            VALUES (
                format(
                    ' Skipping schedule: course %s, period %s, day %s  no teachers assigned',
                    coalesce(v_course_id::text, 'NULL'),
                    coalesce(v_period_id::text, 'NULL'),
                    raw_day_id
                ),
                'no_teachers'
            );
            schedule_index := schedule_index + 1;
            CONTINUE;
        END IF;

        -- Get period details
        SELECT sp.block_number, sp.start_time, sp.end_time
        INTO start_block, v_start_time, v_end_time
        FROM public.schedule_periods sp
        WHERE sp.id = v_period_id;

        -- Track this schedule for cleanup purposes
        INSERT INTO temp_draft_keys (course_id, subject_id, class_id, period_id, day_id)
        VALUES (v_course_id, v_subject_id, v_class_id, v_period_id, raw_day_id);

        -- Check for existing schedule
        SELECT cs.id INTO existing_schedule_id
        FROM public.course_schedules cs
        WHERE cs.school_id = _school_id
          AND cs.period_id = v_period_id
          AND cs.day_id = raw_day_id
          AND (
            (v_course_id IS NOT NULL AND cs.course_id = v_course_id)
            OR
            (v_course_id IS NULL AND cs.course_id IS NULL AND cs.subject_id = v_subject_id AND cs.class_id IS NOT DISTINCT FROM v_class_id)
          )
        LIMIT 1;

        INSERT INTO debug_logs (message, step)
        VALUES (
            format('Matching schedule_id for entry %s: %s', schedule_index, coalesce(existing_schedule_id::text, 'NONE')),
            'match_check'
        );

        IF existing_schedule_id IS NOT NULL THEN
            -- Update existing schedule
            UPDATE public.course_schedules cs
            SET teacher_ids = staff_ids,
                room_id = v_room_id,
                start_time = v_start_time,
                end_time = v_end_time,
                meeting_name = CASE WHEN is_termin THEN v_meeting_name ELSE NULL END,
                notes = CASE WHEN is_termin THEN v_notes ELSE NULL END
            WHERE cs.id = existing_schedule_id;

            -- Update future lessons
            UPDATE public.course_lessons cl
            SET teacher_ids = staff_ids,
                room_id = v_room_id,
                meeting_name = CASE WHEN is_termin THEN v_meeting_name ELSE NULL END,
                notes = CASE WHEN is_termin THEN v_notes ELSE NULL END
            WHERE cl.schedule_id = existing_schedule_id
              AND cl.start_datetime >= current_date;

            INSERT INTO debug_logs (message, step)
            VALUES (
                format(' Updated schedule and lessons for schedule_id %s', coalesce(existing_schedule_id::text, 'NULL')),
                'update'
            );

        ELSE
            -- Create new schedule
            IF v_course_id IS NOT NULL THEN
                PERFORM * FROM public.create_schedule_and_generate_lessons(
                    v_course_id,
                    raw_day_id,
                    start_date,
                    end_date,
                    v_start_time,
                    v_end_time,
                    staff_ids,
                    v_room_id,
                    _school_id,
                    v_period_id,
                    period_count
                );
                GET DIAGNOSTICS lesson_count = ROW_COUNT;

                INSERT INTO debug_logs (message, step)
                VALUES (
                    format(' Created %s lessons for new course schedule: course %s, period %s, day %s', 
                           lesson_count, coalesce(v_course_id::text, 'NULL'), coalesce(v_period_id::text, 'NULL'), raw_day_id),
                    'insert_course'
                );

            ELSE
                -- Insert school lesson schedule
                INSERT INTO public.course_schedules (
                    course_id, subject_id, class_id, day_id, start_date, end_date,
                    start_time, end_time, teacher_ids, room_id, school_id, period_id,
                    meeting_name, notes
                )
                VALUES (
                    NULL, v_subject_id, v_class_id, raw_day_id, start_date, end_date,
                    v_start_time, v_end_time, staff_ids, v_room_id, _school_id, v_period_id,
                    CASE WHEN is_termin THEN v_meeting_name ELSE NULL END,
                    CASE WHEN is_termin THEN v_notes ELSE NULL END
                )
                RETURNING id INTO existing_schedule_id;

                -- Generate lessons for school lesson
INSERT INTO public.course_lessons (
    schedule_id, start_datetime, end_datetime, teacher_ids, room_id,
    meeting_name, notes, school_id, subject_id, class_id
)
SELECT 
    existing_schedule_id,
    date_trunc('day', d) + v_start_time,
    date_trunc('day', d) + v_end_time,
    staff_ids,
    v_room_id,
    CASE WHEN is_termin THEN v_meeting_name ELSE NULL END,
    CASE WHEN is_termin THEN v_notes ELSE NULL END,
    _school_id,
    v_subject_id,
    v_class_id
FROM generate_series(start_date, end_date, '1 day'::interval) AS d
WHERE extract(dow from d) = v_day_id;

                GET DIAGNOSTICS lesson_count = ROW_COUNT;

                INSERT INTO debug_logs (message, step)
                VALUES (
                    format(' Created %s lessons for new school schedule: subject %s, class %s, period %s, day %s', 
                           lesson_count, coalesce(v_subject_id::text, 'NULL'), coalesce(v_class_id::text, 'NULL'), 
                           coalesce(v_period_id::text, 'NULL'), raw_day_id),
                    'insert_school'
                );
            END IF;
        END IF;

        schedule_index := schedule_index + 1;
    END LOOP;

    INSERT INTO debug_logs (message, step)
    VALUES ('Completed creating/updating schedules and lessons', 'schedules_complete');

    -- PHASE 2: Identify lessons that need attendance transfer
    INSERT INTO debug_logs (step, message) VALUES 
        ('attendance_transfer_start', 'Starting attendance transfer analysis');

    -- Find lessons with attendance that will be deleted
    INSERT INTO temp_lessons_to_transfer (old_lesson_id, lesson_date, class_id, period_id, day_id, start_time, end_time)
    SELECT DISTINCT cl.id, cl.start_datetime::date, cs.class_id, cs.period_id, cs.day_id, cl.start_datetime::time, cl.end_datetime::time
    FROM public.course_lessons cl
    JOIN public.course_schedules cs ON cs.id = cl.schedule_id
    WHERE cs.school_id = _school_id
      AND cl.start_datetime >= current_date
      AND EXISTS (
        SELECT 1 FROM student_attendance_logs sal
        WHERE sal.lesson_id = cl.id
      )
      AND NOT EXISTS (
        SELECT 1 FROM temp_draft_keys dk
        WHERE
          (
            dk.course_id IS NOT NULL
            AND cs.course_id = dk.course_id
            AND cs.period_id = dk.period_id
            AND cs.day_id = dk.day_id
          )
          OR
          (
            dk.course_id IS NULL
            AND cs.course_id IS NULL
            AND cs.subject_id = dk.subject_id
            AND cs.class_id IS NOT DISTINCT FROM dk.class_id
            AND cs.period_id = dk.period_id
            AND cs.day_id = dk.day_id
          )
      );


    -- Attempt to find the new lesson for each old lesson by matching date, class, period, and day_id
    UPDATE temp_lessons_to_transfer tlt
    SET new_lesson_id = l_new.id
    FROM public.course_lessons l_new
    JOIN public.course_schedules s_new ON l_new.schedule_id = s_new.id
    WHERE
        l_new.start_datetime::date = tlt.lesson_date
        AND l_new.start_datetime::time = tlt.start_time          -- match start time!
        AND (l_new.end_datetime::time = tlt.end_time)         -- (optional) match end time too
        AND s_new.class_id IS NOT DISTINCT FROM tlt.class_id
        AND s_new.period_id IS NOT DISTINCT FROM tlt.period_id
        AND s_new.day_id = tlt.day_id;


    UPDATE public.course_lessons old
    SET replaced_by_lesson_id = tlt.new_lesson_id
    FROM temp_lessons_to_transfer tlt
    WHERE old.id = tlt.old_lesson_id AND tlt.new_lesson_id IS NOT NULL;
    
    UPDATE public.course_lessons new
    SET replaces_lesson_id = tlt.old_lesson_id
    FROM temp_lessons_to_transfer tlt
    WHERE new.id = tlt.new_lesson_id AND tlt.old_lesson_id IS NOT NULL;

    -- Transfer attendance records to new lessons
    UPDATE student_attendance_logs sal
    SET lesson_id = tlt.new_lesson_id
    FROM temp_lessons_to_transfer tlt
    WHERE sal.lesson_id = tlt.old_lesson_id 
      AND tlt.new_lesson_id IS NOT NULL;

    GET DIAGNOSTICS v_attendance_transfer_count = ROW_COUNT;

    INSERT INTO debug_logs (step, message) VALUES 
        ('attendance_transfer_analysis', 
         format('Found %s lessons with attendance that need transfer', v_attendance_transfer_count));

    -- PHASE 5: Clean up outdated schedules and lessons
    INSERT INTO debug_logs (step, message) VALUES 
        ('cleanup_start', 'Starting cleanup of outdated schedules and lessons');

    -- Identify schedules that are NOT in the new draft
    CREATE TEMP TABLE temp_obsolete_schedules AS
    SELECT cs.id AS schedule_id
    FROM public.course_schedules cs
    WHERE cs.school_id = _school_id
      AND NOT EXISTS (
        SELECT 1 FROM temp_draft_keys dk
        WHERE
          (
            dk.course_id IS NOT NULL
            AND cs.course_id = dk.course_id
            AND cs.period_id = dk.period_id
            AND cs.day_id = dk.day_id
          )
          OR
          (
            dk.course_id IS NULL
            AND cs.course_id IS NULL
            AND cs.subject_id = dk.subject_id
            AND cs.class_id IS NOT DISTINCT FROM dk.class_id
            AND cs.period_id = dk.period_id
            AND cs.day_id = dk.day_id
          )
      );

    INSERT INTO debug_logs (step, message)
    SELECT 'cleanup_schedules_pending',
           format('Will clean schedule id=%s (not present in new draft)', schedule_id)
    FROM temp_obsolete_schedules;

    -- First delete FUTURE lessons for obsolete schedules that have no attendance
    DELETE FROM public.course_lessons cl
    USING temp_obsolete_schedules tos
    WHERE cl.schedule_id = tos.schedule_id
      AND cl.start_datetime >= current_date
      AND NOT EXISTS (
        SELECT 1 FROM student_attendance_logs sal WHERE sal.lesson_id = cl.id
      );

    INSERT INTO debug_logs (step, message)
    VALUES ('cleanup_lessons_deleted', 'Deleted future lessons without attendance for obsolete schedules');

    -- Log lessons we could not delete because attendance still exists and no new lesson was found
    INSERT INTO debug_logs (step, message)
    SELECT 
      'blocked_deletion_due_to_attendance',
      format('Lesson %s could not be deleted because attendance still exists', cl.id)
    FROM public.course_lessons cl
    JOIN temp_obsolete_schedules tos ON tos.schedule_id = cl.schedule_id
    WHERE cl.start_datetime >= current_date
      AND EXISTS (
        SELECT 1 FROM student_attendance_logs sal WHERE sal.lesson_id = cl.id
      );

    -- Now delete obsolete schedules that have no remaining lessons (past or future)
    DELETE FROM public.course_schedules cs
    USING temp_obsolete_schedules tos
    WHERE cs.id = tos.schedule_id
      AND NOT EXISTS (
        SELECT 1 FROM public.course_lessons cl WHERE cl.schedule_id = cs.id
      );

    INSERT INTO debug_logs (message, step)
    VALUES ('Deleted obsolete course_schedules with no remaining lessons', 'cleanup_schedules');

    -- Mark remaining obsolete schedules/lessons as archived (e.g., those with past lessons or future lessons holding attendance)
    UPDATE public.course_schedules cs
    SET is_archived = true
    WHERE cs.id IN (SELECT schedule_id FROM temp_obsolete_schedules)
      AND EXISTS (
        SELECT 1 FROM public.course_lessons cl WHERE cl.schedule_id = cs.id
      );

    UPDATE public.course_lessons cl
    SET is_archived = true
    WHERE cl.schedule_id IN (SELECT schedule_id FROM temp_obsolete_schedules)
      AND cl.start_datetime >= current_date
      AND EXISTS (
        SELECT 1 FROM student_attendance_logs sal WHERE sal.lesson_id = cl.id
      );

    INSERT INTO debug_logs (step, message)
    SELECT 
        'orphaned_attendance',
        format('Lesson %s still has attendance but no new lesson found', old_lesson_id)
    FROM temp_lessons_to_transfer
    WHERE new_lesson_id IS NULL;

    INSERT INTO debug_logs (message, step)
    VALUES ('Deleted/archived outdated schedules and lessons', 'cleanup_complete');

    -- PHASE 6: Finalize publication
    UPDATE public.schedule_drafts
    SET is_live = false
    WHERE school_id = _school_id;

    UPDATE public.schedule_drafts sd
    SET published_at = now(),
        updated_at = now(),
        is_live = true
    WHERE sd.id = _draft_id;

    INSERT INTO debug_logs (message, step)
    VALUES ('Draft published and marked as live', 'publish_complete');

    INSERT INTO debug_logs (step, message) VALUES 
        ('publish_success', 
         format('Successfully published draft %s with %s attendance transfers', 
                _draft_id, v_attendance_transfer_count));
   
    UPDATE public.course_schedules cs
    SET is_archived = true
    WHERE cs.school_id = _school_id
      AND NOT EXISTS (
        SELECT 1 FROM temp_draft_keys dk
        WHERE (
          dk.course_id IS NOT NULL
          AND cs.course_id = dk.course_id
          AND cs.period_id = dk.period_id
          AND cs.day_id = dk.day_id
        ) OR (
          dk.course_id IS NULL
          AND cs.course_id IS NULL
          AND cs.subject_id = dk.subject_id
          AND cs.class_id IS NOT DISTINCT FROM dk.class_id
          AND cs.period_id = dk.period_id
          AND cs.day_id = dk.day_id
        )
      )
      AND EXISTS (
        SELECT 1 FROM public.course_lessons cl
        WHERE cl.schedule_id = cs.id
      );

    UPDATE public.course_lessons cl
    SET is_archived = true
    WHERE cl.schedule_id IS NOT NULL
      AND cl.schedule_id NOT IN (
        SELECT cs.id FROM public.course_schedules cs
      )
      AND cl.start_datetime >= current_date
      AND EXISTS (
        SELECT 1 FROM student_attendance_logs sal
        WHERE sal.lesson_id = cl.id
      );

EXCEPTION
    WHEN OTHERS THEN
        v_error_msg := SQLERRM;
        INSERT INTO debug_logs (step, message) VALUES 
            ('publish_error', 
             format('Error publishing draft %s: %s', _draft_id, v_error_msg));
        RAISE;
END;$$;


ALTER FUNCTION public."publish_schedule_draft_v2_Alt_new"(_draft_id uuid, _school_id uuid, _published_by uuid) OWNER TO supabase_admin;

--
-- Name: publish_schedule_draft_v2_alt(uuid, uuid, uuid); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.publish_schedule_draft_v2_alt(_draft_id uuid, _school_id uuid, _published_by uuid DEFAULT auth.uid()) RETURNS uuid
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$DECLARE
    -- Published draft tracking
    v_published_draft_id uuid;
    v_draft_title text;
    v_draft_notes text;
    v_semester_id uuid;
    
    -- Original function variables
    draft_data jsonb;
    schedule jsonb;
    schedule_index integer := 0;
    total_schedules integer;
    staff_ids uuid[];
    v_course_id uuid;
    v_period_id uuid;
    v_day_id integer;
    raw_day_id integer;
    v_room_id uuid;
    v_start_time time;
    v_end_time time;
    start_block int;
    period_count integer := 1;
    start_date date := current_date;
    end_date date := current_date + interval '6 months';
    lesson_count integer;
    existing_schedule_id uuid;
    v_class_id uuid;
    v_subject_id uuid;
    v_meeting_name text;
    v_notes text;
    is_termin boolean;
    termin_subject_uuid uuid;
    v_primary_teacher_id uuid;
    
    -- Audit variables
    v_schedule_count integer := 0;
    v_lesson_count integer := 0;
    v_error_msg text;
    expected_schedule record;
    
    -- Audit comparison tables
    expected_schedules_count integer;
    actual_schedules_count integer;
    expected_lessons_count integer;
    actual_lessons_count integer;
BEGIN
    -- Input validation
    IF _draft_id IS NULL OR _school_id IS NULL THEN
        RAISE EXCEPTION 'Draft ID and School ID are required';
    END IF;
    
    IF _published_by IS NULL THEN
        RAISE EXCEPTION 'Published by user ID is required';
    END IF;
    
    -- Check if draft exists and get metadata
    SELECT sd.title, sd.notes, sd.semester_id, sd.current_version
    INTO v_draft_title, v_draft_notes, v_semester_id, draft_data
    FROM public.schedule_drafts sd
    WHERE sd.id = _draft_id AND sd.school_id = _school_id;
    
    IF NOT FOUND THEN
        RAISE EXCEPTION 'Schedule draft not found: %', _draft_id;
    END IF;
    
    IF draft_data IS NULL THEN
        RAISE EXCEPTION 'Draft has no current version data';
    END IF;
    
    -- Check if there's already a successful publish for this draft
    IF EXISTS (
        SELECT 1 FROM public.published_drafts pd 
        WHERE pd.draft_id = _draft_id AND pd.status = 'success'
    ) THEN
        RAISE EXCEPTION 'Draft has already been successfully published';
    END IF;
    
    -- Check if there are existing publications for this semester (for logging)
    IF EXISTS (
        SELECT 1 FROM public.schedule_drafts sd2
        JOIN public.published_drafts pd2 ON sd2.id = pd2.draft_id
        WHERE sd2.school_id = _school_id 
        AND sd2.semester_id = v_semester_id 
        AND sd2.id != _draft_id
        AND pd2.status = 'success'
    ) THEN
        INSERT INTO debug_logs (message, step)
        VALUES (
            format('Republishing: Found existing publications for semester %s, will replace schedules', v_semester_id),
            'publish_republish'
        );
    END IF;
    
    -- Create published_draft record
    INSERT INTO public.published_drafts (
        draft_id, school_id, semester_id, published_by, title, notes, 
        draft_data, status
    ) VALUES (
        _draft_id, _school_id, v_semester_id, _published_by, v_draft_title, v_draft_notes,
        draft_data, 'in_progress'
    ) RETURNING id INTO v_published_draft_id;
    
    -- Log start of publish attempt
    INSERT INTO debug_logs (message, step)
    VALUES (
        format('Starting publish_schedule_draft_v2 for draft %s by user %s, published_draft_id %s', 
               _draft_id, _published_by, v_published_draft_id),
        'publish_start'
    );
    
    -- Find the UUID for the 'Termin' subject (case insensitive)
    SELECT id INTO termin_subject_uuid FROM subjects WHERE lower(name) = 'termin' LIMIT 1;
    
    -- Create temporary table for tracking expected schedules
    CREATE TEMP TABLE temp_expected_schedules (
        course_id uuid,
        subject_id uuid,
        class_id uuid,
        period_id uuid,
        day_id integer,
        primary_teacher_id uuid,
        room_id uuid,
        start_time time,
        end_time time,
        meeting_name text,
        notes text
    ) ON COMMIT DROP;
    
    -- Parse draft data and populate expected schedules
    total_schedules := jsonb_array_length(draft_data);
    
    WHILE schedule_index < total_schedules LOOP
        schedule := draft_data -> schedule_index;
        
        -- Parse schedule data (reusing original logic)
        IF schedule ? 'course_id' AND (schedule ->> 'course_id') IS NOT NULL THEN
            v_course_id := (schedule ->> 'course_id')::uuid;
            v_class_id := NULL;
            v_subject_id := NULL;
            is_termin := false;
        ELSE
            v_course_id := NULL;
            IF lower(schedule ->> 'subject_id') = 'termin' THEN
                is_termin := true;
                v_subject_id := termin_subject_uuid;
                v_class_id := NULL;
            ELSE
                is_termin := false;
                v_subject_id := NULLIF(schedule ->> 'subject_id', '')::uuid;
                v_class_id := NULLIF(schedule ->> 'class_id', '')::uuid;
            END IF;
        END IF;
        
        v_period_id := NULLIF(schedule ->> 'period_id', '')::uuid;
        raw_day_id := (schedule ->> 'day_id')::int;
        v_day_id := (raw_day_id + 6) % 7;
        
        IF jsonb_typeof(schedule -> 'room_id') = 'object' THEN
            v_room_id := (schedule -> 'room_id' ->> 'id')::uuid;
        ELSE
            v_room_id := NULLIF(schedule ->> 'room_id', '')::uuid;
        END IF;
        
        SELECT array_agg(value::uuid)
        INTO staff_ids
        FROM jsonb_array_elements_text(schedule -> 'staff_ids');
        staff_ids := coalesce(staff_ids, ARRAY[]::uuid[]);
        
        -- Set primary teacher as first teacher in the array
        v_primary_teacher_id := NULL;
        IF array_length(staff_ids, 1) > 0 THEN
            v_primary_teacher_id := staff_ids[1];
        END IF;
        
        v_meeting_name := schedule ->> 'meeting_name';
        v_notes := schedule ->> 'notes';
        
        IF array_length(staff_ids, 1) IS NULL OR array_length(staff_ids, 1) = 0 THEN
            INSERT INTO debug_logs (message, step)
            VALUES (
                format('No teachers assigned for schedule entry %s: publishing anyway', schedule_index),
                'publish_no_teachers'
            );
            -- staff_ids will be empty, v_primary_teacher_id will be NULL
        END IF;
        
        -- Get time information
        SELECT sp.block_number, sp.start_time, sp.end_time
        INTO start_block, v_start_time, v_end_time
        FROM public.schedule_periods sp
        WHERE sp.id = v_period_id;
        
        -- Store expected schedule data
        INSERT INTO temp_expected_schedules (
            course_id, subject_id, class_id, period_id, day_id, primary_teacher_id,
            room_id, start_time, end_time, meeting_name, notes
        ) VALUES (
            v_course_id, v_subject_id, v_class_id, v_period_id, raw_day_id, v_primary_teacher_id,
            v_room_id, v_start_time, v_end_time, v_meeting_name, v_notes
        );
        
        schedule_index := schedule_index + 1;
    END LOOP;
    
    -- Get expected count
    SELECT COUNT(*) INTO expected_schedules_count FROM temp_expected_schedules;
    
    -- Now execute the original publish logic with modifications
    -- Reset index for actual processing
    schedule_index := 0;
    
    WHILE schedule_index < total_schedules LOOP
        schedule := draft_data -> schedule_index;
        
        -- Reparse data (same logic as before)
        IF schedule ? 'course_id' AND (schedule ->> 'course_id') IS NOT NULL THEN
            v_course_id := (schedule ->> 'course_id')::uuid;
            v_class_id := NULL;
            v_subject_id := NULL;
            is_termin := false;
        ELSE
            v_course_id := NULL;
            IF lower(schedule ->> 'subject_id') = 'termin' THEN
                is_termin := true;
                v_subject_id := termin_subject_uuid;
                v_class_id := NULL;
            ELSE
                is_termin := false;
                v_subject_id := NULLIF(schedule ->> 'subject_id', '')::uuid;
                v_class_id := NULLIF(schedule ->> 'class_id', '')::uuid;
            END IF;
        END IF;
        
        v_period_id := NULLIF(schedule ->> 'period_id', '')::uuid;
        raw_day_id := (schedule ->> 'day_id')::int;
        v_day_id := (raw_day_id + 6) % 7;
        
        IF jsonb_typeof(schedule -> 'room_id') = 'object' THEN
            v_room_id := (schedule -> 'room_id' ->> 'id')::uuid;
        ELSE
            v_room_id := NULLIF(schedule ->> 'room_id', '')::uuid;
        END IF;
        
        SELECT array_agg(value::uuid)
        INTO staff_ids
        FROM jsonb_array_elements_text(schedule -> 'staff_ids');
        staff_ids := coalesce(staff_ids, ARRAY[]::uuid[]);
        
        -- Set primary teacher
        v_primary_teacher_id := NULL;
        IF array_length(staff_ids, 1) > 0 THEN
            v_primary_teacher_id := staff_ids[1];
        END IF;
        
        v_meeting_name := schedule ->> 'meeting_name';
        v_notes := schedule ->> 'notes';
        
        IF array_length(staff_ids, 1) IS NULL OR array_length(staff_ids, 1) = 0 THEN
            INSERT INTO debug_logs (message, step)
            VALUES (
                format('No teachers assigned for schedule entry %s: publishing anyway', schedule_index),
                'publish_no_teachers'
            );
            -- staff_ids will be empty, v_primary_teacher_id will be NULL
        END IF;
        
        -- Get period times
        SELECT sp.block_number, sp.start_time, sp.end_time
        INTO start_block, v_start_time, v_end_time
        FROM public.schedule_periods sp
        WHERE sp.id = v_period_id;
        
        -- Find existing schedule
        SELECT cs.id INTO existing_schedule_id
        FROM public.course_schedules cs
        WHERE cs.school_id = _school_id
          AND cs.period_id = v_period_id
          AND cs.day_id = raw_day_id
          AND (
            (v_course_id IS NOT NULL AND cs.course_id = v_course_id)
            OR
            (v_course_id IS NULL AND cs.course_id IS NULL AND cs.subject_id = v_subject_id AND cs.class_id IS NOT DISTINCT FROM v_class_id)
          )
        LIMIT 1;
        
        IF existing_schedule_id IS NOT NULL THEN
            -- Update existing schedule with published_draft_id and primary_teacher_id
            UPDATE public.course_schedules cs
            SET teacher_ids = staff_ids,
                room_id = v_room_id,
                start_time = v_start_time,
                end_time = v_end_time,
                meeting_name = CASE WHEN is_termin THEN v_meeting_name ELSE NULL END,
                notes = v_notes,
                published_draft_id = v_published_draft_id,
                primary_teacher_id = v_primary_teacher_id
            WHERE cs.id = existing_schedule_id;
            
            v_schedule_count := v_schedule_count + 1;
            
            -- Delete existing lessons from current date forward
            DELETE FROM public.course_lessons cl
            WHERE cl.schedule_id = existing_schedule_id
              AND cl.start_datetime >= current_date;
            
            -- Generate new lessons with published_draft_id and primary_teacher_id
            INSERT INTO public.course_lessons (
                course_id, subject_id, class_id, schedule_id, start_datetime, end_datetime,
                school_id, teacher_ids, room_id, period_id, period_ids, is_lesson_based,
                meeting_name, published_draft_id, primary_teacher_id
            )
            SELECT
                v_course_id, v_subject_id, v_class_id, existing_schedule_id,
                gs::date + v_start_time,
                gs::date + v_end_time,
                _school_id, staff_ids, v_room_id,
                v_period_id, ARRAY[v_period_id], true,
                CASE WHEN is_termin THEN v_meeting_name ELSE NULL END,
                v_published_draft_id, v_primary_teacher_id
            FROM generate_series(start_date, end_date, '1 day'::interval) AS gs
            WHERE EXTRACT(ISODOW FROM gs) = v_day_id;
            
            GET DIAGNOSTICS lesson_count = ROW_COUNT;
            v_lesson_count := v_lesson_count + lesson_count;
            
        ELSE
            -- Create new schedule with published_draft_id and primary_teacher_id
            INSERT INTO public.course_schedules (
                course_id, subject_id, class_id, day_id, start_date, end_date,
                start_time, end_time, teacher_ids, room_id, school_id, period_id,
                meeting_name, notes, published_draft_id, primary_teacher_id
            )
            VALUES (
                v_course_id, v_subject_id, v_class_id, raw_day_id, start_date, end_date,
                v_start_time, v_end_time, staff_ids, v_room_id, _school_id, v_period_id,
                CASE WHEN is_termin THEN v_meeting_name ELSE NULL END, v_notes,
                v_published_draft_id, v_primary_teacher_id
            )
            RETURNING id INTO existing_schedule_id;
            
            v_schedule_count := v_schedule_count + 1;
            
            -- Generate lessons for new schedule
            INSERT INTO public.course_lessons (
                course_id, subject_id, class_id, schedule_id, start_datetime, end_datetime,
                school_id, teacher_ids, room_id, period_id, period_ids, is_lesson_based,
                meeting_name, published_draft_id, primary_teacher_id
            )
            SELECT
                v_course_id, v_subject_id, v_class_id, existing_schedule_id,
                gs::date + v_start_time,
                gs::date + v_end_time,
                _school_id, staff_ids, v_room_id,
                v_period_id, ARRAY[v_period_id], true,
                CASE WHEN is_termin THEN v_meeting_name ELSE NULL END,
                v_published_draft_id, v_primary_teacher_id
            FROM generate_series(start_date, end_date, '1 day'::interval) AS gs
            WHERE EXTRACT(ISODOW FROM gs) = v_day_id;
            
            GET DIAGNOSTICS lesson_count = ROW_COUNT;
            v_lesson_count := v_lesson_count + lesson_count;
        END IF;
        
        schedule_index := schedule_index + 1;
    END LOOP;
    
    -- Cleanup: Delete schedules not in the new draft, including from previous publications for this semester
    DELETE FROM public.course_schedules cs
    WHERE cs.school_id = _school_id
      AND (
        -- Delete old unpublished schedules
        cs.published_draft_id IS NULL
        OR
        -- Delete schedules from previous publications for this semester (allow republishing)
        cs.published_draft_id IN (
          SELECT pd.id FROM public.published_drafts pd 
          JOIN public.schedule_drafts sd ON pd.draft_id = sd.id
          WHERE sd.school_id = _school_id 
          AND sd.semester_id = v_semester_id 
          AND pd.id != v_published_draft_id
          AND pd.status = 'success'
        )
      )
      AND NOT EXISTS (
        SELECT 1 FROM temp_expected_schedules tes
        WHERE (
          (tes.course_id IS NOT NULL AND cs.course_id = tes.course_id AND cs.period_id = tes.period_id AND cs.day_id = tes.day_id)
          OR
          (tes.course_id IS NULL AND cs.course_id IS NULL AND cs.subject_id = tes.subject_id AND cs.class_id IS NOT DISTINCT FROM tes.class_id AND cs.period_id = tes.period_id AND cs.day_id = tes.day_id)
        )
      );
    
    -- Cleanup: Delete orphaned lessons and lessons from previous publications for this semester
    DELETE FROM public.course_lessons cl
    WHERE (
        -- Delete orphaned lessons (schedule no longer exists)
        (cl.schedule_id IS NOT NULL
         AND cl.schedule_id NOT IN (SELECT cs.id FROM public.course_schedules cs)
         AND cl.start_datetime >= current_date)
        OR
        -- Delete lessons from previous publications for this semester (allow republishing)
        (cl.published_draft_id IN (
          SELECT pd.id FROM public.published_drafts pd 
          JOIN public.schedule_drafts sd ON pd.draft_id = sd.id
          WHERE sd.school_id = _school_id 
          AND sd.semester_id = v_semester_id 
          AND pd.id != v_published_draft_id
          AND pd.status = 'success'
        ))
      )
      AND NOT EXISTS (
        SELECT 1 FROM student_attendance_logs sal WHERE sal.lesson_id = cl.id
      );
    
    -- AUDIT PHASE: Validate the results
    SELECT COUNT(*) INTO actual_schedules_count 
    FROM public.course_schedules cs 
    WHERE cs.published_draft_id = v_published_draft_id;
    
    SELECT COUNT(*) INTO actual_lessons_count 
    FROM public.course_lessons cl 
    WHERE cl.published_draft_id = v_published_draft_id;
    
    -- Basic count validation
    IF actual_schedules_count != expected_schedules_count THEN
        v_error_msg := format('Schedule count mismatch: expected %s, got %s', 
                             expected_schedules_count, actual_schedules_count);
        RAISE EXCEPTION '%', v_error_msg;
    END IF;
    
    -- Detailed business field validation
    -- Check that all expected schedules were created with correct business data
    FOR expected_schedule IN 
        SELECT * FROM temp_expected_schedules
    LOOP
        IF NOT EXISTS (
            SELECT 1 FROM public.course_schedules cs
            WHERE cs.published_draft_id = v_published_draft_id
              AND cs.course_id IS NOT DISTINCT FROM expected_schedule.course_id
              AND cs.subject_id IS NOT DISTINCT FROM expected_schedule.subject_id
              AND cs.class_id IS NOT DISTINCT FROM expected_schedule.class_id
              AND cs.period_id = expected_schedule.period_id
              AND cs.day_id = expected_schedule.day_id
              AND cs.primary_teacher_id IS NOT DISTINCT FROM expected_schedule.primary_teacher_id
              AND cs.room_id IS NOT DISTINCT FROM expected_schedule.room_id
              AND cs.start_time = expected_schedule.start_time
              AND cs.end_time = expected_schedule.end_time
              AND cs.meeting_name IS NOT DISTINCT FROM expected_schedule.meeting_name
              AND cs.notes IS NOT DISTINCT FROM expected_schedule.notes
        ) THEN
            v_error_msg := format('Missing or incorrect schedule: course_id=%s, subject_id=%s, class_id=%s, period_id=%s, day_id=%s',
                                 expected_schedule.course_id, expected_schedule.subject_id, expected_schedule.class_id, expected_schedule.period_id, expected_schedule.day_id);
            RAISE EXCEPTION '%', v_error_msg;
        END IF;
    END LOOP;
    
    -- Update published_draft record with success
    UPDATE public.published_drafts 
    SET status = 'success',
        schedule_count = v_schedule_count,
        lesson_count = v_lesson_count,
        updated_at = now()
    WHERE id = v_published_draft_id;
    
    -- Update schedule_drafts
    UPDATE public.schedule_drafts
    SET is_live = false
    WHERE school_id = _school_id;
    
    UPDATE public.schedule_drafts
    SET published_at = now(),
        updated_at = now(),
        is_live = true
    WHERE id = _draft_id;
    
    -- Log successful completion
    INSERT INTO debug_logs (message, step)
    VALUES (
        format('Successfully published draft %s: created %s schedules, %s lessons, published_draft_id %s',
               _draft_id, v_schedule_count, v_lesson_count, v_published_draft_id),
        'publish_success'
    );
    
    RETURN v_published_draft_id;
    
EXCEPTION
    WHEN OTHERS THEN
        -- Log the error
        v_error_msg := SQLERRM;
        INSERT INTO debug_logs (message, step)
        VALUES (
            format('Publish failed for draft %s: %s', _draft_id, v_error_msg),
            'publish_error'
        );
        
        -- Update published_draft record with failure
        UPDATE public.published_drafts 
        SET status = 'failed',
            error_message = v_error_msg,
            updated_at = now()
        WHERE id = v_published_draft_id;
        
        -- Re-raise the exception to trigger rollback
        RAISE;
END;$$;


ALTER FUNCTION public.publish_schedule_draft_v2_alt(_draft_id uuid, _school_id uuid, _published_by uuid) OWNER TO supabase_admin;

--
-- Name: refresh_user_login_profiles(); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.refresh_user_login_profiles() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  REFRESH MATERIALIZED VIEW public.vwm_user_login_profiles;
  RETURN NULL;
END;
$$;


ALTER FUNCTION public.refresh_user_login_profiles() OWNER TO supabase_admin;

--
-- Name: remove_student_from_family(uuid); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.remove_student_from_family(target_student_profile_id uuid) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    AS $$
DECLARE
  auth_user uuid := auth.uid();
  school_id uuid;
  current_family_id uuid;
  num_siblings int;
  before_data jsonb;
BEGIN
  -- Get school_id of student
  SELECT up.school_id INTO school_id
  FROM user_profiles up
  WHERE up.id = target_student_profile_id;

  -- Get current family_id
  SELECT fm.family_id INTO current_family_id
  FROM family_members fm
  WHERE fm.profile_id = target_student_profile_id
    AND fm.role = 'student'
    AND fm.removed_at IS NULL;

  IF current_family_id IS NULL THEN
    RAISE EXCEPTION 'This student is not currently assigned to any family.';
  END IF;

  -- Count number of active student family members
  SELECT COUNT(*) INTO num_siblings
  FROM family_members fm
  WHERE fm.family_id = current_family_id
    AND fm.role = 'student'
    AND fm.removed_at IS NULL;

  IF num_siblings <= 1 THEN
    RAISE EXCEPTION 'This is the only student in the family. The entire family should be deleted instead.';
  END IF;

  -- Capture current row as JSON before deletion
  SELECT to_jsonb(fm.*) INTO before_data
  FROM family_members fm
  WHERE fm.profile_id = target_student_profile_id
    AND fm.role = 'student'
    AND fm.removed_at IS NULL;

  -- Hard-delete the family membership
  DELETE FROM family_members
  WHERE profile_id = target_student_profile_id
    AND role = 'student'
    AND removed_at IS NULL;

  -- Insert into change_log
  INSERT INTO change_log (
    user_id,
    school_id,
    table_name,
    record_id,
    action_type,
    before_data
  ) VALUES (
    auth_user,
    school_id,
    'family_members',
    target_student_profile_id,
    'hard_delete',
    before_data
  );
END;
$$;


ALTER FUNCTION public.remove_student_from_family(target_student_profile_id uuid) OWNER TO supabase_admin;

--
-- Name: remove_user_from_group(); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.remove_user_from_group() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_group_id uuid;
  group_name text;
BEGIN
  -- Get the group name based on the old role_id
  SELECT name INTO group_name FROM public.roles WHERE id = OLD.role_id;

  -- Get the group ID
  SELECT id INTO v_group_id FROM public.user_groups WHERE name = group_name;

  -- Check if the user exists in the group before deleting
  RAISE NOTICE 'Checking if user exists in group: %', v_group_id;

  -- Remove the user from the group
  DELETE FROM public.user_group_members
  WHERE user_id = OLD.user_profile_id AND group_id = v_group_id;

  -- Debugging output for DELETE operation
  RAISE NOTICE 'User removed from group: %', v_group_id;

  RETURN OLD;
END;
$$;


ALTER FUNCTION public.remove_user_from_group() OWNER TO supabase_admin;

--
-- Name: resolve_course_note(uuid, text); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.resolve_course_note(p_note_id uuid, p_resolved_by text DEFAULT 'Admin'::text) RETURNS json
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
  -- Update the note to resolved
  UPDATE course_notes 
  SET is_resolved = true,
      resolved_at = NOW(),
      resolved_by = p_resolved_by,
      updated_at = NOW()
  WHERE id = p_note_id AND is_problem = true;

  IF NOT FOUND THEN
    RETURN json_build_object(
      'ok', false,
      'error', 'Note not found or not a problem'
    );
  END IF;

  RETURN json_build_object(
    'ok', true,
    'message', 'Problem resolved successfully'
  );
EXCEPTION WHEN OTHERS THEN
  RETURN json_build_object(
    'ok', false,
    'error', SQLERRM
  );
END;
$$;


ALTER FUNCTION public.resolve_course_note(p_note_id uuid, p_resolved_by text) OWNER TO supabase_admin;

--
-- Name: save_draft_to_db(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.save_draft_to_db(_draft_id uuid, _schedule_data jsonb) RETURNS jsonb
    LANGUAGE plpgsql
    AS $$
DECLARE
  old_version jsonb;
  saved_at timestamptz := now();
  user_id uuid := auth.uid();
  new_version_entry jsonb;
BEGIN
  -- Build version object with metadata
  SELECT current_version INTO old_version
  FROM schedule_drafts
  WHERE id = _draft_id;

  new_version_entry := jsonb_build_object(
    'saved_at', to_char(saved_at, 'YYYY-MM-DD"T"HH24:MI:SS.MS"Z"'),
    'saved_by', user_id,
    'data', old_version
  );

  UPDATE schedule_drafts
  SET 
    current_version = _schedule_data,
    versions = CASE
      WHEN old_version IS NOT NULL THEN array_prepend(new_version_entry, coalesce(versions, '{}'))
      ELSE versions
    END,
    published_at = NULL,
    updated_at = saved_at
  WHERE id = _draft_id;

  IF NOT FOUND THEN
    INSERT INTO schedule_drafts (
      id, current_version, versions, created_at, updated_at
    ) VALUES (
      _draft_id, _schedule_data, '{}', saved_at, saved_at
    );
  END IF;

  RETURN jsonb_build_object(
    'saved', true,
    'saved_at', saved_at
  );
END;
$$;


ALTER FUNCTION public.save_draft_to_db(_draft_id uuid, _schedule_data jsonb) OWNER TO supabase_admin;

--
-- Name: scheduling_create_new_draft(uuid, text, text, uuid, uuid); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.scheduling_create_new_draft(_created_by uuid, _name text, _notes text, _school_id uuid, _semester_id uuid) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
declare
  _new_id uuid := gen_random_uuid();
  _now timestamptz := now();
  _change_group_id uuid := gen_random_uuid();
begin
  -- Insert into schedule_drafts
  insert into public.schedule_drafts (
    id,
    created_by,
    title,
    notes,
    school_id,
    semester_id,
    created_at
  )
  values (
    _new_id,
    _created_by,
    _name,
    _notes,
    _school_id,
    _semester_id,
    _now
  );

  -- Log change in change_log
  insert into public.change_log (
    id,
    change_group_id,
    user_id,
    school_id,
    table_name,
    record_id,
    action_type,
    after_data,
    created_at
  )
  values (
    gen_random_uuid(),
    _change_group_id,
    _created_by,
    _school_id,
    'schedule_drafts',
    _new_id,
    'insert',
    jsonb_build_object(
      'id', _new_id,
      'created_by', _created_by,
      'title', _name,
      'notes', _notes,
      'school_id', _school_id,
      'semester_id', _semester_id,
      'created_at', _now
    ),
    _now
  );

  return _new_id;
end;
$$;


ALTER FUNCTION public.scheduling_create_new_draft(_created_by uuid, _name text, _notes text, _school_id uuid, _semester_id uuid) OWNER TO supabase_admin;

--
-- Name: scheduling_save_draft_version(uuid, jsonb); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.scheduling_save_draft_version(_draft_id uuid, _schedule_data jsonb) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
  _version_entry jsonb;
  _saved_at timestamptz := now();
  _saved_by uuid := auth.uid();
BEGIN
  _version_entry := jsonb_build_object(
    'saved_at', to_char(_saved_at, 'YYYY-MM-DD"T"HH24:MI:SS.MS"Z"'),
    'saved_by', _saved_by,
    'data', _schedule_data
  );

  UPDATE schedule_drafts
  SET 
    current_version = _version_entry,
    versions = CASE
      WHEN versions IS NULL THEN array[_version_entry]
      ELSE versions || _version_entry
    END
  WHERE id = _draft_id;
END;
$$;


ALTER FUNCTION public.scheduling_save_draft_version(_draft_id uuid, _schedule_data jsonb) OWNER TO supabase_admin;

--
-- Name: set_pickup_authorization(uuid, uuid, uuid, boolean); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.set_pickup_authorization(_family_id uuid, _adult_profile_id uuid, _child_profile_id uuid, _authorized_for_pickup boolean) RETURNS text
    LANGUAGE plpgsql
    AS $$
begin
  insert into public.family_member_child_links (
    family_id,
    adult_profile_id,
    child_profile_id,
    authorized_for_pickup
  )
  values (
    _family_id,
    _adult_profile_id,
    _child_profile_id,
    _authorized_for_pickup
  )
  on conflict (family_id, adult_profile_id, child_profile_id) do update
  set authorized_for_pickup = excluded.authorized_for_pickup;

  if _authorized_for_pickup then
    return ' Successfully added as authorized pickup person';
  else
    return ' Successfully removed as authorized pickup person';
  end if;
end;
$$;


ALTER FUNCTION public.set_pickup_authorization(_family_id uuid, _adult_profile_id uuid, _child_profile_id uuid, _authorized_for_pickup boolean) OWNER TO supabase_admin;

--
-- Name: set_sibling_pickup_authorization(uuid, uuid, boolean); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.set_sibling_pickup_authorization(_student_profile_id uuid, _sibling_profile_id uuid, _authorized boolean) RETURNS text
    LANGUAGE plpgsql
    AS $$
begin
  if _authorized then
    update public.profile_info_student
    set authorized_pickup_ids = array_append(authorized_pickup_ids, _sibling_profile_id)
    where profile_id = _student_profile_id
      and not (_sibling_profile_id = any(authorized_pickup_ids));

    return ' Successfully added as authorized pickup person';
  else
    update public.profile_info_student
    set authorized_pickup_ids = array_remove(authorized_pickup_ids, _sibling_profile_id)
    where profile_id = _student_profile_id;

    return ' Successfully removed as authorized pickup person';
  end if;
end;
$$;


ALTER FUNCTION public.set_sibling_pickup_authorization(_student_profile_id uuid, _sibling_profile_id uuid, _authorized boolean) OWNER TO supabase_admin;

--
-- Name: set_updated_at(); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.set_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$;


ALTER FUNCTION public.set_updated_at() OWNER TO supabase_admin;

--
-- Name: set_user_context(uuid); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.set_user_context(p_user_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
  PERFORM set_config('request.user_id', p_user_id::text, true);
END;
$$;


ALTER FUNCTION public.set_user_context(p_user_id uuid) OWNER TO supabase_admin;

--
-- Name: soft_delete_enrollment_with_logging(uuid, uuid, uuid, uuid); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.soft_delete_enrollment_with_logging(p_enrollment_id uuid, p_user_id uuid, p_school_id uuid, p_change_group_id uuid DEFAULT NULL::uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
  v_before RECORD;
BEGIN
  -- Optional: set a change group id so the trigger groups this audit entry
  IF p_change_group_id IS NOT NULL THEN
    PERFORM set_config('my.change_group_id', p_change_group_id::text, true);
  END IF;

  -- Fetch the current enrollment before modification (for your own checks if needed)
  SELECT * INTO v_before
  FROM course_enrollments
  WHERE id = p_enrollment_id;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'Enrollment with ID % not found.', p_enrollment_id;
  END IF;

  -- Perform soft delete by setting end_date = now()
  UPDATE course_enrollments
  SET end_date = now()
  WHERE id = p_enrollment_id;

  -- No manual log_change() call here. The AFTER UPDATE trigger logs before/after automatically.
END;
$$;


ALTER FUNCTION public.soft_delete_enrollment_with_logging(p_enrollment_id uuid, p_user_id uuid, p_school_id uuid, p_change_group_id uuid) OWNER TO supabase_admin;

--
-- Name: soft_delete_enrollment_with_logging_alt(uuid, uuid, uuid, uuid); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.soft_delete_enrollment_with_logging_alt(p_enrollment_id uuid, p_user_id uuid, p_school_id uuid, p_change_group_id uuid DEFAULT NULL::uuid) RETURNS void
    LANGUAGE plpgsql
    AS $$DECLARE
  v_before RECORD;
BEGIN
  -- Fetch the current enrollment before modification
  SELECT * INTO v_before
  FROM course_enrollments
  WHERE id = p_enrollment_id;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'Enrollment with ID % not found.', p_enrollment_id;
  END IF;

  -- Perform soft delete by setting end_date = now()
  UPDATE course_enrollments
  SET end_date = now()
  WHERE id = p_enrollment_id;

  -- Log the change with BEFORE data
  PERFORM log_change(
    p_table_name       := 'course_enrollments',
    p_record_id        := p_enrollment_id,
    p_operation        := 'soft_delete',
    p_user_id          := p_user_id,
    p_school_id        := p_school_id,
    p_data             := to_jsonb(v_before),
    p_change_group_id  := p_change_group_id
  );
END;$$;


ALTER FUNCTION public.soft_delete_enrollment_with_logging_alt(p_enrollment_id uuid, p_user_id uuid, p_school_id uuid, p_change_group_id uuid) OWNER TO supabase_admin;

--
-- Name: student_absence_recurrences_generate(uuid, uuid, uuid, uuid, text, time without time zone, time without time zone, text); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.student_absence_recurrences_generate(p_recurrence_id uuid, p_student_id uuid, p_school_id uuid, p_created_by uuid, p_reason text, p_from_time time without time zone, p_to_time time without time zone, p_attachment_url text DEFAULT NULL::text) RETURNS void
    LANGUAGE plpgsql
    AS $$DECLARE
  rec RECORD;
  v_date date;
  v_daily_log_id uuid;
  v_lesson RECORD;
  v_attendance_log_id uuid;
  v_note text;
BEGIN
  -- Get the recurrence pattern
  SELECT *
    INTO rec
    FROM public.student_absence_recurrences
   WHERE id = p_recurrence_id;

  IF rec IS NULL THEN
    RAISE EXCEPTION 'Recurrence not found for id: %', p_recurrence_id;
  END IF;

  -- Loop through all dates in the recurrence window
  v_date := rec.start_date;
  WHILE v_date <= rec.end_date LOOP
    -- Daily/Interval/Weekday logic
    IF rec.repeat_every_unit = 'day' THEN
      -- If week_days is present, only include if matches
      IF (rec.week_days IS NULL OR array_length(rec.week_days, 1) = 0)
         OR (extract(isodow from v_date)::smallint = ANY (rec.week_days)) THEN

        -- Insert or upsert into student_daily_log
        INSERT INTO student_daily_log (
          student_id, school_id, date, notes, check_in_time, check_out_time, created_at, updated_at, last_updated_by
        )
        VALUES (
          p_student_id, p_school_id, v_date, p_reason, p_from_time, p_to_time, NOW(), NOW(), p_created_by
        )
        ON CONFLICT (student_id, school_id, date) DO UPDATE
          SET notes = p_reason, check_in_time = p_from_time, check_out_time = p_to_time, updated_at=NOW(), last_updated_by=p_created_by
        RETURNING id INTO v_daily_log_id;

        -- For each lesson that overlaps the absence window
        FOR v_lesson IN
          SELECT id, start_datetime, end_datetime
          FROM course_lessons
          WHERE school_id = p_school_id
            AND start_datetime::date = v_date
            AND (start_datetime::time < p_to_time)
            AND (end_datetime::time > p_from_time)
        LOOP
          -- Determine note in German
          IF p_from_time > v_lesson.start_datetime::time THEN
            v_note := format('Zu sp채t wegen %s', p_reason);
          ELSIF p_to_time < v_lesson.end_datetime::time THEN
            v_note := format('Geht fr체her wegen %s', p_reason);
          ELSE
            v_note := p_reason;
          END IF;

          -- Insert or update student_attendance_logs
          INSERT INTO student_attendance_logs (
            lesson_id, student_id, daily_log_id, notes, recorded_by, "timestamp", status
          )
          VALUES (
            v_lesson.id, p_student_id, v_daily_log_id, v_note, p_created_by, NOW(), 'absent'
          )
          ON CONFLICT (lesson_id, student_id) DO
            UPDATE SET notes = v_note, daily_log_id = v_daily_log_id, recorded_by=p_created_by, "timestamp"=NOW(), status='absent';
        END LOOP;
      END IF;
      v_date := v_date + rec.repeat_every_number;
    ELSIF rec.repeat_every_unit = 'week' THEN
      -- Only on specified weekdays (should always have week_days array)
      IF extract(isodow from v_date)::smallint = ANY (rec.week_days) THEN
        -- Same logic as above block
        INSERT INTO student_daily_log (
          student_id, school_id, date, notes, check_in_time, check_out_time, created_at, updated_at, last_updated_by
        )
        VALUES (
          p_student_id, p_school_id, v_date, p_reason, p_from_time, p_to_time, NOW(), NOW(), p_created_by
        )
        ON CONFLICT (student_id, school_id, date) DO UPDATE
          SET notes = p_reason, check_in_time = p_from_time, check_out_time = p_to_time, updated_at=NOW(), last_updated_by=p_created_by
        RETURNING id INTO v_daily_log_id;

        -- Lessons
        FOR v_lesson IN
          SELECT id, start_datetime, end_datetime
          FROM course_lessons
          WHERE school_id = p_school_id
            AND start_datetime::date = v_date
            AND (start_datetime::time < p_to_time)
            AND (end_datetime::time > p_from_time)
        LOOP
          IF p_from_time > v_lesson.start_datetime::time THEN
            v_note := format('Zu sp채t wegen %s', p_reason);
          ELSIF p_to_time < v_lesson.end_datetime::time THEN
            v_note := format('Geht fr체her wegen %s', p_reason);
          ELSE
            v_note := p_reason;
          END IF;
          INSERT INTO student_attendance_logs (
            lesson_id, student_id, daily_log_id, notes, recorded_by, "timestamp", status
          )
          VALUES (
            v_lesson.id, p_student_id, v_daily_log_id, v_note, p_created_by, NOW(), 'absent'
          )
          ON CONFLICT (lesson_id, student_id) DO
            UPDATE SET notes = v_note, daily_log_id = v_daily_log_id, recorded_by=p_created_by, "timestamp"=NOW(), status='absent';
        END LOOP;
      END IF;
      v_date := v_date + 1;
    ELSE
      -- Other recurrence units (e.g., month) can be added here if needed
      v_date := v_date + 1;
    END IF;
  END LOOP;
END;$$;


ALTER FUNCTION public.student_absence_recurrences_generate(p_recurrence_id uuid, p_student_id uuid, p_school_id uuid, p_created_by uuid, p_reason text, p_from_time time without time zone, p_to_time time without time zone, p_attachment_url text) OWNER TO supabase_admin;

--
-- Name: FUNCTION student_absence_recurrences_generate(p_recurrence_id uuid, p_student_id uuid, p_school_id uuid, p_created_by uuid, p_reason text, p_from_time time without time zone, p_to_time time without time zone, p_attachment_url text); Type: COMMENT; Schema: public; Owner: supabase_admin
--

COMMENT ON FUNCTION public.student_absence_recurrences_generate(p_recurrence_id uuid, p_student_id uuid, p_school_id uuid, p_created_by uuid, p_reason text, p_from_time time without time zone, p_to_time time without time zone, p_attachment_url text) IS 'MAIN recurrence generator function. Always use this for recurring absences - do not implement recurrence logic elsewhere.';


--
-- Name: test_as_user(uuid); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.test_as_user(user_id uuid) RETURNS TABLE(test_name text, user_name text, school_name text, visible_users bigint, visible_students bigint, visible_absences bigint, visible_classes bigint, cross_school_users bigint, cross_school_students bigint, cross_school_absences bigint, cross_school_classes bigint)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    user_school_id uuid;
    user_full_name text;
    school_name_text text;
BEGIN
    -- Get user info
    SELECT 
        up.school_id,
        up.first_name || ' ' || up.last_name,
        s.name
    INTO user_school_id, user_full_name, school_name_text
    FROM user_profiles up
    LEFT JOIN structure_schools s ON s.id = up.school_id
    WHERE up.id = user_id;

    -- Set the user context (simulating login)
    PERFORM set_config('request.jwt.claim.sub', user_id::text, true);

    -- Return test results
    RETURN QUERY
    SELECT 
        'RLS Test for ' || user_full_name as test_name,
        user_full_name as user_name,
        school_name_text as school_name,
        (SELECT COUNT(*) FROM public.user_profiles)::bigint as visible_users,
        (SELECT COUNT(*) FROM public.profile_info_student)::bigint as visible_students,
        (SELECT COUNT(*) FROM public.student_absence_notes)::bigint as visible_absences,
        (SELECT COUNT(*) FROM public.structure_classes)::bigint as visible_classes,
        (SELECT COUNT(*) FROM public.user_profiles WHERE school_id != user_school_id)::bigint as cross_school_users,
        (SELECT COUNT(*) FROM public.profile_info_student WHERE school_id != user_school_id)::bigint as cross_school_students,
        (SELECT COUNT(*) FROM public.student_absence_notes WHERE school_id != user_school_id)::bigint as cross_school_absences,
        (SELECT COUNT(*) FROM public.structure_classes WHERE school_id != user_school_id)::bigint as cross_school_classes;
END;
$$;


ALTER FUNCTION public.test_as_user(user_id uuid) OWNER TO supabase_admin;

--
-- Name: test_current_user_rls(); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.test_current_user_rls() RETURNS TABLE(test_name text, count bigint, auth_uid text, note text)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
    -- Test family_members
    RETURN QUERY
    SELECT 
        'Family members'::text,
        COUNT(*)::bigint,
        COALESCE(auth.uid()::text, 'NULL')::text,
        'Current user sees this many family members'::text
    FROM family_members;
    
    -- Test vw_checkin_students_today
    RETURN QUERY
    SELECT 
        'Students in checkin view'::text,
        COUNT(*)::bigint,
        COALESCE(auth.uid()::text, 'NULL')::text,
        'Current user sees this many students'::text
    FROM vw_checkin_students_today;
    
    -- Test structure_classes
    RETURN QUERY
    SELECT 
        'Classes visible'::text,
        COUNT(*)::bigint,
        COALESCE(auth.uid()::text, 'NULL')::text,
        'Current user sees this many classes'::text
    FROM structure_classes;
    
    RETURN;
END
$$;


ALTER FUNCTION public.test_current_user_rls() OWNER TO supabase_admin;

--
-- Name: test_rls_as_father_muller(); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.test_rls_as_father_muller() RETURNS TABLE(test_name text, count bigint, expected text)
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    SET role TO 'authenticated'
    AS $$
BEGIN
    -- Set the user context
    PERFORM set_config('request.jwt.claim.sub', '0c901b8f-19cc-462c-9974-eb6ef5396856', true);
    
    -- Test family_members
    RETURN QUERY
    SELECT 
        'Family members as Father M체ller'::text,
        COUNT(*)::bigint,
        'Should be 10'::text
    FROM family_members;
    
    -- Test vw_checkin_students_today
    RETURN QUERY
    SELECT 
        'Students in checkin view'::text,
        COUNT(*)::bigint,
        'Should see school students'::text
    FROM vw_checkin_students_today;
    
    -- Test structure_classes
    RETURN QUERY
    SELECT 
        'Classes visible'::text,
        COUNT(*)::bigint,
        'Should see accessible classes'::text
    FROM structure_classes;
    
    RETURN;
END
$$;


ALTER FUNCTION public.test_rls_as_father_muller() OWNER TO supabase_admin;

--
-- Name: test_storage_access(); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.test_storage_access() RETURNS TABLE(bucket_name text, is_public boolean, access_test_result text, file_count integer, error_message text, test_successful boolean)
    LANGUAGE plpgsql
    AS $$
DECLARE
    bucket_record RECORD;
    test_result TEXT;
    file_count_val INTEGER;
    error_msg TEXT;
    success_flag BOOLEAN;
BEGIN
    -- Check if user is authenticated
    IF auth.uid() IS NULL THEN
        RETURN QUERY SELECT 
            'authentication_required'::TEXT,
            FALSE,
            'NOT_AUTHENTICATED'::TEXT,
            0,
            'User must be signed in to test storage access'::TEXT,
            FALSE;
        RETURN;
    END IF;

    -- Loop through all buckets and test access with user's actual permissions
    FOR bucket_record IN 
        SELECT name, public FROM storage.buckets ORDER BY name
    LOOP
        BEGIN
            -- Try to count objects in bucket (this tests actual RLS policies)
            SELECT COUNT(*)::INTEGER 
            INTO file_count_val
            FROM storage.objects 
            WHERE bucket_id = bucket_record.name;
            
            test_result := 'ACCESS_GRANTED';
            error_msg := NULL;
            success_flag := TRUE;
            
        EXCEPTION WHEN insufficient_privilege THEN
            test_result := 'ACCESS_DENIED_RLS';
            file_count_val := 0;
            error_msg := 'Blocked by RLS policies';
            success_flag := FALSE;
            
        WHEN OTHERS THEN
            test_result := 'ACCESS_ERROR';
            file_count_val := 0;
            error_msg := SQLERRM;
            success_flag := FALSE;
        END;
        
        RETURN QUERY SELECT 
            bucket_record.name,
            bucket_record.public,
            test_result,
            file_count_val,
            error_msg,
            success_flag;
    END LOOP;
    
    RETURN;
END;
$$;


ALTER FUNCTION public.test_storage_access() OWNER TO supabase_admin;

--
-- Name: FUNCTION test_storage_access(); Type: COMMENT; Schema: public; Owner: supabase_admin
--

COMMENT ON FUNCTION public.test_storage_access() IS 'Tests storage access permissions for current user across all buckets';


--
-- Name: test_timeout(integer); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.test_timeout(seconds integer) RETURNS text
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'public'
    SET statement_timeout TO '0'
    AS $$
begin
  perform pg_sleep(seconds);
  return 'ok';
end;
$$;


ALTER FUNCTION public.test_timeout(seconds integer) OWNER TO supabase_admin;

--
-- Name: toggle_custom_period(uuid, uuid, boolean); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.toggle_custom_period(p_school_id uuid, p_user_id uuid, p_allow_custom boolean) RETURNS void
    LANGUAGE plpgsql
    AS $$
begin
  perform set_config('request.user_id', p_user_id::text, true);
  perform set_config('request.school_id', p_school_id::text, true);

  if p_allow_custom then
    if not exists (
      select 1 from schedule_periods
      where school_id = p_school_id and block_type = 'custom'
    ) then
      insert into schedule_periods (
        school_id,
        block_number,
        start_time,
        end_time,
        label,
        group_label,
        attendance_requirement,
        block_type
      )
      values (
        p_school_id,
        999,
        '00:00',
        '00:00',
        'Benutzerdefiniert',
        'Spezial',
        'flexible',
        'custom'
      );
    end if;
  else
    delete from schedule_periods
    where school_id = p_school_id and block_type = 'custom';
  end if;
end;
$$;


ALTER FUNCTION public.toggle_custom_period(p_school_id uuid, p_user_id uuid, p_allow_custom boolean) OWNER TO supabase_admin;

--
-- Name: trg_set_school_on_possible_times(); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.trg_set_school_on_possible_times() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
  select school_id into NEW.school_id
  from course_list
  where id = NEW.course_id;

  if NEW.school_id is null then
    raise exception 'Invalid course_id  could not resolve school_id';
  end if;

  return NEW;
end;
$$;


ALTER FUNCTION public.trg_set_school_on_possible_times() OWNER TO supabase_admin;

--
-- Name: undo_change(uuid, uuid); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.undo_change(p_change_id uuid, p_user_id uuid) RETURNS void
    LANGUAGE plpgsql
    AS $_$
DECLARE
  v_log_entry change_log;
  v_sql TEXT;
BEGIN
  -- Fetch the change log entry
  SELECT * INTO v_log_entry
  FROM change_log
  WHERE id = p_change_id AND user_id = p_user_id;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'Change not found or you are not the owner.';
  END IF;

  -- Ensure it hasn't already been undone
  IF v_log_entry.is_undone THEN
    RAISE EXCEPTION 'This change has already been undone.';
  END IF;

  -- Only support undo for insert, update, and soft_delete
  IF v_log_entry.action_type = 'insert' THEN
    EXECUTE format('DELETE FROM %I WHERE id = $1', v_log_entry.table_name)
    USING v_log_entry.record_id;

  ELSIF v_log_entry.action_type IN ('update', 'soft_delete') THEN
    -- Dynamically build update statement with casting
    SELECT INTO v_sql
      'UPDATE ' || quote_ident(v_log_entry.table_name) || ' SET ' ||
      string_agg(
        CASE
          WHEN key IN ('id', 'course_id', 'student_id', 'teacher_id', 'created_by', 'updated_by', 'school_id') THEN
            quote_ident(key) || ' = (to_jsonb($1)->>' || quote_literal(key) || ')::uuid'
          WHEN key IN ('start_date', 'end_date') THEN
            quote_ident(key) || ' = (to_jsonb($1)->>' || quote_literal(key) || ')::date'
          WHEN key IN ('created_at', 'updated_at', 'assigned_at') THEN
            quote_ident(key) || ' = (to_jsonb($1)->>' || quote_literal(key) || ')::timestamp'
          WHEN key LIKE 'is_%' THEN
            quote_ident(key) || ' = (to_jsonb($1)->>' || quote_literal(key) || ')::boolean'
          WHEN key = 'schedule_ids' THEN
            quote_ident(key) || ' = CASE ' ||
              'WHEN (to_jsonb($1)->>' || quote_literal(key) || ') = ''[]'' THEN ''{}''::uuid[] ' ||
              'ELSE (to_jsonb($1)->>' || quote_literal(key) || ')::uuid[] END'
          ELSE
            quote_ident(key) || ' = to_jsonb($1)->>' || quote_literal(key)
        END,
        ', '
      )
    FROM jsonb_each_text(v_log_entry.before_data);

    v_sql := v_sql || ' WHERE id = $2';

    EXECUTE v_sql USING v_log_entry.before_data, v_log_entry.record_id;

  ELSE
    RAISE EXCEPTION 'Undo not supported for this action type (%).', v_log_entry.action_type;
  END IF;

  -- Mark as undone
  UPDATE change_log
  SET is_undone = true,
      undone_by = p_user_id,
      undone_at = now()
  WHERE id = p_change_id;
END;
$_$;


ALTER FUNCTION public.undo_change(p_change_id uuid, p_user_id uuid) OWNER TO supabase_admin;

--
-- Name: update_course_with_custom_times_alt(uuid, uuid, uuid, text, integer, date, date, boolean, text, smallint[], text, text[], text, uuid, boolean, boolean, uuid[], text[]); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.update_course_with_custom_times_alt(p_user_id uuid, p_school_id uuid, p_course_id uuid, p_name text, p_max_students integer, p_start_date date, p_end_date date, p_is_active boolean, p_course_code text, p_is_for_year_g smallint[], p_description text, p_pictures text[], p_wichtige_infos text, p_subject_id uuid, p_is_open_course boolean, p_description_visible_to_parents boolean, p_possible_staff_members uuid[], p_possible_times text[]) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  p_entry text;
  weekday smallint;
  schedule_period_id uuid;
  start_time time;
  duration_minutes int;
begin
  -- Set RLS context
  perform set_config('request.user_id', p_user_id::text, true);
  perform set_config('request.school_id', p_school_id::text, true);

  -- Update course details
  update course_list
  set
    name = p_name,
    max_students = p_max_students,
    start_date = p_start_date,
    end_date = p_end_date,
    is_active = p_is_active,
    course_code = p_course_code,
    is_for_year_g = p_is_for_year_g,
    description = p_description,
    pictures = p_pictures,
    wichtige_infos = p_wichtige_infos,
    subject_id = p_subject_id,
    is_open_course = p_is_open_course,
    description_visible_to_parents = p_description_visible_to_parents,
    possible_staff_members = p_possible_staff_members
  where id = p_course_id;

  -- Remove old possible times
  delete from course_possible_times
  where course_id = p_course_id;

  -- Insert new possible times
  foreach p_entry in array p_possible_times
  loop
    begin
      weekday := split_part(p_entry, '|', 1)::smallint;
      schedule_period_id := split_part(p_entry, '|', 2)::uuid;
      start_time := null;
      duration_minutes := null;

      if weekday < 1 or weekday > 6 then
        raise exception 'Invalid weekday in possible time: %', p_entry;
      end if;

      if array_length(string_to_array(p_entry, '|'), 1) >= 4 then
        start_time := nullif(split_part(p_entry, '|', 3), '')::time;
        duration_minutes := nullif(split_part(p_entry, '|', 4), '')::int;
      end if;

      insert into course_possible_times (
        course_id,
        school_id,
        weekday,
        schedule_period_id,
        is_custom_time,
        custom_start,
        custom_duration
      )
      values (
        p_course_id,
        p_school_id,
        weekday,
        schedule_period_id,
        start_time is not null,
        start_time,
        case
          when duration_minutes is not null then (duration_minutes || ' minutes')::interval
          else null
        end
      );

    exception when others then
      raise exception 'Failed to insert possible time %: %', p_entry, sqlerrm;
    end;
  end loop;
end;$$;


ALTER FUNCTION public.update_course_with_custom_times_alt(p_user_id uuid, p_school_id uuid, p_course_id uuid, p_name text, p_max_students integer, p_start_date date, p_end_date date, p_is_active boolean, p_course_code text, p_is_for_year_g smallint[], p_description text, p_pictures text[], p_wichtige_infos text, p_subject_id uuid, p_is_open_course boolean, p_description_visible_to_parents boolean, p_possible_staff_members uuid[], p_possible_times text[]) OWNER TO supabase_admin;

--
-- Name: update_course_with_options(uuid, uuid, uuid, text, integer, date, date, boolean, text, integer[], text, text[], text, uuid, boolean, boolean, uuid[], text[]); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.update_course_with_options(p_course_id uuid, p_user_id uuid, p_school_id uuid, p_name text, p_max_students integer, p_start_date date, p_end_date date, p_is_active boolean, p_course_code text, p_is_for_year_g integer[], p_description text, p_pictures text[], p_wichtige_infos text, p_subject_id uuid, p_is_open_course boolean, p_description_visible_to_parents boolean, p_possible_staff_members uuid[], p_possible_times text[]) RETURNS void
    LANGUAGE plpgsql
    AS $$DECLARE
  p_entry text;
  weekday smallint;
  schedule_period_id uuid;
  start_time time;
  duration_minutes int;
BEGIN
  -- Set RLS and trigger context
  PERFORM set_config('my.user_id', p_user_id::text, true);
  PERFORM set_config('my.school_id', p_school_id::text, true);

  -- Update course details
  UPDATE course_list
  SET
    name = p_name,
    max_students = p_max_students,
    start_date = p_start_date,
    end_date = p_end_date,
    is_active = p_is_active,
    course_code = p_course_code,
    is_for_year_g = p_is_for_year_g,
    description = p_description,
    pictures = p_pictures,
    wichtige_infos = p_wichtige_infos,
    subject_id = p_subject_id,
    is_open_course = p_is_open_course,
    description_visible_to_parents = p_description_visible_to_parents,
    possible_staff_members = p_possible_staff_members
  WHERE id = p_course_id;

  -- Remove old possible times
  DELETE FROM course_possible_times
  WHERE course_id = p_course_id;

  -- Insert new possible times
  FOREACH p_entry IN ARRAY p_possible_times
  LOOP
    BEGIN
      weekday := split_part(p_entry, '|', 1)::smallint;
      schedule_period_id := split_part(p_entry, '|', 2)::uuid;
      start_time := NULL;
      duration_minutes := NULL;

      IF weekday < 1 OR weekday > 6 THEN
        RAISE EXCEPTION 'Invalid weekday in possible time: %', p_entry;
      END IF;

      IF array_length(string_to_array(p_entry, '|'), 1) >= 4 THEN
        start_time := nullif(split_part(p_entry, '|', 3), '')::time;
        duration_minutes := nullif(split_part(p_entry, '|', 4), '')::int;
      END IF;

      INSERT INTO course_possible_times (
        course_id,
        school_id,
        weekday,
        schedule_period_id,
        is_custom_time,
        custom_start,
        custom_duration
      )
      VALUES (
        p_course_id,
        p_school_id,
        weekday,
        schedule_period_id,
        start_time IS NOT NULL,
        start_time,
        CASE
          WHEN duration_minutes IS NOT NULL THEN (duration_minutes || ' minutes')::interval
          ELSE NULL
        END
      );

    EXCEPTION WHEN OTHERS THEN
      RAISE EXCEPTION 'Failed to insert possible time %: %', p_entry, SQLERRM;
    END;
  END LOOP;
END;$$;


ALTER FUNCTION public.update_course_with_options(p_course_id uuid, p_user_id uuid, p_school_id uuid, p_name text, p_max_students integer, p_start_date date, p_end_date date, p_is_active boolean, p_course_code text, p_is_for_year_g integer[], p_description text, p_pictures text[], p_wichtige_infos text, p_subject_id uuid, p_is_open_course boolean, p_description_visible_to_parents boolean, p_possible_staff_members uuid[], p_possible_times text[]) OWNER TO supabase_admin;

--
-- Name: update_course_with_possible_times_alt(uuid, uuid, uuid, text, integer, date, date, boolean, text, integer[], text, text[], text, uuid, boolean, boolean, text[], uuid[]); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.update_course_with_possible_times_alt(p_course_id uuid, p_school_id uuid, p_user_id uuid, p_name text, p_max_students integer, p_start_date date, p_end_date date, p_is_active boolean, p_course_code text, p_is_for_year_g integer[], p_description text, p_pictures text[], p_wichtige_infos text, p_subject_id uuid, p_is_open_course boolean, p_description_visible_to_parents boolean, p_possible_times text[], p_possible_staff_members uuid[] DEFAULT NULL::uuid[]) RETURNS void
    LANGUAGE plpgsql
    AS $$declare
  p_entry text;
  weekday smallint;
  schedule_period_id uuid;
begin
  -- Set RLS context
  perform set_config('request.user_id', p_user_id::text, true);
  perform set_config('request.school_id', p_school_id::text, true);

  -- Update main course fields
  update course_list
  set
    name = p_name,
    max_students = p_max_students,
    start_date = p_start_date,
    end_date = p_end_date,
    is_active = p_is_active,
    course_code = p_course_code,
    is_for_year_g = p_is_for_year_g,
    description = p_description,
    pictures = p_pictures,
    wichtige_infos = p_wichtige_infos,
    subject_id = p_subject_id,
    is_open_course = p_is_open_course,
    description_visible_to_parents = p_description_visible_to_parents,
    possible_staff_members = p_possible_staff_members
  where id = p_course_id;

  -- Remove old possible times
  delete from course_possible_times
  where course_id = p_course_id;

  -- Insert new possible times
  foreach p_entry in array p_possible_times
  loop
    begin
      weekday := split_part(p_entry, '|', 1)::smallint;
      schedule_period_id := split_part(p_entry, '|', 2)::uuid;

      if weekday < 1 or weekday > 5 then
        raise exception 'Invalid weekday in possible time: %', p_entry;
      end if;

      if not exists (
        select 1 from schedule_periods
        where id = schedule_period_id
      ) then
        raise exception 'Invalid schedule_period_id in possible time: %', p_entry;
      end if;

      insert into course_possible_times (course_id, school_id, weekday, schedule_period_id)
      values (p_course_id, p_school_id, weekday, schedule_period_id);

    exception when others then
      raise exception 'Failed to insert possible time %: %', p_entry, sqlerrm;
    end;
  end loop;
end;$$;


ALTER FUNCTION public.update_course_with_possible_times_alt(p_course_id uuid, p_school_id uuid, p_user_id uuid, p_name text, p_max_students integer, p_start_date date, p_end_date date, p_is_active boolean, p_course_code text, p_is_for_year_g integer[], p_description text, p_pictures text[], p_wichtige_infos text, p_subject_id uuid, p_is_open_course boolean, p_description_visible_to_parents boolean, p_possible_times text[], p_possible_staff_members uuid[]) OWNER TO supabase_admin;

--
-- Name: update_registration_periods_updated_at(); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.update_registration_periods_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = now();
    RETURN NEW;
END;
$$;


ALTER FUNCTION public.update_registration_periods_updated_at() OWNER TO supabase_admin;

--
-- Name: update_schedule_draft_info(uuid, text, text); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.update_schedule_draft_info(p_draft_id uuid, p_title text, p_notes text) RETURNS void
    LANGUAGE plpgsql
    AS $$
declare
  v_old_record schedule_drafts;
  v_new_record schedule_drafts;
  v_user_id uuid := auth.uid();
begin
  -- Load current state
  select * into v_old_record from schedule_drafts where id = p_draft_id;

  if not found then
    raise exception 'Draft not found';
  end if;

  -- Update draft
  update schedule_drafts
  set
    title = p_title,
    notes = p_notes,
    updated_at = now()
  where id = p_draft_id;

  -- Load new state
  select * into v_new_record from schedule_drafts where id = p_draft_id;

  -- Log change
  insert into change_log (
    user_id,
    school_id,
    table_name,
    record_id,
    action_type,
    before_data,
    after_data
  )
  values (
    v_user_id,
    v_old_record.school_id,
    'schedule_drafts',
    p_draft_id,
    'update',
    to_jsonb(v_old_record),
    to_jsonb(v_new_record)
  );
end;
$$;


ALTER FUNCTION public.update_schedule_draft_info(p_draft_id uuid, p_title text, p_notes text) OWNER TO supabase_admin;

--
-- Name: update_staff_profile(uuid, uuid, text, text, date, text, date, text, jsonb, text, text); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.update_staff_profile(p_profile_id uuid, p_user_id uuid, p_first_name text, p_last_name text, p_date_of_birth date, p_gender text, p_joined_at date, p_employee_id text DEFAULT NULL::text, p_contacts jsonb DEFAULT '[]'::jsonb, p_reason text DEFAULT NULL::text, p_source text DEFAULT 'manual'::text) RETURNS void
    LANGUAGE plpgsql
    AS $$
declare
  v_school_id uuid;
  v_before_user jsonb;
  v_before_staff jsonb;
  v_change_group_id uuid := gen_random_uuid();  -- Group log entries
  v_generated_employee_id text;
begin
  -- Get school_id from user_profiles (for change_log)
  select school_id into v_school_id
  from public.user_profiles
  where id = p_profile_id;

  -- Store current user_profiles state
  select to_jsonb(up) into v_before_user
  from public.user_profiles up
  where id = p_profile_id;

  -- Update user_profiles
  update public.user_profiles
  set
    first_name = p_first_name,
    last_name = p_last_name,
    date_of_birth = p_date_of_birth,
    gender = p_gender
  where id = p_profile_id;

  -- Log user_profiles update
  insert into public.change_log (
    user_id, school_id, table_name, record_id,
    action_type, before_data, after_data,
    reason, source, change_group_id
  )
  values (
    p_user_id, v_school_id, 'user_profiles', p_profile_id,
    'update', v_before_user,
    jsonb_build_object(
      'first_name', p_first_name,
      'last_name', p_last_name,
      'date_of_birth', p_date_of_birth,
      'gender', p_gender
    ),
    p_reason, p_source, v_change_group_id
  );

  -- Store current profile_info_staff state
  select to_jsonb(ps) into v_before_staff
  from public.profile_info_staff ps
  where profile_id = p_profile_id;

  -- Auto-generate employee ID if not provided
  if p_employee_id is null then
    loop
      v_generated_employee_id := lpad(trunc(random() * 1000000)::text, 6, '0');
      exit when not exists (
        select 1 from public.profile_info_staff where employee_id = v_generated_employee_id
      );
    end loop;
    p_employee_id := v_generated_employee_id;
  end if;

  -- Update profile_info_staff
  update public.profile_info_staff
  set
    joined_at = p_joined_at,
    employee_id = p_employee_id
  where profile_id = p_profile_id;

  -- Log profile_info_staff update
  insert into public.change_log (
    user_id, school_id, table_name, record_id,
    action_type, before_data, after_data,
    reason, source, change_group_id
  )
  values (
    p_user_id, v_school_id, 'profile_info_staff', p_profile_id,
    'update', v_before_staff,
    jsonb_build_object(
      'joined_at', p_joined_at,
      'employee_id', p_employee_id
    ),
    p_reason, p_source, v_change_group_id
  );

  -- TEMP: Replace contacts (NOTE: not ideal for long-term logging granularity)
  delete from public.contacts
  where profile_id = p_profile_id and profile_type = 'staff';

  insert into public.contacts (
    profile_id, profile_type, type, value, notes, is_primary
  )
  select
    p_profile_id,
    'staff',
    contact ->> 'contact_type',
    contact ->> 'contact_value',
    contact ->> 'notes',
    (contact ->> 'is_primary')::boolean
  from jsonb_array_elements(p_contacts) as contact;

  -- Log contacts bulk update
  insert into public.change_log (
    user_id, school_id, table_name, record_id,
    action_type, before_data, after_data,
    reason, source, change_group_id
  )
  values (
    p_user_id, v_school_id, 'contacts', p_profile_id,
    'update', null, p_contacts,
    p_reason, p_source, v_change_group_id
  );
end;
$$;


ALTER FUNCTION public.update_staff_profile(p_profile_id uuid, p_user_id uuid, p_first_name text, p_last_name text, p_date_of_birth date, p_gender text, p_joined_at date, p_employee_id text, p_contacts jsonb, p_reason text, p_source text) OWNER TO supabase_admin;

--
-- Name: upsert_school_days(uuid, integer[]); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.upsert_school_days(p_school_id uuid, p_day_ids integer[]) RETURNS json
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    v_user_school_id UUID;
    v_deleted_count INTEGER;
    v_inserted_count INTEGER;
    v_day_id INTEGER;
BEGIN
    -- Security: Get user's school ID for RLS validation
    v_user_school_id := auth.get_user_school_id();
    
    -- Validate user can only modify their own school
    IF v_user_school_id IS NULL THEN
        RETURN json_build_object(
            'success', false,
            'error', 'Cannot determine user school ID'
        );
    END IF;
    
    IF p_school_id != v_user_school_id THEN
        RETURN json_build_object(
            'success', false,
            'error', 'Access denied: Can only modify your own school days'
        );
    END IF;
    
    -- Validate day_ids array is not empty
    IF p_day_ids IS NULL OR array_length(p_day_ids, 1) IS NULL THEN
        RETURN json_build_object(
            'success', false,
            'error', 'day_ids array cannot be empty'
        );
    END IF;
    
    -- Validate all day_ids exist in structure_days table
    IF EXISTS (
        SELECT 1 FROM unnest(p_day_ids) AS day_id 
        WHERE day_id NOT IN (SELECT id FROM public.structure_days)
    ) THEN
        RETURN json_build_object(
            'success', false,
            'error', 'Invalid day_id provided - must exist in structure_days table'
        );
    END IF;
    
    -- PERFORMANCE: Delete all existing days for this school (efficient bulk delete)
    DELETE FROM public.structure_school_days 
    WHERE school_id = p_school_id;
    
    GET DIAGNOSTICS v_deleted_count = ROW_COUNT;
    
    -- PERFORMANCE: Bulk insert new days using INSERT + VALUES
    INSERT INTO public.structure_school_days (school_id, day_id)
    SELECT p_school_id, unnest(p_day_ids)
    ON CONFLICT (school_id, day_id) DO NOTHING;
    
    GET DIAGNOSTICS v_inserted_count = ROW_COUNT;
    
    -- Return success with operation details
    RETURN json_build_object(
        'success', true,
        'school_id', p_school_id,
        'days_deleted', v_deleted_count,
        'days_inserted', v_inserted_count,
        'day_ids', p_day_ids,
        'message', format('Successfully set %s days for school', v_inserted_count)
    );
    
EXCEPTION WHEN OTHERS THEN
    -- Handle any unexpected errors
    RETURN json_build_object(
        'success', false,
        'error', format('Database error: %s', SQLERRM)
    );
END;
$$;


ALTER FUNCTION public.upsert_school_days(p_school_id uuid, p_day_ids integer[]) OWNER TO supabase_admin;

--
-- Name: use_code(character varying, uuid); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.use_code(input_code character varying, profile_id uuid DEFAULT NULL::uuid) RETURNS json
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    code_user_id UUID;
    code_found BOOLEAN := false;
BEGIN
    IF profile_id IS NULL THEN
        RETURN json_build_object(
            'success', false,
            'error', 'Profile id not provided'
        );
    END IF;

    -- Check if code exists and is unused
    SELECT profile_id INTO code_user_id
    FROM user_codes
    WHERE code = input_code
    AND used_at IS NULL
    AND revoked_at IS NULL
    AND expires_at > NOW();

    IF code_user_id IS NULL THEN
        RETURN json_build_object(
            'success', false,
            'error', 'Invalid, expired, or already used code'
        );
    END IF;

    -- If profile_id was provided, verify ownership
    IF profile_id != code_user_id THEN
        RETURN json_build_object(
            'success', false,
            'error', 'Code does not belong to this user profile'
        );
    END IF;

    -- Mark code as used
    UPDATE user_codes
    SET used_at = NOW()
    WHERE code = input_code
    AND used_at IS NULL;

    RETURN json_build_object(
        'success', true,
        'error', null,
        'message', 'Code marked as used'
    );

EXCEPTION
    WHEN OTHERS THEN
        RETURN json_build_object(
            'success', false,
            'error', SQLERRM
        );
END;
$$;


ALTER FUNCTION public.use_code(input_code character varying, profile_id uuid) OWNER TO supabase_admin;

--
-- Name: whoami(); Type: FUNCTION; Schema: public; Owner: supabase_admin
--

CREATE FUNCTION public.whoami() RETURNS jsonb
    LANGUAGE sql STABLE SECURITY DEFINER
    SET search_path TO 'public'
    SET statement_timeout TO '0'
    AS $$
  select jsonb_build_object(
    'current_user', current_user,
    'session_user', session_user,
    'effective_role', current_setting('role', true),
    'statement_timeout', current_setting('statement_timeout'),
    'lock_timeout', current_setting('lock_timeout'),
    'supabase_uid', auth.uid(),
    'jwt_claims', current_setting('request.jwt.claims', true)
  );
$$;


ALTER FUNCTION public.whoami() OWNER TO supabase_admin;

--
-- Name: apply_rls(jsonb, integer); Type: FUNCTION; Schema: realtime; Owner: supabase_admin
--

CREATE FUNCTION realtime.apply_rls(wal jsonb, max_record_bytes integer DEFAULT (1024 * 1024)) RETURNS SETOF realtime.wal_rls
    LANGUAGE plpgsql
    AS $$
declare
-- Regclass of the table e.g. public.notes
entity_ regclass = (quote_ident(wal ->> 'schema') || '.' || quote_ident(wal ->> 'table'))::regclass;

-- I, U, D, T: insert, update ...
action realtime.action = (
    case wal ->> 'action'
        when 'I' then 'INSERT'
        when 'U' then 'UPDATE'
        when 'D' then 'DELETE'
        else 'ERROR'
    end
);

-- Is row level security enabled for the table
is_rls_enabled bool = relrowsecurity from pg_class where oid = entity_;

subscriptions realtime.subscription[] = array_agg(subs)
    from
        realtime.subscription subs
    where
        subs.entity = entity_;

-- Subscription vars
roles regrole[] = array_agg(distinct us.claims_role::text)
    from
        unnest(subscriptions) us;

working_role regrole;
claimed_role regrole;
claims jsonb;

subscription_id uuid;
subscription_has_access bool;
visible_to_subscription_ids uuid[] = '{}';

-- structured info for wal's columns
columns realtime.wal_column[];
-- previous identity values for update/delete
old_columns realtime.wal_column[];

error_record_exceeds_max_size boolean = octet_length(wal::text) > max_record_bytes;

-- Primary jsonb output for record
output jsonb;

begin
perform set_config('role', null, true);

columns =
    array_agg(
        (
            x->>'name',
            x->>'type',
            x->>'typeoid',
            realtime.cast(
                (x->'value') #>> '{}',
                coalesce(
                    (x->>'typeoid')::regtype, -- null when wal2json version <= 2.4
                    (x->>'type')::regtype
                )
            ),
            (pks ->> 'name') is not null,
            true
        )::realtime.wal_column
    )
    from
        jsonb_array_elements(wal -> 'columns') x
        left join jsonb_array_elements(wal -> 'pk') pks
            on (x ->> 'name') = (pks ->> 'name');

old_columns =
    array_agg(
        (
            x->>'name',
            x->>'type',
            x->>'typeoid',
            realtime.cast(
                (x->'value') #>> '{}',
                coalesce(
                    (x->>'typeoid')::regtype, -- null when wal2json version <= 2.4
                    (x->>'type')::regtype
                )
            ),
            (pks ->> 'name') is not null,
            true
        )::realtime.wal_column
    )
    from
        jsonb_array_elements(wal -> 'identity') x
        left join jsonb_array_elements(wal -> 'pk') pks
            on (x ->> 'name') = (pks ->> 'name');

for working_role in select * from unnest(roles) loop

    -- Update `is_selectable` for columns and old_columns
    columns =
        array_agg(
            (
                c.name,
                c.type_name,
                c.type_oid,
                c.value,
                c.is_pkey,
                pg_catalog.has_column_privilege(working_role, entity_, c.name, 'SELECT')
            )::realtime.wal_column
        )
        from
            unnest(columns) c;

    old_columns =
            array_agg(
                (
                    c.name,
                    c.type_name,
                    c.type_oid,
                    c.value,
                    c.is_pkey,
                    pg_catalog.has_column_privilege(working_role, entity_, c.name, 'SELECT')
                )::realtime.wal_column
            )
            from
                unnest(old_columns) c;

    if action <> 'DELETE' and count(1) = 0 from unnest(columns) c where c.is_pkey then
        return next (
            jsonb_build_object(
                'schema', wal ->> 'schema',
                'table', wal ->> 'table',
                'type', action
            ),
            is_rls_enabled,
            -- subscriptions is already filtered by entity
            (select array_agg(s.subscription_id) from unnest(subscriptions) as s where claims_role = working_role),
            array['Error 400: Bad Request, no primary key']
        )::realtime.wal_rls;

    -- The claims role does not have SELECT permission to the primary key of entity
    elsif action <> 'DELETE' and sum(c.is_selectable::int) <> count(1) from unnest(columns) c where c.is_pkey then
        return next (
            jsonb_build_object(
                'schema', wal ->> 'schema',
                'table', wal ->> 'table',
                'type', action
            ),
            is_rls_enabled,
            (select array_agg(s.subscription_id) from unnest(subscriptions) as s where claims_role = working_role),
            array['Error 401: Unauthorized']
        )::realtime.wal_rls;

    else
        output = jsonb_build_object(
            'schema', wal ->> 'schema',
            'table', wal ->> 'table',
            'type', action,
            'commit_timestamp', to_char(
                ((wal ->> 'timestamp')::timestamptz at time zone 'utc'),
                'YYYY-MM-DD"T"HH24:MI:SS.MS"Z"'
            ),
            'columns', (
                select
                    jsonb_agg(
                        jsonb_build_object(
                            'name', pa.attname,
                            'type', pt.typname
                        )
                        order by pa.attnum asc
                    )
                from
                    pg_attribute pa
                    join pg_type pt
                        on pa.atttypid = pt.oid
                where
                    attrelid = entity_
                    and attnum > 0
                    and pg_catalog.has_column_privilege(working_role, entity_, pa.attname, 'SELECT')
            )
        )
        -- Add "record" key for insert and update
        || case
            when action in ('INSERT', 'UPDATE') then
                jsonb_build_object(
                    'record',
                    (
                        select
                            jsonb_object_agg(
                                -- if unchanged toast, get column name and value from old record
                                coalesce((c).name, (oc).name),
                                case
                                    when (c).name is null then (oc).value
                                    else (c).value
                                end
                            )
                        from
                            unnest(columns) c
                            full outer join unnest(old_columns) oc
                                on (c).name = (oc).name
                        where
                            coalesce((c).is_selectable, (oc).is_selectable)
                            and ( not error_record_exceeds_max_size or (octet_length((c).value::text) <= 64))
                    )
                )
            else '{}'::jsonb
        end
        -- Add "old_record" key for update and delete
        || case
            when action = 'UPDATE' then
                jsonb_build_object(
                        'old_record',
                        (
                            select jsonb_object_agg((c).name, (c).value)
                            from unnest(old_columns) c
                            where
                                (c).is_selectable
                                and ( not error_record_exceeds_max_size or (octet_length((c).value::text) <= 64))
                        )
                    )
            when action = 'DELETE' then
                jsonb_build_object(
                    'old_record',
                    (
                        select jsonb_object_agg((c).name, (c).value)
                        from unnest(old_columns) c
                        where
                            (c).is_selectable
                            and ( not error_record_exceeds_max_size or (octet_length((c).value::text) <= 64))
                            and ( not is_rls_enabled or (c).is_pkey ) -- if RLS enabled, we can't secure deletes so filter to pkey
                    )
                )
            else '{}'::jsonb
        end;

        -- Create the prepared statement
        if is_rls_enabled and action <> 'DELETE' then
            if (select 1 from pg_prepared_statements where name = 'walrus_rls_stmt' limit 1) > 0 then
                deallocate walrus_rls_stmt;
            end if;
            execute realtime.build_prepared_statement_sql('walrus_rls_stmt', entity_, columns);
        end if;

        visible_to_subscription_ids = '{}';

        for subscription_id, claims in (
                select
                    subs.subscription_id,
                    subs.claims
                from
                    unnest(subscriptions) subs
                where
                    subs.entity = entity_
                    and subs.claims_role = working_role
                    and (
                        realtime.is_visible_through_filters(columns, subs.filters)
                        or (
                          action = 'DELETE'
                          and realtime.is_visible_through_filters(old_columns, subs.filters)
                        )
                    )
        ) loop

            if not is_rls_enabled or action = 'DELETE' then
                visible_to_subscription_ids = visible_to_subscription_ids || subscription_id;
            else
                -- Check if RLS allows the role to see the record
                perform
                    -- Trim leading and trailing quotes from working_role because set_config
                    -- doesn't recognize the role as valid if they are included
                    set_config('role', trim(both '"' from working_role::text), true),
                    set_config('request.jwt.claims', claims::text, true);

                execute 'execute walrus_rls_stmt' into subscription_has_access;

                if subscription_has_access then
                    visible_to_subscription_ids = visible_to_subscription_ids || subscription_id;
                end if;
            end if;
        end loop;

        perform set_config('role', null, true);

        return next (
            output,
            is_rls_enabled,
            visible_to_subscription_ids,
            case
                when error_record_exceeds_max_size then array['Error 413: Payload Too Large']
                else '{}'
            end
        )::realtime.wal_rls;

    end if;
end loop;

perform set_config('role', null, true);
end;
$$;


ALTER FUNCTION realtime.apply_rls(wal jsonb, max_record_bytes integer) OWNER TO supabase_admin;

--
-- Name: broadcast_changes(text, text, text, text, text, record, record, text); Type: FUNCTION; Schema: realtime; Owner: supabase_admin
--

CREATE FUNCTION realtime.broadcast_changes(topic_name text, event_name text, operation text, table_name text, table_schema text, new record, old record, level text DEFAULT 'ROW'::text) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
    -- Declare a variable to hold the JSONB representation of the row
    row_data jsonb := '{}'::jsonb;
BEGIN
    IF level = 'STATEMENT' THEN
        RAISE EXCEPTION 'function can only be triggered for each row, not for each statement';
    END IF;
    -- Check the operation type and handle accordingly
    IF operation = 'INSERT' OR operation = 'UPDATE' OR operation = 'DELETE' THEN
        row_data := jsonb_build_object('old_record', OLD, 'record', NEW, 'operation', operation, 'table', table_name, 'schema', table_schema);
        PERFORM realtime.send (row_data, event_name, topic_name);
    ELSE
        RAISE EXCEPTION 'Unexpected operation type: %', operation;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'Failed to process the row: %', SQLERRM;
END;

$$;


ALTER FUNCTION realtime.broadcast_changes(topic_name text, event_name text, operation text, table_name text, table_schema text, new record, old record, level text) OWNER TO supabase_admin;

--
-- Name: build_prepared_statement_sql(text, regclass, realtime.wal_column[]); Type: FUNCTION; Schema: realtime; Owner: supabase_admin
--

CREATE FUNCTION realtime.build_prepared_statement_sql(prepared_statement_name text, entity regclass, columns realtime.wal_column[]) RETURNS text
    LANGUAGE sql
    AS $$
      /*
      Builds a sql string that, if executed, creates a prepared statement to
      tests retrive a row from *entity* by its primary key columns.
      Example
          select realtime.build_prepared_statement_sql('public.notes', '{"id"}'::text[], '{"bigint"}'::text[])
      */
          select
      'prepare ' || prepared_statement_name || ' as
          select
              exists(
                  select
                      1
                  from
                      ' || entity || '
                  where
                      ' || string_agg(quote_ident(pkc.name) || '=' || quote_nullable(pkc.value #>> '{}') , ' and ') || '
              )'
          from
              unnest(columns) pkc
          where
              pkc.is_pkey
          group by
              entity
      $$;


ALTER FUNCTION realtime.build_prepared_statement_sql(prepared_statement_name text, entity regclass, columns realtime.wal_column[]) OWNER TO supabase_admin;

--
-- Name: cast(text, regtype); Type: FUNCTION; Schema: realtime; Owner: supabase_admin
--

CREATE FUNCTION realtime."cast"(val text, type_ regtype) RETURNS jsonb
    LANGUAGE plpgsql IMMUTABLE
    AS $$
    declare
      res jsonb;
    begin
      execute format('select to_jsonb(%L::'|| type_::text || ')', val)  into res;
      return res;
    end
    $$;


ALTER FUNCTION realtime."cast"(val text, type_ regtype) OWNER TO supabase_admin;

--
-- Name: check_equality_op(realtime.equality_op, regtype, text, text); Type: FUNCTION; Schema: realtime; Owner: supabase_admin
--

CREATE FUNCTION realtime.check_equality_op(op realtime.equality_op, type_ regtype, val_1 text, val_2 text) RETURNS boolean
    LANGUAGE plpgsql IMMUTABLE
    AS $$
      /*
      Casts *val_1* and *val_2* as type *type_* and check the *op* condition for truthiness
      */
      declare
          op_symbol text = (
              case
                  when op = 'eq' then '='
                  when op = 'neq' then '!='
                  when op = 'lt' then '<'
                  when op = 'lte' then '<='
                  when op = 'gt' then '>'
                  when op = 'gte' then '>='
                  when op = 'in' then '= any'
                  else 'UNKNOWN OP'
              end
          );
          res boolean;
      begin
          execute format(
              'select %L::'|| type_::text || ' ' || op_symbol
              || ' ( %L::'
              || (
                  case
                      when op = 'in' then type_::text || '[]'
                      else type_::text end
              )
              || ')', val_1, val_2) into res;
          return res;
      end;
      $$;


ALTER FUNCTION realtime.check_equality_op(op realtime.equality_op, type_ regtype, val_1 text, val_2 text) OWNER TO supabase_admin;

--
-- Name: is_visible_through_filters(realtime.wal_column[], realtime.user_defined_filter[]); Type: FUNCTION; Schema: realtime; Owner: supabase_admin
--

CREATE FUNCTION realtime.is_visible_through_filters(columns realtime.wal_column[], filters realtime.user_defined_filter[]) RETURNS boolean
    LANGUAGE sql IMMUTABLE
    AS $_$
    /*
    Should the record be visible (true) or filtered out (false) after *filters* are applied
    */
        select
            -- Default to allowed when no filters present
            $2 is null -- no filters. this should not happen because subscriptions has a default
            or array_length($2, 1) is null -- array length of an empty array is null
            or bool_and(
                coalesce(
                    realtime.check_equality_op(
                        op:=f.op,
                        type_:=coalesce(
                            col.type_oid::regtype, -- null when wal2json version <= 2.4
                            col.type_name::regtype
                        ),
                        -- cast jsonb to text
                        val_1:=col.value #>> '{}',
                        val_2:=f.value
                    ),
                    false -- if null, filter does not match
                )
            )
        from
            unnest(filters) f
            join unnest(columns) col
                on f.column_name = col.name;
    $_$;


ALTER FUNCTION realtime.is_visible_through_filters(columns realtime.wal_column[], filters realtime.user_defined_filter[]) OWNER TO supabase_admin;

--
-- Name: list_changes(name, name, integer, integer); Type: FUNCTION; Schema: realtime; Owner: supabase_admin
--

CREATE FUNCTION realtime.list_changes(publication name, slot_name name, max_changes integer, max_record_bytes integer) RETURNS SETOF realtime.wal_rls
    LANGUAGE sql
    SET log_min_messages TO 'fatal'
    AS $$
      with pub as (
        select
          concat_ws(
            ',',
            case when bool_or(pubinsert) then 'insert' else null end,
            case when bool_or(pubupdate) then 'update' else null end,
            case when bool_or(pubdelete) then 'delete' else null end
          ) as w2j_actions,
          coalesce(
            string_agg(
              realtime.quote_wal2json(format('%I.%I', schemaname, tablename)::regclass),
              ','
            ) filter (where ppt.tablename is not null and ppt.tablename not like '% %'),
            ''
          ) w2j_add_tables
        from
          pg_publication pp
          left join pg_publication_tables ppt
            on pp.pubname = ppt.pubname
        where
          pp.pubname = publication
        group by
          pp.pubname
        limit 1
      ),
      w2j as (
        select
          x.*, pub.w2j_add_tables
        from
          pub,
          pg_logical_slot_get_changes(
            slot_name, null, max_changes,
            'include-pk', 'true',
            'include-transaction', 'false',
            'include-timestamp', 'true',
            'include-type-oids', 'true',
            'format-version', '2',
            'actions', pub.w2j_actions,
            'add-tables', pub.w2j_add_tables
          ) x
      )
      select
        xyz.wal,
        xyz.is_rls_enabled,
        xyz.subscription_ids,
        xyz.errors
      from
        w2j,
        realtime.apply_rls(
          wal := w2j.data::jsonb,
          max_record_bytes := max_record_bytes
        ) xyz(wal, is_rls_enabled, subscription_ids, errors)
      where
        w2j.w2j_add_tables <> ''
        and xyz.subscription_ids[1] is not null
    $$;


ALTER FUNCTION realtime.list_changes(publication name, slot_name name, max_changes integer, max_record_bytes integer) OWNER TO supabase_admin;

--
-- Name: quote_wal2json(regclass); Type: FUNCTION; Schema: realtime; Owner: supabase_admin
--

CREATE FUNCTION realtime.quote_wal2json(entity regclass) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $$
      select
        (
          select string_agg('' || ch,'')
          from unnest(string_to_array(nsp.nspname::text, null)) with ordinality x(ch, idx)
          where
            not (x.idx = 1 and x.ch = '"')
            and not (
              x.idx = array_length(string_to_array(nsp.nspname::text, null), 1)
              and x.ch = '"'
            )
        )
        || '.'
        || (
          select string_agg('' || ch,'')
          from unnest(string_to_array(pc.relname::text, null)) with ordinality x(ch, idx)
          where
            not (x.idx = 1 and x.ch = '"')
            and not (
              x.idx = array_length(string_to_array(nsp.nspname::text, null), 1)
              and x.ch = '"'
            )
          )
      from
        pg_class pc
        join pg_namespace nsp
          on pc.relnamespace = nsp.oid
      where
        pc.oid = entity
    $$;


ALTER FUNCTION realtime.quote_wal2json(entity regclass) OWNER TO supabase_admin;

--
-- Name: send(jsonb, text, text, boolean); Type: FUNCTION; Schema: realtime; Owner: supabase_admin
--

CREATE FUNCTION realtime.send(payload jsonb, event text, topic text, private boolean DEFAULT true) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
  BEGIN
    -- Set the topic configuration
    EXECUTE format('SET LOCAL realtime.topic TO %L', topic);

    -- Attempt to insert the message
    INSERT INTO realtime.messages (payload, event, topic, private, extension)
    VALUES (payload, event, topic, private, 'broadcast');
  EXCEPTION
    WHEN OTHERS THEN
      -- Capture and notify the error
      PERFORM pg_notify(
          'realtime:system',
          jsonb_build_object(
              'error', SQLERRM,
              'function', 'realtime.send',
              'event', event,
              'topic', topic,
              'private', private
          )::text
      );
  END;
END;
$$;


ALTER FUNCTION realtime.send(payload jsonb, event text, topic text, private boolean) OWNER TO supabase_admin;

--
-- Name: subscription_check_filters(); Type: FUNCTION; Schema: realtime; Owner: supabase_admin
--

CREATE FUNCTION realtime.subscription_check_filters() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
    /*
    Validates that the user defined filters for a subscription:
    - refer to valid columns that the claimed role may access
    - values are coercable to the correct column type
    */
    declare
        col_names text[] = coalesce(
                array_agg(c.column_name order by c.ordinal_position),
                '{}'::text[]
            )
            from
                information_schema.columns c
            where
                format('%I.%I', c.table_schema, c.table_name)::regclass = new.entity
                and pg_catalog.has_column_privilege(
                    (new.claims ->> 'role'),
                    format('%I.%I', c.table_schema, c.table_name)::regclass,
                    c.column_name,
                    'SELECT'
                );
        filter realtime.user_defined_filter;
        col_type regtype;

        in_val jsonb;
    begin
        for filter in select * from unnest(new.filters) loop
            -- Filtered column is valid
            if not filter.column_name = any(col_names) then
                raise exception 'invalid column for filter %', filter.column_name;
            end if;

            -- Type is sanitized and safe for string interpolation
            col_type = (
                select atttypid::regtype
                from pg_catalog.pg_attribute
                where attrelid = new.entity
                      and attname = filter.column_name
            );
            if col_type is null then
                raise exception 'failed to lookup type for column %', filter.column_name;
            end if;

            -- Set maximum number of entries for in filter
            if filter.op = 'in'::realtime.equality_op then
                in_val = realtime.cast(filter.value, (col_type::text || '[]')::regtype);
                if coalesce(jsonb_array_length(in_val), 0) > 100 then
                    raise exception 'too many values for `in` filter. Maximum 100';
                end if;
            else
                -- raises an exception if value is not coercable to type
                perform realtime.cast(filter.value, col_type);
            end if;

        end loop;

        -- Apply consistent order to filters so the unique constraint on
        -- (subscription_id, entity, filters) can't be tricked by a different filter order
        new.filters = coalesce(
            array_agg(f order by f.column_name, f.op, f.value),
            '{}'
        ) from unnest(new.filters) f;

        return new;
    end;
    $$;


ALTER FUNCTION realtime.subscription_check_filters() OWNER TO supabase_admin;

--
-- Name: to_regrole(text); Type: FUNCTION; Schema: realtime; Owner: supabase_admin
--

CREATE FUNCTION realtime.to_regrole(role_name text) RETURNS regrole
    LANGUAGE sql IMMUTABLE
    AS $$ select role_name::regrole $$;


ALTER FUNCTION realtime.to_regrole(role_name text) OWNER TO supabase_admin;

--
-- Name: topic(); Type: FUNCTION; Schema: realtime; Owner: supabase_realtime_admin
--

CREATE FUNCTION realtime.topic() RETURNS text
    LANGUAGE sql STABLE
    AS $$
select nullif(current_setting('realtime.topic', true), '')::text;
$$;


ALTER FUNCTION realtime.topic() OWNER TO supabase_realtime_admin;

--
-- Name: add_prefixes(text, text); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.add_prefixes(_bucket_id text, _name text) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE
    prefixes text[];
BEGIN
    prefixes := "storage"."get_prefixes"("_name");

    IF array_length(prefixes, 1) > 0 THEN
        INSERT INTO storage.prefixes (name, bucket_id)
        SELECT UNNEST(prefixes) as name, "_bucket_id" ON CONFLICT DO NOTHING;
    END IF;
END;
$$;


ALTER FUNCTION storage.add_prefixes(_bucket_id text, _name text) OWNER TO supabase_storage_admin;

--
-- Name: can_insert_object(text, text, uuid, jsonb); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.can_insert_object(bucketid text, name text, owner uuid, metadata jsonb) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
  INSERT INTO "storage"."objects" ("bucket_id", "name", "owner", "metadata") VALUES (bucketid, name, owner, metadata);
  -- hack to rollback the successful insert
  RAISE sqlstate 'PT200' using
  message = 'ROLLBACK',
  detail = 'rollback successful insert';
END
$$;


ALTER FUNCTION storage.can_insert_object(bucketid text, name text, owner uuid, metadata jsonb) OWNER TO supabase_storage_admin;

--
-- Name: delete_prefix(text, text); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.delete_prefix(_bucket_id text, _name text) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
BEGIN
    -- Check if we can delete the prefix
    IF EXISTS(
        SELECT FROM "storage"."prefixes"
        WHERE "prefixes"."bucket_id" = "_bucket_id"
          AND level = "storage"."get_level"("_name") + 1
          AND "prefixes"."name" COLLATE "C" LIKE "_name" || '/%'
        LIMIT 1
    )
    OR EXISTS(
        SELECT FROM "storage"."objects"
        WHERE "objects"."bucket_id" = "_bucket_id"
          AND "storage"."get_level"("objects"."name") = "storage"."get_level"("_name") + 1
          AND "objects"."name" COLLATE "C" LIKE "_name" || '/%'
        LIMIT 1
    ) THEN
    -- There are sub-objects, skip deletion
    RETURN false;
    ELSE
        DELETE FROM "storage"."prefixes"
        WHERE "prefixes"."bucket_id" = "_bucket_id"
          AND level = "storage"."get_level"("_name")
          AND "prefixes"."name" = "_name";
        RETURN true;
    END IF;
END;
$$;


ALTER FUNCTION storage.delete_prefix(_bucket_id text, _name text) OWNER TO supabase_storage_admin;

--
-- Name: delete_prefix_hierarchy_trigger(); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.delete_prefix_hierarchy_trigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    prefix text;
BEGIN
    prefix := "storage"."get_prefix"(OLD."name");

    IF coalesce(prefix, '') != '' THEN
        PERFORM "storage"."delete_prefix"(OLD."bucket_id", prefix);
    END IF;

    RETURN OLD;
END;
$$;


ALTER FUNCTION storage.delete_prefix_hierarchy_trigger() OWNER TO supabase_storage_admin;

--
-- Name: extension(text); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.extension(name text) RETURNS text
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE
    _parts text[];
    _filename text;
BEGIN
    SELECT string_to_array(name, '/') INTO _parts;
    SELECT _parts[array_length(_parts,1)] INTO _filename;
    RETURN reverse(split_part(reverse(_filename), '.', 1));
END
$$;


ALTER FUNCTION storage.extension(name text) OWNER TO supabase_storage_admin;

--
-- Name: extract_school_id_from_path(text); Type: FUNCTION; Schema: storage; Owner: supabase_admin
--

CREATE FUNCTION storage.extract_school_id_from_path(object_path text) RETURNS uuid
    LANGUAGE sql IMMUTABLE
    AS $$
  SELECT 
    CASE 
      -- Path format: school-logo/school_id/filename
      -- OR: bucket-name/school_id/folder/filename
      WHEN object_path ~ '^[^/]+/[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}/' THEN
        (regexp_match(object_path, '^[^/]+/([0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12})/'))[1]::UUID
      ELSE
        NULL
    END;
$$;


ALTER FUNCTION storage.extract_school_id_from_path(object_path text) OWNER TO supabase_admin;

--
-- Name: filename(text); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.filename(name text) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
_parts text[];
BEGIN
	select string_to_array(name, '/') into _parts;
	return _parts[array_length(_parts,1)];
END
$$;


ALTER FUNCTION storage.filename(name text) OWNER TO supabase_storage_admin;

--
-- Name: foldername(text); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.foldername(name text) RETURNS text[]
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE
    _parts text[];
BEGIN
    -- Split on "/" to get path segments
    SELECT string_to_array(name, '/') INTO _parts;
    -- Return everything except the last segment
    RETURN _parts[1 : array_length(_parts,1) - 1];
END
$$;


ALTER FUNCTION storage.foldername(name text) OWNER TO supabase_storage_admin;

--
-- Name: get_level(text); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.get_level(name text) RETURNS integer
    LANGUAGE sql IMMUTABLE STRICT
    AS $$
SELECT array_length(string_to_array("name", '/'), 1);
$$;


ALTER FUNCTION storage.get_level(name text) OWNER TO supabase_storage_admin;

--
-- Name: get_object_school_id(jsonb); Type: FUNCTION; Schema: storage; Owner: supabase_admin
--

CREATE FUNCTION storage.get_object_school_id(object_metadata jsonb) RETURNS uuid
    LANGUAGE sql IMMUTABLE
    AS $$
  SELECT (object_metadata ->> 'school_id')::UUID;
$$;


ALTER FUNCTION storage.get_object_school_id(object_metadata jsonb) OWNER TO supabase_admin;

--
-- Name: get_prefix(text); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.get_prefix(name text) RETURNS text
    LANGUAGE sql IMMUTABLE STRICT
    AS $_$
SELECT
    CASE WHEN strpos("name", '/') > 0 THEN
             regexp_replace("name", '[\/]{1}[^\/]+\/?$', '')
         ELSE
             ''
        END;
$_$;


ALTER FUNCTION storage.get_prefix(name text) OWNER TO supabase_storage_admin;

--
-- Name: get_prefixes(text); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.get_prefixes(name text) RETURNS text[]
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $$
DECLARE
    parts text[];
    prefixes text[];
    prefix text;
BEGIN
    -- Split the name into parts by '/'
    parts := string_to_array("name", '/');
    prefixes := '{}';

    -- Construct the prefixes, stopping one level below the last part
    FOR i IN 1..array_length(parts, 1) - 1 LOOP
            prefix := array_to_string(parts[1:i], '/');
            prefixes := array_append(prefixes, prefix);
    END LOOP;

    RETURN prefixes;
END;
$$;


ALTER FUNCTION storage.get_prefixes(name text) OWNER TO supabase_storage_admin;

--
-- Name: get_size_by_bucket(); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.get_size_by_bucket() RETURNS TABLE(size bigint, bucket_id text)
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    return query
        select sum((metadata->>'size')::bigint) as size, obj.bucket_id
        from "storage".objects as obj
        group by obj.bucket_id;
END
$$;


ALTER FUNCTION storage.get_size_by_bucket() OWNER TO supabase_storage_admin;

--
-- Name: is_public_bucket(text); Type: FUNCTION; Schema: storage; Owner: supabase_admin
--

CREATE FUNCTION storage.is_public_bucket(bucket_name text) RETURNS boolean
    LANGUAGE sql STABLE
    AS $$
  SELECT public FROM storage.buckets WHERE name = bucket_name;
$$;


ALTER FUNCTION storage.is_public_bucket(bucket_name text) OWNER TO supabase_admin;

--
-- Name: list_multipart_uploads_with_delimiter(text, text, text, integer, text, text); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.list_multipart_uploads_with_delimiter(bucket_id text, prefix_param text, delimiter_param text, max_keys integer DEFAULT 100, next_key_token text DEFAULT ''::text, next_upload_token text DEFAULT ''::text) RETURNS TABLE(key text, id text, created_at timestamp with time zone)
    LANGUAGE plpgsql
    AS $_$
BEGIN
    RETURN QUERY EXECUTE
        'SELECT DISTINCT ON(key COLLATE "C") * from (
            SELECT
                CASE
                    WHEN position($2 IN substring(key from length($1) + 1)) > 0 THEN
                        substring(key from 1 for length($1) + position($2 IN substring(key from length($1) + 1)))
                    ELSE
                        key
                END AS key, id, created_at
            FROM
                storage.s3_multipart_uploads
            WHERE
                bucket_id = $5 AND
                key ILIKE $1 || ''%'' AND
                CASE
                    WHEN $4 != '''' AND $6 = '''' THEN
                        CASE
                            WHEN position($2 IN substring(key from length($1) + 1)) > 0 THEN
                                substring(key from 1 for length($1) + position($2 IN substring(key from length($1) + 1))) COLLATE "C" > $4
                            ELSE
                                key COLLATE "C" > $4
                            END
                    ELSE
                        true
                END AND
                CASE
                    WHEN $6 != '''' THEN
                        id COLLATE "C" > $6
                    ELSE
                        true
                    END
            ORDER BY
                key COLLATE "C" ASC, created_at ASC) as e order by key COLLATE "C" LIMIT $3'
        USING prefix_param, delimiter_param, max_keys, next_key_token, bucket_id, next_upload_token;
END;
$_$;


ALTER FUNCTION storage.list_multipart_uploads_with_delimiter(bucket_id text, prefix_param text, delimiter_param text, max_keys integer, next_key_token text, next_upload_token text) OWNER TO supabase_storage_admin;

--
-- Name: list_objects_with_delimiter(text, text, text, integer, text, text); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.list_objects_with_delimiter(bucket_id text, prefix_param text, delimiter_param text, max_keys integer DEFAULT 100, start_after text DEFAULT ''::text, next_token text DEFAULT ''::text) RETURNS TABLE(name text, id uuid, metadata jsonb, updated_at timestamp with time zone)
    LANGUAGE plpgsql
    AS $_$
BEGIN
    RETURN QUERY EXECUTE
        'SELECT DISTINCT ON(name COLLATE "C") * from (
            SELECT
                CASE
                    WHEN position($2 IN substring(name from length($1) + 1)) > 0 THEN
                        substring(name from 1 for length($1) + position($2 IN substring(name from length($1) + 1)))
                    ELSE
                        name
                END AS name, id, metadata, updated_at
            FROM
                storage.objects
            WHERE
                bucket_id = $5 AND
                name ILIKE $1 || ''%'' AND
                CASE
                    WHEN $6 != '''' THEN
                    name COLLATE "C" > $6
                ELSE true END
                AND CASE
                    WHEN $4 != '''' THEN
                        CASE
                            WHEN position($2 IN substring(name from length($1) + 1)) > 0 THEN
                                substring(name from 1 for length($1) + position($2 IN substring(name from length($1) + 1))) COLLATE "C" > $4
                            ELSE
                                name COLLATE "C" > $4
                            END
                    ELSE
                        true
                END
            ORDER BY
                name COLLATE "C" ASC) as e order by name COLLATE "C" LIMIT $3'
        USING prefix_param, delimiter_param, max_keys, next_token, bucket_id, start_after;
END;
$_$;


ALTER FUNCTION storage.list_objects_with_delimiter(bucket_id text, prefix_param text, delimiter_param text, max_keys integer, start_after text, next_token text) OWNER TO supabase_storage_admin;

--
-- Name: objects_insert_prefix_trigger(); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.objects_insert_prefix_trigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    PERFORM "storage"."add_prefixes"(NEW."bucket_id", NEW."name");
    NEW.level := "storage"."get_level"(NEW."name");

    RETURN NEW;
END;
$$;


ALTER FUNCTION storage.objects_insert_prefix_trigger() OWNER TO supabase_storage_admin;

--
-- Name: objects_update_prefix_trigger(); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.objects_update_prefix_trigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    old_prefixes TEXT[];
BEGIN
    -- Ensure this is an update operation and the name has changed
    IF TG_OP = 'UPDATE' AND (NEW."name" <> OLD."name" OR NEW."bucket_id" <> OLD."bucket_id") THEN
        -- Retrieve old prefixes
        old_prefixes := "storage"."get_prefixes"(OLD."name");

        -- Remove old prefixes that are only used by this object
        WITH all_prefixes as (
            SELECT unnest(old_prefixes) as prefix
        ),
        can_delete_prefixes as (
             SELECT prefix
             FROM all_prefixes
             WHERE NOT EXISTS (
                 SELECT 1 FROM "storage"."objects"
                 WHERE "bucket_id" = OLD."bucket_id"
                   AND "name" <> OLD."name"
                   AND "name" LIKE (prefix || '%')
             )
         )
        DELETE FROM "storage"."prefixes" WHERE name IN (SELECT prefix FROM can_delete_prefixes);

        -- Add new prefixes
        PERFORM "storage"."add_prefixes"(NEW."bucket_id", NEW."name");
    END IF;
    -- Set the new level
    NEW."level" := "storage"."get_level"(NEW."name");

    RETURN NEW;
END;
$$;


ALTER FUNCTION storage.objects_update_prefix_trigger() OWNER TO supabase_storage_admin;

--
-- Name: operation(); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.operation() RETURNS text
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN current_setting('storage.operation', true);
END;
$$;


ALTER FUNCTION storage.operation() OWNER TO supabase_storage_admin;

--
-- Name: prefixes_insert_trigger(); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.prefixes_insert_trigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    PERFORM "storage"."add_prefixes"(NEW."bucket_id", NEW."name");
    RETURN NEW;
END;
$$;


ALTER FUNCTION storage.prefixes_insert_trigger() OWNER TO supabase_storage_admin;

--
-- Name: search(text, text, integer, integer, integer, text, text, text); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.search(prefix text, bucketname text, limits integer DEFAULT 100, levels integer DEFAULT 1, offsets integer DEFAULT 0, search text DEFAULT ''::text, sortcolumn text DEFAULT 'name'::text, sortorder text DEFAULT 'asc'::text) RETURNS TABLE(name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone, metadata jsonb)
    LANGUAGE plpgsql
    AS $$
declare
    can_bypass_rls BOOLEAN;
begin
    SELECT rolbypassrls
    INTO can_bypass_rls
    FROM pg_roles
    WHERE rolname = coalesce(nullif(current_setting('role', true), 'none'), current_user);

    IF can_bypass_rls THEN
        RETURN QUERY SELECT * FROM storage.search_v1_optimised(prefix, bucketname, limits, levels, offsets, search, sortcolumn, sortorder);
    ELSE
        RETURN QUERY SELECT * FROM storage.search_legacy_v1(prefix, bucketname, limits, levels, offsets, search, sortcolumn, sortorder);
    END IF;
end;
$$;


ALTER FUNCTION storage.search(prefix text, bucketname text, limits integer, levels integer, offsets integer, search text, sortcolumn text, sortorder text) OWNER TO supabase_storage_admin;

--
-- Name: search_legacy_v1(text, text, integer, integer, integer, text, text, text); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.search_legacy_v1(prefix text, bucketname text, limits integer DEFAULT 100, levels integer DEFAULT 1, offsets integer DEFAULT 0, search text DEFAULT ''::text, sortcolumn text DEFAULT 'name'::text, sortorder text DEFAULT 'asc'::text) RETURNS TABLE(name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone, metadata jsonb)
    LANGUAGE plpgsql STABLE
    AS $_$
declare
    v_order_by text;
    v_sort_order text;
begin
    case
        when sortcolumn = 'name' then
            v_order_by = 'name';
        when sortcolumn = 'updated_at' then
            v_order_by = 'updated_at';
        when sortcolumn = 'created_at' then
            v_order_by = 'created_at';
        when sortcolumn = 'last_accessed_at' then
            v_order_by = 'last_accessed_at';
        else
            v_order_by = 'name';
        end case;

    case
        when sortorder = 'asc' then
            v_sort_order = 'asc';
        when sortorder = 'desc' then
            v_sort_order = 'desc';
        else
            v_sort_order = 'asc';
        end case;

    v_order_by = v_order_by || ' ' || v_sort_order;

    return query execute
        'with folders as (
           select path_tokens[$1] as folder
           from storage.objects
             where objects.name ilike $2 || $3 || ''%''
               and bucket_id = $4
               and array_length(objects.path_tokens, 1) <> $1
           group by folder
           order by folder ' || v_sort_order || '
     )
     (select folder as "name",
            null as id,
            null as updated_at,
            null as created_at,
            null as last_accessed_at,
            null as metadata from folders)
     union all
     (select path_tokens[$1] as "name",
            id,
            updated_at,
            created_at,
            last_accessed_at,
            metadata
     from storage.objects
     where objects.name ilike $2 || $3 || ''%''
       and bucket_id = $4
       and array_length(objects.path_tokens, 1) = $1
     order by ' || v_order_by || ')
     limit $5
     offset $6' using levels, prefix, search, bucketname, limits, offsets;
end;
$_$;


ALTER FUNCTION storage.search_legacy_v1(prefix text, bucketname text, limits integer, levels integer, offsets integer, search text, sortcolumn text, sortorder text) OWNER TO supabase_storage_admin;

--
-- Name: search_v1_optimised(text, text, integer, integer, integer, text, text, text); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.search_v1_optimised(prefix text, bucketname text, limits integer DEFAULT 100, levels integer DEFAULT 1, offsets integer DEFAULT 0, search text DEFAULT ''::text, sortcolumn text DEFAULT 'name'::text, sortorder text DEFAULT 'asc'::text) RETURNS TABLE(name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone, metadata jsonb)
    LANGUAGE plpgsql STABLE
    AS $_$
declare
    v_order_by text;
    v_sort_order text;
begin
    case
        when sortcolumn = 'name' then
            v_order_by = 'name';
        when sortcolumn = 'updated_at' then
            v_order_by = 'updated_at';
        when sortcolumn = 'created_at' then
            v_order_by = 'created_at';
        when sortcolumn = 'last_accessed_at' then
            v_order_by = 'last_accessed_at';
        else
            v_order_by = 'name';
        end case;

    case
        when sortorder = 'asc' then
            v_sort_order = 'asc';
        when sortorder = 'desc' then
            v_sort_order = 'desc';
        else
            v_sort_order = 'asc';
        end case;

    v_order_by = v_order_by || ' ' || v_sort_order;

    return query execute
        'with folders as (
           select (string_to_array(name, ''/''))[level] as name
           from storage.prefixes
             where lower(prefixes.name) like lower($2 || $3) || ''%''
               and bucket_id = $4
               and level = $1
           order by name ' || v_sort_order || '
     )
     (select name,
            null as id,
            null as updated_at,
            null as created_at,
            null as last_accessed_at,
            null as metadata from folders)
     union all
     (select path_tokens[level] as "name",
            id,
            updated_at,
            created_at,
            last_accessed_at,
            metadata
     from storage.objects
     where lower(objects.name) like lower($2 || $3) || ''%''
       and bucket_id = $4
       and level = $1
     order by ' || v_order_by || ')
     limit $5
     offset $6' using levels, prefix, search, bucketname, limits, offsets;
end;
$_$;


ALTER FUNCTION storage.search_v1_optimised(prefix text, bucketname text, limits integer, levels integer, offsets integer, search text, sortcolumn text, sortorder text) OWNER TO supabase_storage_admin;

--
-- Name: search_v2(text, text, integer, integer, text); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.search_v2(prefix text, bucket_name text, limits integer DEFAULT 100, levels integer DEFAULT 1, start_after text DEFAULT ''::text) RETURNS TABLE(key text, name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, metadata jsonb)
    LANGUAGE plpgsql STABLE
    AS $_$
BEGIN
    RETURN query EXECUTE
        $sql$
        SELECT * FROM (
            (
                SELECT
                    split_part(name, '/', $4) AS key,
                    name || '/' AS name,
                    NULL::uuid AS id,
                    NULL::timestamptz AS updated_at,
                    NULL::timestamptz AS created_at,
                    NULL::jsonb AS metadata
                FROM storage.prefixes
                WHERE name COLLATE "C" LIKE $1 || '%'
                AND bucket_id = $2
                AND level = $4
                AND name COLLATE "C" > $5
                ORDER BY prefixes.name COLLATE "C" LIMIT $3
            )
            UNION ALL
            (SELECT split_part(name, '/', $4) AS key,
                name,
                id,
                updated_at,
                created_at,
                metadata
            FROM storage.objects
            WHERE name COLLATE "C" LIKE $1 || '%'
                AND bucket_id = $2
                AND level = $4
                AND name COLLATE "C" > $5
            ORDER BY name COLLATE "C" LIMIT $3)
        ) obj
        ORDER BY name COLLATE "C" LIMIT $3;
        $sql$
        USING prefix, bucket_name, limits, levels, start_after;
END;
$_$;


ALTER FUNCTION storage.search_v2(prefix text, bucket_name text, limits integer, levels integer, start_after text) OWNER TO supabase_storage_admin;

--
-- Name: update_updated_at_column(); Type: FUNCTION; Schema: storage; Owner: supabase_storage_admin
--

CREATE FUNCTION storage.update_updated_at_column() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = now();
    RETURN NEW; 
END;
$$;


ALTER FUNCTION storage.update_updated_at_column() OWNER TO supabase_storage_admin;

--
-- Name: http_request(); Type: FUNCTION; Schema: supabase_functions; Owner: supabase_functions_admin
--

CREATE FUNCTION supabase_functions.http_request() RETURNS trigger
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO 'supabase_functions'
    AS $$
    DECLARE
      request_id bigint;
      payload jsonb;
      url text := TG_ARGV[0]::text;
      method text := TG_ARGV[1]::text;
      headers jsonb DEFAULT '{}'::jsonb;
      params jsonb DEFAULT '{}'::jsonb;
      timeout_ms integer DEFAULT 1000;
    BEGIN
      IF url IS NULL OR url = 'null' THEN
        RAISE EXCEPTION 'url argument is missing';
      END IF;

      IF method IS NULL OR method = 'null' THEN
        RAISE EXCEPTION 'method argument is missing';
      END IF;

      IF TG_ARGV[2] IS NULL OR TG_ARGV[2] = 'null' THEN
        headers = '{"Content-Type": "application/json"}'::jsonb;
      ELSE
        headers = TG_ARGV[2]::jsonb;
      END IF;

      IF TG_ARGV[3] IS NULL OR TG_ARGV[3] = 'null' THEN
        params = '{}'::jsonb;
      ELSE
        params = TG_ARGV[3]::jsonb;
      END IF;

      IF TG_ARGV[4] IS NULL OR TG_ARGV[4] = 'null' THEN
        timeout_ms = 1000;
      ELSE
        timeout_ms = TG_ARGV[4]::integer;
      END IF;

      CASE
        WHEN method = 'GET' THEN
          SELECT http_get INTO request_id FROM net.http_get(
            url,
            params,
            headers,
            timeout_ms
          );
        WHEN method = 'POST' THEN
          payload = jsonb_build_object(
            'old_record', OLD,
            'record', NEW,
            'type', TG_OP,
            'table', TG_TABLE_NAME,
            'schema', TG_TABLE_SCHEMA
          );

          SELECT http_post INTO request_id FROM net.http_post(
            url,
            payload,
            params,
            headers,
            timeout_ms
          );
        ELSE
          RAISE EXCEPTION 'method argument % is invalid', method;
      END CASE;

      INSERT INTO supabase_functions.hooks
        (hook_table_id, hook_name, request_id)
      VALUES
        (TG_RELID, TG_NAME, request_id);

      RETURN NEW;
    END
  $$;


ALTER FUNCTION supabase_functions.http_request() OWNER TO supabase_functions_admin;

SET default_tablespace = '';

SET default_table_access_method = heap;

--
-- Name: extensions; Type: TABLE; Schema: _realtime; Owner: supabase_admin
--

CREATE TABLE _realtime.extensions (
    id uuid NOT NULL,
    type text,
    settings jsonb,
    tenant_external_id text,
    inserted_at timestamp(0) without time zone NOT NULL,
    updated_at timestamp(0) without time zone NOT NULL
);


ALTER TABLE _realtime.extensions OWNER TO supabase_admin;

--
-- Name: schema_migrations; Type: TABLE; Schema: _realtime; Owner: supabase_admin
--

CREATE TABLE _realtime.schema_migrations (
    version bigint NOT NULL,
    inserted_at timestamp(0) without time zone
);


ALTER TABLE _realtime.schema_migrations OWNER TO supabase_admin;

--
-- Name: tenants; Type: TABLE; Schema: _realtime; Owner: supabase_admin
--

CREATE TABLE _realtime.tenants (
    id uuid NOT NULL,
    name text,
    external_id text,
    jwt_secret text,
    max_concurrent_users integer DEFAULT 200 NOT NULL,
    inserted_at timestamp(0) without time zone NOT NULL,
    updated_at timestamp(0) without time zone NOT NULL,
    max_events_per_second integer DEFAULT 100 NOT NULL,
    postgres_cdc_default text DEFAULT 'postgres_cdc_rls'::text,
    max_bytes_per_second integer DEFAULT 100000 NOT NULL,
    max_channels_per_client integer DEFAULT 100 NOT NULL,
    max_joins_per_second integer DEFAULT 500 NOT NULL,
    suspend boolean DEFAULT false,
    jwt_jwks jsonb,
    notify_private_alpha boolean DEFAULT false,
    private_only boolean DEFAULT false NOT NULL
);


ALTER TABLE _realtime.tenants OWNER TO supabase_admin;

--
-- Name: audit_log_entries; Type: TABLE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TABLE auth.audit_log_entries (
    instance_id uuid,
    id uuid NOT NULL,
    payload json,
    created_at timestamp with time zone,
    ip_address character varying(64) DEFAULT ''::character varying NOT NULL
);


ALTER TABLE auth.audit_log_entries OWNER TO supabase_auth_admin;

--
-- Name: TABLE audit_log_entries; Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON TABLE auth.audit_log_entries IS 'Auth: Audit trail for user actions.';


--
-- Name: flow_state; Type: TABLE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TABLE auth.flow_state (
    id uuid NOT NULL,
    user_id uuid,
    auth_code text NOT NULL,
    code_challenge_method auth.code_challenge_method NOT NULL,
    code_challenge text NOT NULL,
    provider_type text NOT NULL,
    provider_access_token text,
    provider_refresh_token text,
    created_at timestamp with time zone,
    updated_at timestamp with time zone,
    authentication_method text NOT NULL,
    auth_code_issued_at timestamp with time zone
);


ALTER TABLE auth.flow_state OWNER TO supabase_auth_admin;

--
-- Name: TABLE flow_state; Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON TABLE auth.flow_state IS 'stores metadata for pkce logins';


--
-- Name: identities; Type: TABLE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TABLE auth.identities (
    provider_id text NOT NULL,
    user_id uuid NOT NULL,
    identity_data jsonb NOT NULL,
    provider text NOT NULL,
    last_sign_in_at timestamp with time zone,
    created_at timestamp with time zone,
    updated_at timestamp with time zone,
    email text GENERATED ALWAYS AS (lower((identity_data ->> 'email'::text))) STORED,
    id uuid DEFAULT gen_random_uuid() NOT NULL
);


ALTER TABLE auth.identities OWNER TO supabase_auth_admin;

--
-- Name: TABLE identities; Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON TABLE auth.identities IS 'Auth: Stores identities associated to a user.';


--
-- Name: COLUMN identities.email; Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON COLUMN auth.identities.email IS 'Auth: Email is a generated column that references the optional email property in the identity_data';


--
-- Name: instances; Type: TABLE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TABLE auth.instances (
    id uuid NOT NULL,
    uuid uuid,
    raw_base_config text,
    created_at timestamp with time zone,
    updated_at timestamp with time zone
);


ALTER TABLE auth.instances OWNER TO supabase_auth_admin;

--
-- Name: TABLE instances; Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON TABLE auth.instances IS 'Auth: Manages users across multiple sites.';


--
-- Name: mfa_amr_claims; Type: TABLE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TABLE auth.mfa_amr_claims (
    session_id uuid NOT NULL,
    created_at timestamp with time zone NOT NULL,
    updated_at timestamp with time zone NOT NULL,
    authentication_method text NOT NULL,
    id uuid NOT NULL
);


ALTER TABLE auth.mfa_amr_claims OWNER TO supabase_auth_admin;

--
-- Name: TABLE mfa_amr_claims; Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON TABLE auth.mfa_amr_claims IS 'auth: stores authenticator method reference claims for multi factor authentication';


--
-- Name: mfa_challenges; Type: TABLE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TABLE auth.mfa_challenges (
    id uuid NOT NULL,
    factor_id uuid NOT NULL,
    created_at timestamp with time zone NOT NULL,
    verified_at timestamp with time zone,
    ip_address inet NOT NULL,
    otp_code text,
    web_authn_session_data jsonb
);


ALTER TABLE auth.mfa_challenges OWNER TO supabase_auth_admin;

--
-- Name: TABLE mfa_challenges; Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON TABLE auth.mfa_challenges IS 'auth: stores metadata about challenge requests made';


--
-- Name: mfa_factors; Type: TABLE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TABLE auth.mfa_factors (
    id uuid NOT NULL,
    user_id uuid NOT NULL,
    friendly_name text,
    factor_type auth.factor_type NOT NULL,
    status auth.factor_status NOT NULL,
    created_at timestamp with time zone NOT NULL,
    updated_at timestamp with time zone NOT NULL,
    secret text,
    phone text,
    last_challenged_at timestamp with time zone,
    web_authn_credential jsonb,
    web_authn_aaguid uuid
);


ALTER TABLE auth.mfa_factors OWNER TO supabase_auth_admin;

--
-- Name: TABLE mfa_factors; Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON TABLE auth.mfa_factors IS 'auth: stores metadata about factors';


--
-- Name: one_time_tokens; Type: TABLE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TABLE auth.one_time_tokens (
    id uuid NOT NULL,
    user_id uuid NOT NULL,
    token_type auth.one_time_token_type NOT NULL,
    token_hash text NOT NULL,
    relates_to text NOT NULL,
    created_at timestamp without time zone DEFAULT now() NOT NULL,
    updated_at timestamp without time zone DEFAULT now() NOT NULL,
    CONSTRAINT one_time_tokens_token_hash_check CHECK ((char_length(token_hash) > 0))
);


ALTER TABLE auth.one_time_tokens OWNER TO supabase_auth_admin;

--
-- Name: refresh_tokens; Type: TABLE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TABLE auth.refresh_tokens (
    instance_id uuid,
    id bigint NOT NULL,
    token character varying(255),
    user_id character varying(255),
    revoked boolean,
    created_at timestamp with time zone,
    updated_at timestamp with time zone,
    parent character varying(255),
    session_id uuid
);


ALTER TABLE auth.refresh_tokens OWNER TO supabase_auth_admin;

--
-- Name: TABLE refresh_tokens; Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON TABLE auth.refresh_tokens IS 'Auth: Store of tokens used to refresh JWT tokens once they expire.';


--
-- Name: refresh_tokens_id_seq; Type: SEQUENCE; Schema: auth; Owner: supabase_auth_admin
--

CREATE SEQUENCE auth.refresh_tokens_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE auth.refresh_tokens_id_seq OWNER TO supabase_auth_admin;

--
-- Name: refresh_tokens_id_seq; Type: SEQUENCE OWNED BY; Schema: auth; Owner: supabase_auth_admin
--

ALTER SEQUENCE auth.refresh_tokens_id_seq OWNED BY auth.refresh_tokens.id;


--
-- Name: saml_providers; Type: TABLE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TABLE auth.saml_providers (
    id uuid NOT NULL,
    sso_provider_id uuid NOT NULL,
    entity_id text NOT NULL,
    metadata_xml text NOT NULL,
    metadata_url text,
    attribute_mapping jsonb,
    created_at timestamp with time zone,
    updated_at timestamp with time zone,
    name_id_format text,
    CONSTRAINT "entity_id not empty" CHECK ((char_length(entity_id) > 0)),
    CONSTRAINT "metadata_url not empty" CHECK (((metadata_url = NULL::text) OR (char_length(metadata_url) > 0))),
    CONSTRAINT "metadata_xml not empty" CHECK ((char_length(metadata_xml) > 0))
);


ALTER TABLE auth.saml_providers OWNER TO supabase_auth_admin;

--
-- Name: TABLE saml_providers; Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON TABLE auth.saml_providers IS 'Auth: Manages SAML Identity Provider connections.';


--
-- Name: saml_relay_states; Type: TABLE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TABLE auth.saml_relay_states (
    id uuid NOT NULL,
    sso_provider_id uuid NOT NULL,
    request_id text NOT NULL,
    for_email text,
    redirect_to text,
    created_at timestamp with time zone,
    updated_at timestamp with time zone,
    flow_state_id uuid,
    CONSTRAINT "request_id not empty" CHECK ((char_length(request_id) > 0))
);


ALTER TABLE auth.saml_relay_states OWNER TO supabase_auth_admin;

--
-- Name: TABLE saml_relay_states; Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON TABLE auth.saml_relay_states IS 'Auth: Contains SAML Relay State information for each Service Provider initiated login.';


--
-- Name: schema_migrations; Type: TABLE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TABLE auth.schema_migrations (
    version character varying(255) NOT NULL
);


ALTER TABLE auth.schema_migrations OWNER TO supabase_auth_admin;

--
-- Name: TABLE schema_migrations; Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON TABLE auth.schema_migrations IS 'Auth: Manages updates to the auth system.';


--
-- Name: sessions; Type: TABLE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TABLE auth.sessions (
    id uuid NOT NULL,
    user_id uuid NOT NULL,
    created_at timestamp with time zone,
    updated_at timestamp with time zone,
    factor_id uuid,
    aal auth.aal_level,
    not_after timestamp with time zone,
    refreshed_at timestamp without time zone,
    user_agent text,
    ip inet,
    tag text
);


ALTER TABLE auth.sessions OWNER TO supabase_auth_admin;

--
-- Name: TABLE sessions; Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON TABLE auth.sessions IS 'Auth: Stores session data associated to a user.';


--
-- Name: COLUMN sessions.not_after; Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON COLUMN auth.sessions.not_after IS 'Auth: Not after is a nullable column that contains a timestamp after which the session should be regarded as expired.';


--
-- Name: sso_domains; Type: TABLE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TABLE auth.sso_domains (
    id uuid NOT NULL,
    sso_provider_id uuid NOT NULL,
    domain text NOT NULL,
    created_at timestamp with time zone,
    updated_at timestamp with time zone,
    CONSTRAINT "domain not empty" CHECK ((char_length(domain) > 0))
);


ALTER TABLE auth.sso_domains OWNER TO supabase_auth_admin;

--
-- Name: TABLE sso_domains; Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON TABLE auth.sso_domains IS 'Auth: Manages SSO email address domain mapping to an SSO Identity Provider.';


--
-- Name: sso_providers; Type: TABLE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TABLE auth.sso_providers (
    id uuid NOT NULL,
    resource_id text,
    created_at timestamp with time zone,
    updated_at timestamp with time zone,
    CONSTRAINT "resource_id not empty" CHECK (((resource_id = NULL::text) OR (char_length(resource_id) > 0)))
);


ALTER TABLE auth.sso_providers OWNER TO supabase_auth_admin;

--
-- Name: TABLE sso_providers; Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON TABLE auth.sso_providers IS 'Auth: Manages SSO identity provider information; see saml_providers for SAML.';


--
-- Name: COLUMN sso_providers.resource_id; Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON COLUMN auth.sso_providers.resource_id IS 'Auth: Uniquely identifies a SSO provider according to a user-chosen resource ID (case insensitive), useful in infrastructure as code.';


--
-- Name: users; Type: TABLE; Schema: auth; Owner: supabase_auth_admin
--

CREATE TABLE auth.users (
    instance_id uuid,
    id uuid NOT NULL,
    aud character varying(255),
    role character varying(255),
    email character varying(255),
    encrypted_password character varying(255),
    email_confirmed_at timestamp with time zone,
    invited_at timestamp with time zone,
    confirmation_token character varying(255),
    confirmation_sent_at timestamp with time zone,
    recovery_token character varying(255),
    recovery_sent_at timestamp with time zone,
    email_change_token_new character varying(255),
    email_change character varying(255),
    email_change_sent_at timestamp with time zone,
    last_sign_in_at timestamp with time zone,
    raw_app_meta_data jsonb,
    raw_user_meta_data jsonb,
    is_super_admin boolean,
    created_at timestamp with time zone,
    updated_at timestamp with time zone,
    phone text DEFAULT NULL::character varying,
    phone_confirmed_at timestamp with time zone,
    phone_change text DEFAULT ''::character varying,
    phone_change_token character varying(255) DEFAULT ''::character varying,
    phone_change_sent_at timestamp with time zone,
    confirmed_at timestamp with time zone GENERATED ALWAYS AS (LEAST(email_confirmed_at, phone_confirmed_at)) STORED,
    email_change_token_current character varying(255) DEFAULT ''::character varying,
    email_change_confirm_status smallint DEFAULT 0,
    banned_until timestamp with time zone,
    reauthentication_token character varying(255) DEFAULT ''::character varying,
    reauthentication_sent_at timestamp with time zone,
    is_sso_user boolean DEFAULT false NOT NULL,
    deleted_at timestamp with time zone,
    is_anonymous boolean DEFAULT false NOT NULL,
    CONSTRAINT users_email_change_confirm_status_check CHECK (((email_change_confirm_status >= 0) AND (email_change_confirm_status <= 2)))
);


ALTER TABLE auth.users OWNER TO supabase_auth_admin;

--
-- Name: TABLE users; Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON TABLE auth.users IS 'Auth: Stores user login data within a secure schema.';


--
-- Name: COLUMN users.is_sso_user; Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON COLUMN auth.users.is_sso_user IS 'Auth: Set this column to true when the account comes from SSO. These accounts can have duplicate emails.';


--
-- Name: bulletin_post_users; Type: TABLE; Schema: public; Owner: supabase_admin
--

CREATE TABLE public.bulletin_post_users (
    post_id uuid NOT NULL,
    user_id uuid NOT NULL,
    school_id uuid NOT NULL
);


ALTER TABLE public.bulletin_post_users OWNER TO supabase_admin;

--
-- Name: bulletin_posts; Type: TABLE; Schema: public; Owner: supabase_admin
--

CREATE TABLE public.bulletin_posts (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    school_id uuid NOT NULL,
    title text NOT NULL,
    body text NOT NULL,
    attachments text[] DEFAULT '{}'::text[],
    display_from timestamp without time zone DEFAULT now() NOT NULL,
    notify_on_post boolean DEFAULT false,
    is_recurring boolean DEFAULT false,
    created_by uuid NOT NULL,
    created_at timestamp without time zone DEFAULT now(),
    visible_groups uuid[] DEFAULT '{}'::uuid[],
    read_required boolean DEFAULT false NOT NULL,
    recurrence_id uuid,
    is_important boolean DEFAULT false NOT NULL
);


ALTER TABLE public.bulletin_posts OWNER TO supabase_admin;

--
-- Name: bulletin_recurrences; Type: TABLE; Schema: public; Owner: supabase_admin
--

CREATE TABLE public.bulletin_recurrences (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    start_date timestamp without time zone NOT NULL,
    end_date timestamp without time zone NOT NULL,
    repeat_every_unit text NOT NULL,
    repeat_every_number smallint NOT NULL,
    week_days smallint[],
    monthly_text text,
    original_post_id uuid NOT NULL,
    school_id uuid NOT NULL
);


ALTER TABLE public.bulletin_recurrences OWNER TO supabase_admin;

--
-- Name: change_log; Type: TABLE; Schema: public; Owner: supabase_admin
--

CREATE TABLE public.change_log (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    change_group_id uuid,
    user_id uuid NOT NULL,
    school_id uuid,
    table_name text NOT NULL,
    record_id uuid NOT NULL,
    action_type text NOT NULL,
    before_data jsonb,
    after_data jsonb,
    reason text,
    created_at timestamp without time zone DEFAULT now() NOT NULL,
    is_undone boolean DEFAULT false,
    undone_by uuid,
    undone_at timestamp without time zone,
    source text DEFAULT 'manual'::text,
    CONSTRAINT change_log_action_type_check CHECK ((action_type = ANY (ARRAY['insert'::text, 'update'::text, 'soft_delete'::text, 'hard_delete'::text, 'undo'::text])))
);


ALTER TABLE public.change_log OWNER TO supabase_admin;

--
-- Name: contacts; Type: TABLE; Schema: public; Owner: supabase_admin
--

CREATE TABLE public.contacts (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    profile_id uuid NOT NULL,
    profile_type text NOT NULL,
    type text NOT NULL,
    label text,
    value text NOT NULL,
    is_primary boolean DEFAULT false,
    notes text,
    status text DEFAULT 'valid'::text,
    created_at timestamp without time zone DEFAULT now(),
    is_linked_to_user_login boolean DEFAULT false NOT NULL,
    school_id uuid NOT NULL,
    CONSTRAINT contacts_status_check CHECK ((status = ANY (ARRAY['valid'::text, 'invalid'::text, 'archived'::text])))
);


ALTER TABLE public.contacts OWNER TO supabase_admin;

--
-- Name: course_allocation_drafts; Type: TABLE; Schema: public; Owner: supabase_admin
--

CREATE TABLE public.course_allocation_drafts (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    registration_period_id uuid NOT NULL,
    day_id integer NOT NULL,
    student_id uuid NOT NULL,
    target_course_id uuid,
    special_target text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_by uuid,
    school_id uuid NOT NULL,
    semester_id uuid NOT NULL,
    day_of_week smallint NOT NULL,
    CONSTRAINT cad_day_of_week_check CHECK (((day_of_week >= 1) AND (day_of_week <= 5))),
    CONSTRAINT cad_exactly_one_target CHECK ((((target_course_id IS NOT NULL) AND (special_target IS NULL)) OR ((target_course_id IS NULL) AND (special_target IS NOT NULL)))),
    CONSTRAINT course_allocation_drafts_special_target_check CHECK ((special_target = ANY (ARRAY['waiting'::text, 'go-home'::text])))
);


ALTER TABLE public.course_allocation_drafts OWNER TO supabase_admin;

--
-- Name: course_applications; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.course_applications (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    student_id uuid,
    course_id uuid,
    priority integer,
    school_id uuid NOT NULL,
    window_id uuid,
    registration_period_id uuid NOT NULL,
    semester_id uuid NOT NULL,
    day_of_week smallint,
    rank smallint,
    status text DEFAULT 'pending'::text NOT NULL,
    source text DEFAULT 'interview'::text NOT NULL,
    applied_at timestamp with time zone,
    created_by uuid,
    CONSTRAINT applications_priority_check CHECK (((priority >= 1) AND (priority <= 3))),
    CONSTRAINT course_applications_day_of_week_check CHECK (((day_of_week >= 1) AND (day_of_week <= 5))),
    CONSTRAINT course_applications_rank_check CHECK (((rank >= 1) AND (rank <= 10)))
);


ALTER TABLE public.course_applications OWNER TO postgres;

--
-- Name: course_enrollments; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.course_enrollments (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    student_id uuid,
    course_id uuid,
    assigned_at timestamp without time zone DEFAULT now(),
    school_id uuid NOT NULL,
    schedule_ids uuid[] DEFAULT '{}'::uuid[],
    is_trial boolean DEFAULT false,
    start_date date DEFAULT CURRENT_DATE NOT NULL,
    end_date date DEFAULT (CURRENT_DATE + '90 days'::interval) NOT NULL,
    CONSTRAINT enrollment_dates_valid CHECK ((start_date <= end_date))
);


ALTER TABLE public.course_enrollments OWNER TO postgres;

--
-- Name: course_lessons; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.course_lessons (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    course_id uuid,
    is_cancelled boolean DEFAULT false,
    notes text,
    school_id uuid NOT NULL,
    is_generated boolean DEFAULT true,
    teacher_ids uuid[] DEFAULT ARRAY[]::uuid[] NOT NULL,
    schedule_id uuid,
    start_datetime timestamp without time zone NOT NULL,
    end_datetime timestamp without time zone NOT NULL,
    period_id uuid,
    period_ids uuid[],
    period_count integer,
    room_id uuid,
    subject_id uuid,
    class_id uuid,
    is_lesson_based boolean DEFAULT false,
    meeting_name text,
    primary_teacher_id uuid,
    replaced_by_lesson_id uuid,
    replacing_lesson_id uuid,
    replaces_lesson_id uuid,
    is_archived boolean DEFAULT false
);


ALTER TABLE public.course_lessons OWNER TO postgres;

--
-- Name: course_list; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.course_list (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    school_id uuid NOT NULL,
    name text NOT NULL,
    max_students integer,
    start_date date,
    end_date date,
    is_active boolean DEFAULT true,
    course_code text,
    is_for_year_g integer[],
    description text,
    pictures text[] DEFAULT ARRAY[]::text[],
    wichtige_infos text,
    subject_id uuid,
    is_open_course boolean DEFAULT false NOT NULL,
    description_visible_to_parents boolean DEFAULT false NOT NULL,
    possible_staff_members uuid[],
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    possible_room_id uuid
);


ALTER TABLE public.course_list OWNER TO postgres;

--
-- Name: course_notes; Type: TABLE; Schema: public; Owner: supabase_admin
--

CREATE TABLE public.course_notes (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    course_id text NOT NULL,
    school_id text NOT NULL,
    registration_period_id text NOT NULL,
    semester_id text NOT NULL,
    day_of_week integer NOT NULL,
    text text NOT NULL,
    author text DEFAULT 'Admin'::text NOT NULL,
    is_problem boolean DEFAULT false,
    is_resolved boolean DEFAULT false,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    resolved_at timestamp with time zone,
    resolved_by text
);


ALTER TABLE public.course_notes OWNER TO supabase_admin;

--
-- Name: course_offers; Type: TABLE; Schema: public; Owner: supabase_admin
--

CREATE TABLE public.course_offers (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    school_id uuid NOT NULL,
    proposed_by uuid NOT NULL,
    name text NOT NULL,
    max_students integer,
    is_for_year_g integer[],
    description text,
    pictures text[] DEFAULT ARRAY[]::text[],
    wichtige_infos text,
    description_visible_to_parents boolean DEFAULT false NOT NULL,
    possible_team_members text,
    status text DEFAULT 'pending'::text NOT NULL,
    approved_by uuid,
    approved_at timestamp with time zone,
    approver_comments text,
    rejection_reason text,
    converted_to_course_id uuid,
    auto_convert_on_approval boolean DEFAULT true,
    proposed_start_date date,
    proposed_duration_weeks integer,
    proposer_notes text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT check_approval_fields CHECK ((((status = 'approved'::text) AND (approved_by IS NOT NULL) AND (approved_at IS NOT NULL)) OR ((status = 'rejected'::text) AND (approved_by IS NOT NULL) AND (approved_at IS NOT NULL)) OR (status = ANY (ARRAY['pending'::text, 'withdrawn'::text])))),
    CONSTRAINT check_converted_course CHECK ((((status = 'approved'::text) AND (converted_to_course_id IS NOT NULL)) OR ((status <> 'approved'::text) AND (converted_to_course_id IS NULL)) OR (auto_convert_on_approval = false))),
    CONSTRAINT course_offers_status_check CHECK ((status = ANY (ARRAY['pending'::text, 'approved'::text, 'rejected'::text, 'withdrawn'::text])))
);


ALTER TABLE public.course_offers OWNER TO supabase_admin;

--
-- Name: course_possible_times; Type: TABLE; Schema: public; Owner: supabase_admin
--

CREATE TABLE public.course_possible_times (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    course_id uuid NOT NULL,
    weekday smallint NOT NULL,
    schedule_period_id uuid NOT NULL,
    school_id uuid NOT NULL,
    is_custom_time boolean DEFAULT false NOT NULL,
    custom_start time without time zone,
    custom_duration interval,
    created_by uuid,
    CONSTRAINT course_possible_times_weekday_check CHECK (((weekday >= 1) AND (weekday <= 6)))
);


ALTER TABLE public.course_possible_times OWNER TO supabase_admin;

--
-- Name: course_registration_windows; Type: TABLE; Schema: public; Owner: supabase_admin
--

CREATE TABLE public.course_registration_windows (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    school_id uuid NOT NULL,
    course_id uuid NOT NULL,
    semester_id uuid NOT NULL,
    opens_at timestamp with time zone NOT NULL,
    closes_at timestamp with time zone NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    created_by uuid NOT NULL,
    registration_period_id uuid NOT NULL,
    grade_levels integer[],
    CONSTRAINT course_registration_windows_dates_check CHECK ((closes_at > opens_at))
);


ALTER TABLE public.course_registration_windows OWNER TO supabase_admin;

--
-- Name: TABLE course_registration_windows; Type: COMMENT; Schema: public; Owner: supabase_admin
--

COMMENT ON TABLE public.course_registration_windows IS 'Controls registration windows for courses. Multiple windows per course/semester are allowed to support rolling registration waves.';


--
-- Name: COLUMN course_registration_windows.school_id; Type: COMMENT; Schema: public; Owner: supabase_admin
--

COMMENT ON COLUMN public.course_registration_windows.school_id IS 'Reference to the school offering the course';


--
-- Name: COLUMN course_registration_windows.course_id; Type: COMMENT; Schema: public; Owner: supabase_admin
--

COMMENT ON COLUMN public.course_registration_windows.course_id IS 'Reference to the course being offered for registration';


--
-- Name: COLUMN course_registration_windows.semester_id; Type: COMMENT; Schema: public; Owner: supabase_admin
--

COMMENT ON COLUMN public.course_registration_windows.semester_id IS 'Reference to the semester when the course runs';


--
-- Name: COLUMN course_registration_windows.opens_at; Type: COMMENT; Schema: public; Owner: supabase_admin
--

COMMENT ON COLUMN public.course_registration_windows.opens_at IS 'When registration window opens (inclusive)';


--
-- Name: COLUMN course_registration_windows.closes_at; Type: COMMENT; Schema: public; Owner: supabase_admin
--

COMMENT ON COLUMN public.course_registration_windows.closes_at IS 'When registration window closes (exclusive)';


--
-- Name: COLUMN course_registration_windows.created_by; Type: COMMENT; Schema: public; Owner: supabase_admin
--

COMMENT ON COLUMN public.course_registration_windows.created_by IS 'Admin/user who opened this registration window';


--
-- Name: course_schedules; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.course_schedules (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    course_id uuid,
    start_time time without time zone NOT NULL,
    end_time time without time zone NOT NULL,
    start_date date NOT NULL,
    end_date date NOT NULL,
    room_id uuid,
    school_id uuid NOT NULL,
    created_at timestamp without time zone DEFAULT now(),
    teacher_ids uuid[] DEFAULT ARRAY[]::uuid[],
    valid_from date DEFAULT CURRENT_DATE NOT NULL,
    valid_until date DEFAULT (CURRENT_DATE + '90 days'::interval) NOT NULL,
    day_id integer,
    period_id uuid,
    period_ids uuid[],
    subject_id uuid,
    class_id uuid,
    meeting_name text,
    notes text,
    primary_teacher_id uuid,
    is_archived boolean DEFAULT false,
    updated_at timestamp with time zone DEFAULT now()
);


ALTER TABLE public.course_schedules OWNER TO postgres;

--
-- Name: debug_logs; Type: TABLE; Schema: public; Owner: supabase_admin
--

CREATE TABLE public.debug_logs (
    id integer NOT NULL,
    message text,
    created_at timestamp without time zone DEFAULT now(),
    step text
);


ALTER TABLE public.debug_logs OWNER TO supabase_admin;

--
-- Name: debug_logs_id_seq; Type: SEQUENCE; Schema: public; Owner: supabase_admin
--

CREATE SEQUENCE public.debug_logs_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE public.debug_logs_id_seq OWNER TO supabase_admin;

--
-- Name: debug_logs_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: supabase_admin
--

ALTER SEQUENCE public.debug_logs_id_seq OWNED BY public.debug_logs.id;


--
-- Name: document_types; Type: TABLE; Schema: public; Owner: supabase_admin
--

CREATE TABLE public.document_types (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    name text NOT NULL,
    description text,
    school_id uuid
);


ALTER TABLE public.document_types OWNER TO supabase_admin;

--
-- Name: families; Type: TABLE; Schema: public; Owner: supabase_admin
--

CREATE TABLE public.families (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    school_id uuid NOT NULL,
    family_code text,
    family_name text,
    created_at timestamp without time zone DEFAULT now(),
    created_by uuid,
    updated_at timestamp without time zone DEFAULT now(),
    updated_by uuid
);


ALTER TABLE public.families OWNER TO supabase_admin;

--
-- Name: family_member_child_links; Type: TABLE; Schema: public; Owner: supabase_admin
--

CREATE TABLE public.family_member_child_links (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    family_id uuid NOT NULL,
    adult_profile_id uuid NOT NULL,
    child_profile_id uuid NOT NULL,
    relationship text,
    access_restricted boolean DEFAULT false,
    notes text,
    created_at timestamp without time zone DEFAULT now(),
    authorized_for_pickup boolean DEFAULT false NOT NULL,
    pickup_priority smallint,
    school_id uuid NOT NULL,
    CONSTRAINT family_member_child_links_pickup_priority_check CHECK ((pickup_priority >= 1))
);


ALTER TABLE public.family_member_child_links OWNER TO supabase_admin;

--
-- Name: COLUMN family_member_child_links.pickup_priority; Type: COMMENT; Schema: public; Owner: supabase_admin
--

COMMENT ON COLUMN public.family_member_child_links.pickup_priority IS 'Call order for pickup contacts per child; 1 denotes the designated primary contact.';


--
-- Name: family_members; Type: TABLE; Schema: public; Owner: supabase_admin
--

CREATE TABLE public.family_members (
    family_id uuid NOT NULL,
    profile_id uuid NOT NULL,
    role text NOT NULL,
    relation_description text,
    is_primary_guardian boolean DEFAULT false,
    is_primary_contact boolean DEFAULT false,
    added_at timestamp without time zone DEFAULT now(),
    added_by uuid,
    removed_at timestamp without time zone,
    removed_by uuid,
    notes text,
    school_id uuid NOT NULL,
    CONSTRAINT family_members_role_check CHECK ((role = ANY (ARRAY['student'::text, 'parent'::text, 'guardian'::text, 'staff'::text, 'other'::text])))
);


ALTER TABLE public.family_members OWNER TO supabase_admin;

--
-- Name: ingest_interview_debug_log; Type: TABLE; Schema: public; Owner: supabase_admin
--

CREATE TABLE public.ingest_interview_debug_log (
    id bigint NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    student_id uuid,
    registration_period_id uuid,
    stage text,
    message text,
    details jsonb
);


ALTER TABLE public.ingest_interview_debug_log OWNER TO supabase_admin;

--
-- Name: ingest_interview_debug_log_id_seq; Type: SEQUENCE; Schema: public; Owner: supabase_admin
--

CREATE SEQUENCE public.ingest_interview_debug_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE public.ingest_interview_debug_log_id_seq OWNER TO supabase_admin;

--
-- Name: ingest_interview_debug_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: supabase_admin
--

ALTER SEQUENCE public.ingest_interview_debug_log_id_seq OWNED BY public.ingest_interview_debug_log.id;


--
-- Name: lesson_diary_entries; Type: TABLE; Schema: public; Owner: supabase_admin
--

CREATE TABLE public.lesson_diary_entries (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    lesson_id uuid NOT NULL,
    school_id uuid NOT NULL,
    entry_text text NOT NULL,
    entry_type text DEFAULT 'general'::text NOT NULL,
    is_private boolean DEFAULT false NOT NULL,
    created_by uuid NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_by uuid,
    CONSTRAINT lesson_diary_entries_entry_type_check CHECK ((entry_type = ANY (ARRAY['general'::text, 'attendance'::text, 'behavior'::text, 'curriculum'::text, 'special_event'::text, 'substitute'::text])))
);


ALTER TABLE public.lesson_diary_entries OWNER TO supabase_admin;

--
-- Name: profile_info_family_member; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.profile_info_family_member (
    profile_id uuid NOT NULL,
    school_id uuid NOT NULL,
    can_log_in boolean DEFAULT false,
    is_primary_guardian boolean DEFAULT false,
    default_relationship text,
    access_notes text,
    created_at timestamp without time zone DEFAULT now(),
    created_by uuid,
    updated_at timestamp without time zone DEFAULT now(),
    updated_by uuid
);


ALTER TABLE public.profile_info_family_member OWNER TO postgres;

--
-- Name: profile_info_staff; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.profile_info_staff (
    profile_id uuid NOT NULL,
    skills text[],
    roles text[],
    school_id uuid NOT NULL,
    status text DEFAULT 'active'::text,
    login_active boolean DEFAULT true,
    last_invited_at timestamp without time zone,
    joined_at date,
    employee_id text,
    kurzung text,
    hours_account integer,
    credit_hours integer,
    age_reduction integer,
    subjects_stud uuid[],
    credit_hours_note text,
    colour text,
    CONSTRAINT profile_info_staff_status_check CHECK ((status = ANY (ARRAY['active'::text, 'on_leave'::text, 'archived'::text])))
);


ALTER TABLE public.profile_info_staff OWNER TO postgres;

--
-- Name: COLUMN profile_info_staff.roles; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.profile_info_staff.roles IS 'I don''t think we need this as it should happen through the user_profile';


--
-- Name: COLUMN profile_info_staff.login_active; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.profile_info_staff.login_active IS 'I don''t think we need this as it should happen through the user_profile';


--
-- Name: COLUMN profile_info_staff.last_invited_at; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.profile_info_staff.last_invited_at IS 'I don''t think we need this as it should happen through the user_profile';


--
-- Name: profile_info_student; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.profile_info_student (
    profile_id uuid NOT NULL,
    class_id uuid,
    date_of_birth date,
    notes text,
    school_id uuid NOT NULL,
    middle_name text,
    nickname text,
    allergies text,
    required_school_times jsonb,
    early_departure_policy text,
    policy_editable_by_parent boolean DEFAULT false,
    policy_last_set_by text,
    policy_last_set_at timestamp with time zone,
    authorized_pickup_ids uuid[] DEFAULT '{}'::uuid[],
    CONSTRAINT profile_info_student_early_departure_policy_check CHECK ((early_departure_policy = ANY (ARRAY['always'::text, 'with_confirmation'::text, 'never'::text]))),
    CONSTRAINT profile_info_student_policy_last_set_by_check CHECK ((policy_last_set_by = ANY (ARRAY['parent'::text, 'admin'::text, 'system'::text])))
);


ALTER TABLE public.profile_info_student OWNER TO postgres;

--
-- Name: protected_roles; Type: TABLE; Schema: public; Owner: supabase_admin
--

CREATE TABLE public.protected_roles (
    role_id uuid NOT NULL,
    protection_level text DEFAULT 'CRITICAL'::text NOT NULL,
    protection_reason text NOT NULL,
    protected_by uuid,
    protected_at timestamp with time zone DEFAULT now(),
    can_be_unprotected boolean DEFAULT false,
    CONSTRAINT protected_roles_protection_level_check CHECK ((protection_level = ANY (ARRAY['CRITICAL'::text, 'IMPORTANT'::text, 'NORMAL'::text])))
);


ALTER TABLE public.protected_roles OWNER TO supabase_admin;

--
-- Name: public_holiday_and_breaks; Type: TABLE; Schema: public; Owner: supabase_admin
--

CREATE TABLE public.public_holiday_and_breaks (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    start_date date NOT NULL,
    end_date date NOT NULL,
    name text NOT NULL,
    type text NOT NULL,
    school_year text NOT NULL,
    is_official boolean DEFAULT true,
    source text DEFAULT 'berlin.de'::text,
    country text DEFAULT 'Germany'::text NOT NULL,
    city text DEFAULT 'Berlin'::text NOT NULL,
    created_at timestamp with time zone DEFAULT now(),
    CONSTRAINT public_holiday_and_breaks_type_check CHECK ((type = ANY (ARRAY['feiertag'::text, 'ferientag'::text, 'unterrichtsfrei'::text])))
);


ALTER TABLE public.public_holiday_and_breaks OWNER TO supabase_admin;

--
-- Name: published_drafts; Type: TABLE; Schema: public; Owner: supabase_admin
--

CREATE TABLE public.published_drafts (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    draft_id uuid NOT NULL,
    school_id uuid NOT NULL,
    semester_id uuid NOT NULL,
    published_by uuid NOT NULL,
    published_at timestamp with time zone DEFAULT now() NOT NULL,
    title text NOT NULL,
    notes text,
    draft_data jsonb NOT NULL,
    status text DEFAULT 'success'::text NOT NULL,
    error_message text,
    lesson_count integer DEFAULT 0 NOT NULL,
    schedule_count integer DEFAULT 0 NOT NULL,
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone DEFAULT now(),
    CONSTRAINT published_drafts_status_check CHECK ((status = ANY (ARRAY['success'::text, 'failed'::text, 'in_progress'::text])))
);


ALTER TABLE public.published_drafts OWNER TO supabase_admin;

--
-- Name: recurrence_debug_log; Type: TABLE; Schema: public; Owner: supabase_admin
--

CREATE TABLE public.recurrence_debug_log (
    id integer NOT NULL,
    recurrence_id uuid,
    function_called text,
    log_time timestamp with time zone DEFAULT now()
);


ALTER TABLE public.recurrence_debug_log OWNER TO supabase_admin;

--
-- Name: recurrence_debug_log_id_seq; Type: SEQUENCE; Schema: public; Owner: supabase_admin
--

CREATE SEQUENCE public.recurrence_debug_log_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE public.recurrence_debug_log_id_seq OWNER TO supabase_admin;

--
-- Name: recurrence_debug_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: supabase_admin
--

ALTER SEQUENCE public.recurrence_debug_log_id_seq OWNED BY public.recurrence_debug_log.id;


--
-- Name: registration_periods; Type: TABLE; Schema: public; Owner: supabase_admin
--

CREATE TABLE public.registration_periods (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    school_id uuid NOT NULL,
    semester_id uuid NOT NULL,
    title text NOT NULL,
    subtitle text,
    instructions text,
    internal_notes text,
    status text DEFAULT 'draft'::text NOT NULL,
    published_at timestamp with time zone,
    opened_at timestamp with time zone,
    closed_at timestamp with time zone,
    created_by_id uuid NOT NULL,
    updated_by_id uuid NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    created_by uuid,
    updated_by uuid,
    max_wishes_total integer,
    max_wishes_per_day integer,
    CONSTRAINT registration_periods_status_check CHECK ((status = ANY (ARRAY['draft'::text, 'scheduled'::text, 'open'::text, 'closed'::text, 'archived'::text]))),
    CONSTRAINT registration_periods_title_not_empty CHECK ((length(TRIM(BOTH FROM title)) > 0)),
    CONSTRAINT registration_periods_wish_limits_check CHECK ((((max_wishes_total IS NULL) OR (max_wishes_total >= 0)) AND ((max_wishes_per_day IS NULL) OR (max_wishes_per_day >= 0))))
);


ALTER TABLE public.registration_periods OWNER TO supabase_admin;

--
-- Name: TABLE registration_periods; Type: COMMENT; Schema: public; Owner: supabase_admin
--

COMMENT ON TABLE public.registration_periods IS 'Higher-level grouping for course registration windows. Allows creating titled registration periods (e.g. "AG registrations for Year 1-4") with descriptions, grade ranges, and lifecycle management.';


--
-- Name: COLUMN registration_periods.school_id; Type: COMMENT; Schema: public; Owner: supabase_admin
--

COMMENT ON COLUMN public.registration_periods.school_id IS 'Reference to the school offering the registration period';


--
-- Name: COLUMN registration_periods.semester_id; Type: COMMENT; Schema: public; Owner: supabase_admin
--

COMMENT ON COLUMN public.registration_periods.semester_id IS 'Reference to the semester when courses in this period run';


--
-- Name: COLUMN registration_periods.title; Type: COMMENT; Schema: public; Owner: supabase_admin
--

COMMENT ON COLUMN public.registration_periods.title IS 'Parent-visible title for the registration period (required)';


--
-- Name: COLUMN registration_periods.subtitle; Type: COMMENT; Schema: public; Owner: supabase_admin
--

COMMENT ON COLUMN public.registration_periods.subtitle IS 'Optional subtitle for additional context';


--
-- Name: COLUMN registration_periods.instructions; Type: COMMENT; Schema: public; Owner: supabase_admin
--

COMMENT ON COLUMN public.registration_periods.instructions IS 'Parent-visible instructions or description text (supports markdown)';


--
-- Name: COLUMN registration_periods.internal_notes; Type: COMMENT; Schema: public; Owner: supabase_admin
--

COMMENT ON COLUMN public.registration_periods.internal_notes IS 'Admin-only notes for internal use';


--
-- Name: COLUMN registration_periods.status; Type: COMMENT; Schema: public; Owner: supabase_admin
--

COMMENT ON COLUMN public.registration_periods.status IS 'Lifecycle status: draft, scheduled, open, closed, archived';


--
-- Name: COLUMN registration_periods.published_at; Type: COMMENT; Schema: public; Owner: supabase_admin
--

COMMENT ON COLUMN public.registration_periods.published_at IS 'Timestamp when first moved from draft to scheduled/open';


--
-- Name: COLUMN registration_periods.opened_at; Type: COMMENT; Schema: public; Owner: supabase_admin
--

COMMENT ON COLUMN public.registration_periods.opened_at IS 'Timestamp when status transitioned to open';


--
-- Name: COLUMN registration_periods.closed_at; Type: COMMENT; Schema: public; Owner: supabase_admin
--

COMMENT ON COLUMN public.registration_periods.closed_at IS 'Timestamp when status transitioned to closed';


--
-- Name: COLUMN registration_periods.created_by_id; Type: COMMENT; Schema: public; Owner: supabase_admin
--

COMMENT ON COLUMN public.registration_periods.created_by_id IS 'User who created this registration period';


--
-- Name: COLUMN registration_periods.updated_by_id; Type: COMMENT; Schema: public; Owner: supabase_admin
--

COMMENT ON COLUMN public.registration_periods.updated_by_id IS 'User who last updated this registration period';


--
-- Name: roles; Type: TABLE; Schema: public; Owner: supabase_admin
--

CREATE TABLE public.roles (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    name text NOT NULL,
    is_subrole boolean DEFAULT false NOT NULL
);


ALTER TABLE public.roles OWNER TO supabase_admin;

--
-- Name: schedule_calendar_exceptions; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.schedule_calendar_exceptions (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    school_id uuid NOT NULL,
    date date NOT NULL,
    type text,
    notes text,
    allow_checkins boolean DEFAULT false,
    source text,
    is_official boolean DEFAULT false,
    end_date date,
    CONSTRAINT calendar_exceptions_type_check CHECK ((type = ANY (ARRAY['holiday'::text, 'school_closed'::text, 'no_courses'::text])))
);


ALTER TABLE public.schedule_calendar_exceptions OWNER TO postgres;

--
-- Name: schedule_daily_rostering; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.schedule_daily_rostering (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    school_id uuid NOT NULL,
    date date NOT NULL,
    staff_id uuid,
    time_block_id uuid,
    start_time time without time zone,
    end_time time without time zone,
    room_id uuid,
    role text,
    substitute_for uuid,
    is_draft boolean DEFAULT true,
    created_at timestamp without time zone DEFAULT now(),
    course_id uuid
);


ALTER TABLE public.schedule_daily_rostering OWNER TO postgres;

--
-- Name: schedule_drafts; Type: TABLE; Schema: public; Owner: supabase_admin
--

CREATE TABLE public.schedule_drafts (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    school_id uuid NOT NULL,
    semester_id uuid NOT NULL,
    created_by uuid NOT NULL,
    created_at timestamp with time zone DEFAULT now(),
    title text NOT NULL,
    notes text,
    current_version jsonb,
    versions jsonb[],
    published_at timestamp with time zone,
    updated_at timestamp with time zone,
    is_live boolean DEFAULT false NOT NULL
);


ALTER TABLE public.schedule_drafts OWNER TO supabase_admin;

--
-- Name: schedule_periods; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.schedule_periods (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    school_id uuid NOT NULL,
    block_number integer NOT NULL,
    start_time time without time zone NOT NULL,
    end_time time without time zone NOT NULL,
    label text NOT NULL,
    group_label text,
    attendance_requirement text DEFAULT 'required'::text NOT NULL,
    block_type text DEFAULT 'instructional'::text NOT NULL,
    created_by uuid,
    CONSTRAINT schedule_periods_attendance_requirement_check CHECK ((attendance_requirement = ANY (ARRAY['required'::text, 'flexible'::text, 'contracted'::text]))),
    CONSTRAINT schedule_periods_block_type_check CHECK ((block_type = ANY (ARRAY['instructional'::text, 'break'::text, 'flex'::text, 'before_school'::text, 'after_school'::text, 'admin'::text, 'custom'::text])))
);


ALTER TABLE public.schedule_periods OWNER TO postgres;

--
-- Name: schema_change_log; Type: TABLE; Schema: public; Owner: supabase_admin
--

CREATE TABLE public.schema_change_log (
    id integer NOT NULL,
    event_type text NOT NULL,
    object_type text NOT NULL,
    object_name text,
    executed_sql text DEFAULT 'SQL NOT AVAILABLE'::text NOT NULL,
    username text,
    session_user_name text,
    event_time timestamp with time zone DEFAULT now(),
    group_id uuid
);


ALTER TABLE public.schema_change_log OWNER TO supabase_admin;

--
-- Name: schema_change_log_id_seq; Type: SEQUENCE; Schema: public; Owner: supabase_admin
--

CREATE SEQUENCE public.schema_change_log_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE public.schema_change_log_id_seq OWNER TO supabase_admin;

--
-- Name: schema_change_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: supabase_admin
--

ALTER SEQUENCE public.schema_change_log_id_seq OWNED BY public.schema_change_log.id;


--
-- Name: staff_absence_comments; Type: TABLE; Schema: public; Owner: supabase_admin
--

CREATE TABLE public.staff_absence_comments (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    absence_id uuid,
    author_id uuid,
    comment text,
    created_at timestamp without time zone DEFAULT now(),
    school_id uuid NOT NULL
);


ALTER TABLE public.staff_absence_comments OWNER TO supabase_admin;

--
-- Name: staff_absences; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.staff_absences (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    staff_id uuid,
    date date NOT NULL,
    reason text,
    notes text,
    created_at timestamp without time zone DEFAULT now(),
    school_id uuid NOT NULL,
    substitution_status text DEFAULT 'pending'::text,
    is_approved boolean DEFAULT false,
    approved_by uuid,
    end_date date,
    start_period integer,
    end_period integer,
    attachment_url text,
    created_by uuid
);


ALTER TABLE public.staff_absences OWNER TO postgres;

--
-- Name: staff_class_links; Type: TABLE; Schema: public; Owner: supabase_admin
--

CREATE TABLE public.staff_class_links (
    staff_id uuid NOT NULL,
    class_id uuid NOT NULL,
    is_class_teacher boolean DEFAULT false,
    role text,
    school_id uuid NOT NULL
);


ALTER TABLE public.staff_class_links OWNER TO supabase_admin;

--
-- Name: staff_contracts; Type: TABLE; Schema: public; Owner: supabase_admin
--

CREATE TABLE public.staff_contracts (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    staff_id uuid NOT NULL,
    school_id uuid NOT NULL,
    contract_start date,
    contract_end date,
    weekly_hours numeric,
    contract_type text,
    contract_file_url text,
    version_number integer DEFAULT 1,
    created_at timestamp without time zone DEFAULT now()
);


ALTER TABLE public.staff_contracts OWNER TO supabase_admin;

--
-- Name: staff_documents; Type: TABLE; Schema: public; Owner: supabase_admin
--

CREATE TABLE public.staff_documents (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    staff_id uuid NOT NULL,
    school_id uuid NOT NULL,
    file_url text NOT NULL,
    document_type text,
    visible_to_staff boolean DEFAULT false,
    uploaded_at timestamp without time zone DEFAULT now(),
    type_id uuid,
    expires_at date
);


ALTER TABLE public.staff_documents OWNER TO supabase_admin;

--
-- Name: staff_duty_plan; Type: TABLE; Schema: public; Owner: supabase_admin
--

CREATE TABLE public.staff_duty_plan (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    staff_id uuid NOT NULL,
    school_id uuid NOT NULL,
    weekday integer NOT NULL,
    start_time time without time zone NOT NULL,
    end_time time without time zone NOT NULL,
    preferred boolean DEFAULT false,
    note text,
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone DEFAULT now(),
    CONSTRAINT staff_duty_plan_weekday_check CHECK (((weekday >= 0) AND (weekday <= 6)))
);


ALTER TABLE public.staff_duty_plan OWNER TO supabase_admin;

--
-- Name: staff_subjects; Type: TABLE; Schema: public; Owner: supabase_admin
--

CREATE TABLE public.staff_subjects (
    staff_id uuid NOT NULL,
    subject_id uuid NOT NULL,
    preference text,
    qualification_status text,
    experience_years integer,
    notes text,
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone DEFAULT now(),
    school_id uuid NOT NULL,
    CONSTRAINT staff_subjects_preference_check CHECK ((preference = ANY (ARRAY['loves'::text, 'can do'::text, 'prefers not'::text, 'not qualified'::text])))
);


ALTER TABLE public.staff_subjects OWNER TO supabase_admin;

--
-- Name: staff_work_contracts; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.staff_work_contracts (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    staff_id uuid,
    school_id uuid NOT NULL,
    weekday integer NOT NULL,
    start_time time without time zone NOT NULL,
    end_time time without time zone NOT NULL,
    role text,
    notes text
);


ALTER TABLE public.staff_work_contracts OWNER TO postgres;

--
-- Name: staff_yearly_preferences; Type: TABLE; Schema: public; Owner: supabase_admin
--

CREATE TABLE public.staff_yearly_preferences (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    staff_profile_id uuid,
    semester_id text NOT NULL,
    clubs text,
    team text,
    efob_team text,
    wishes text,
    needs text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    subject_pref uuid[],
    classes uuid[],
    school_id uuid NOT NULL
);


ALTER TABLE public.staff_yearly_preferences OWNER TO supabase_admin;

--
-- Name: structure_classes; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.structure_classes (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    school_id uuid NOT NULL,
    name text NOT NULL,
    year integer NOT NULL,
    teacher_id uuid,
    grade_level integer,
    room_id uuid,
    color text
);


ALTER TABLE public.structure_classes OWNER TO postgres;

--
-- Name: structure_days; Type: TABLE; Schema: public; Owner: supabase_admin
--

CREATE TABLE public.structure_days (
    id integer NOT NULL,
    name_en text NOT NULL,
    name_de text,
    day_number integer NOT NULL,
    order_index smallint DEFAULT 1 NOT NULL,
    CONSTRAINT structure_days_day_number_check CHECK (((day_number >= 0) AND (day_number <= 6)))
);


ALTER TABLE public.structure_days OWNER TO supabase_admin;

--
-- Name: structure_days_id_seq; Type: SEQUENCE; Schema: public; Owner: supabase_admin
--

CREATE SEQUENCE public.structure_days_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE public.structure_days_id_seq OWNER TO supabase_admin;

--
-- Name: structure_days_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: supabase_admin
--

ALTER SEQUENCE public.structure_days_id_seq OWNED BY public.structure_days.id;


--
-- Name: structure_rooms; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.structure_rooms (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    school_id uuid NOT NULL,
    name text NOT NULL,
    room_number text NOT NULL,
    floor text NOT NULL,
    building text,
    is_active boolean DEFAULT true,
    created_at timestamp without time zone DEFAULT now(),
    closed_reason text,
    is_multi_class_bookable boolean DEFAULT false NOT NULL
);


ALTER TABLE public.structure_rooms OWNER TO postgres;

--
-- Name: COLUMN structure_rooms.is_multi_class_bookable; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.structure_rooms.is_multi_class_bookable IS 'If true, this room may be booked by multiple overlapping class-based lessons (course_id IS NULL AND class_id IS NOT NULL).';


--
-- Name: structure_school_days; Type: TABLE; Schema: public; Owner: supabase_admin
--

CREATE TABLE public.structure_school_days (
    school_id uuid NOT NULL,
    day_id integer NOT NULL
);


ALTER TABLE public.structure_school_days OWNER TO supabase_admin;

--
-- Name: structure_school_semesters; Type: TABLE; Schema: public; Owner: supabase_admin
--

CREATE TABLE public.structure_school_semesters (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    school_id uuid NOT NULL,
    school_year_id uuid NOT NULL,
    name text NOT NULL,
    start_date date NOT NULL,
    end_date date NOT NULL,
    is_active boolean DEFAULT true,
    created_at timestamp with time zone DEFAULT now()
);


ALTER TABLE public.structure_school_semesters OWNER TO supabase_admin;

--
-- Name: structure_school_years; Type: TABLE; Schema: public; Owner: supabase_admin
--

CREATE TABLE public.structure_school_years (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    school_id uuid NOT NULL,
    label text NOT NULL,
    start_date date NOT NULL,
    end_date date NOT NULL,
    created_at timestamp with time zone DEFAULT now()
);


ALTER TABLE public.structure_school_years OWNER TO supabase_admin;

--
-- Name: structure_schools; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.structure_schools (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    name text NOT NULL,
    timezone text,
    language text,
    year_groups integer[] DEFAULT '{}'::integer[],
    "Logo" text,
    principal_id uuid,
    email text,
    phone text,
    fax text,
    address_street text,
    address_number text,
    address_postal_code text,
    address_city text,
    address_country text,
    floor_options text[] DEFAULT ARRAY[]::text[],
    building_options text[] DEFAULT ARRAY[]::text[],
    allow_custom_course_times boolean DEFAULT false NOT NULL
);


ALTER TABLE public.structure_schools OWNER TO postgres;

--
-- Name: COLUMN structure_schools."Logo"; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.structure_schools."Logo" IS 'Logo for the school';


--
-- Name: student_absence_notes; Type: TABLE; Schema: public; Owner: supabase_admin
--

CREATE TABLE public.student_absence_notes (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    student_id uuid NOT NULL,
    school_id uuid NOT NULL,
    created_by uuid NOT NULL,
    created_at timestamp without time zone DEFAULT now() NOT NULL,
    updated_by uuid,
    updated_at timestamp without time zone,
    start_date date NOT NULL,
    end_date date NOT NULL,
    absence_type text NOT NULL,
    reason text,
    is_excused boolean DEFAULT false NOT NULL,
    status text DEFAULT 'pending'::text NOT NULL,
    approved_by uuid,
    approved_at timestamp without time zone,
    attachment_url text,
    recurrence_id uuid,
    last_comment text,
    sensitive boolean DEFAULT false,
    deleted_at timestamp without time zone,
    absence_status text,
    CONSTRAINT check_absence_status CHECK ((absence_status = ANY (ARRAY['krankgemeldet'::text, 'Krankgemeldet'::text, 'unentschuldigt'::text, 'Unentschuldigt'::text, 'beurlaubt'::text, 'Beurlaubt'::text, 'versp채tet'::text, 'Versp채tet'::text, 'ungekl채rt'::text, 'Ungekl채rt'::text])))
);


ALTER TABLE public.student_absence_notes OWNER TO supabase_admin;

--
-- Name: student_absence_recurrences; Type: TABLE; Schema: public; Owner: supabase_admin
--

CREATE TABLE public.student_absence_recurrences (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    start_date date NOT NULL,
    end_date date NOT NULL,
    repeat_every_unit text NOT NULL,
    repeat_every_number smallint DEFAULT 1 NOT NULL,
    week_days smallint[],
    monthly_text text,
    original_absence_id uuid,
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone DEFAULT now(),
    created_by uuid,
    school_id uuid NOT NULL
);


ALTER TABLE public.student_absence_recurrences OWNER TO supabase_admin;

--
-- Name: TABLE student_absence_recurrences; Type: COMMENT; Schema: public; Owner: supabase_admin
--

COMMENT ON TABLE public.student_absence_recurrences IS 'Stores recurrence patterns for student absences. Use student_absence_recurrences_generate() to expand patterns into daily logs.';


--
-- Name: COLUMN student_absence_recurrences.repeat_every_unit; Type: COMMENT; Schema: public; Owner: supabase_admin
--

COMMENT ON COLUMN public.student_absence_recurrences.repeat_every_unit IS 'Unit of recurrence: day, week, or month';


--
-- Name: COLUMN student_absence_recurrences.repeat_every_number; Type: COMMENT; Schema: public; Owner: supabase_admin
--

COMMENT ON COLUMN public.student_absence_recurrences.repeat_every_number IS 'Interval number (e.g., every 2 days)';


--
-- Name: COLUMN student_absence_recurrences.week_days; Type: COMMENT; Schema: public; Owner: supabase_admin
--

COMMENT ON COLUMN public.student_absence_recurrences.week_days IS 'Array of weekday numbers (1=Monday, 7=Sunday) for weekly patterns';


--
-- Name: COLUMN student_absence_recurrences.monthly_text; Type: COMMENT; Schema: public; Owner: supabase_admin
--

COMMENT ON COLUMN public.student_absence_recurrences.monthly_text IS 'Text description for monthly patterns (future use)';


--
-- Name: COLUMN student_absence_recurrences.original_absence_id; Type: COMMENT; Schema: public; Owner: supabase_admin
--

COMMENT ON COLUMN public.student_absence_recurrences.original_absence_id IS 'Reference to original absence if this recurrence was created from one';


--
-- Name: student_attendance_logs; Type: TABLE; Schema: public; Owner: supabase_admin
--

CREATE TABLE public.student_attendance_logs (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    lesson_id uuid NOT NULL,
    student_id uuid NOT NULL,
    daily_log_id uuid,
    lateness_duration_minutes integer,
    method text,
    recorded_by uuid,
    "timestamp" timestamp without time zone DEFAULT now(),
    notes text,
    status public.attendance_status,
    absence_note_id uuid,
    school_id uuid NOT NULL
);


ALTER TABLE public.student_attendance_logs OWNER TO supabase_admin;

--
-- Name: student_course_wish_choices; Type: TABLE; Schema: public; Owner: supabase_admin
--

CREATE TABLE public.student_course_wish_choices (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    submission_id uuid NOT NULL,
    day_of_week smallint NOT NULL,
    rank smallint NOT NULL,
    window_id uuid,
    no_offer boolean DEFAULT false NOT NULL,
    school_id uuid NOT NULL,
    CONSTRAINT student_course_wish_choices_day_of_week_check CHECK (((day_of_week >= 1) AND (day_of_week <= 5))),
    CONSTRAINT student_course_wish_choices_rank_check CHECK (((rank >= 0) AND (rank <= 10))),
    CONSTRAINT wish_choice_rank_rule CHECK ((((no_offer = true) AND (rank = 0) AND (window_id IS NULL)) OR ((no_offer = false) AND (rank >= 1) AND (window_id IS NOT NULL))))
);


ALTER TABLE public.student_course_wish_choices OWNER TO supabase_admin;

--
-- Name: TABLE student_course_wish_choices; Type: COMMENT; Schema: public; Owner: supabase_admin
--

COMMENT ON TABLE public.student_course_wish_choices IS 'Normalized per-day ranked choices from course wish interview. day_of_week: 1=Mon .. 5=Fri. rank=0 used only when no_offer=true.';


--
-- Name: student_course_wish_submissions; Type: TABLE; Schema: public; Owner: supabase_admin
--

CREATE TABLE public.student_course_wish_submissions (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    student_id uuid NOT NULL,
    school_id uuid NOT NULL,
    registration_period_id uuid NOT NULL,
    semester_id uuid NOT NULL,
    submitted_at timestamp with time zone DEFAULT now() NOT NULL,
    submitted_by uuid,
    payload jsonb NOT NULL,
    over_limit_total boolean DEFAULT false NOT NULL,
    over_limit_per_day boolean DEFAULT false NOT NULL,
    interview_raw jsonb
);


ALTER TABLE public.student_course_wish_submissions OWNER TO supabase_admin;

--
-- Name: student_daily_log; Type: TABLE; Schema: public; Owner: supabase_admin
--

CREATE TABLE public.student_daily_log (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    student_id uuid NOT NULL,
    school_id uuid,
    date date NOT NULL,
    check_in_time timestamp without time zone,
    check_in_method text,
    check_in_by uuid,
    check_out_time timestamp without time zone,
    check_out_method text,
    check_out_by uuid,
    presence_status public.presence_status DEFAULT 'unmarked'::public.presence_status,
    notes text,
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone DEFAULT now(),
    last_updated_by uuid,
    first_attendance_time timestamp with time zone,
    is_late boolean,
    expected_arrival_time time without time zone,
    expected_checkout_time time without time zone,
    absence_note_id uuid
);


ALTER TABLE public.student_daily_log OWNER TO supabase_admin;

--
-- Name: COLUMN student_daily_log.expected_arrival_time; Type: COMMENT; Schema: public; Owner: supabase_admin
--

COMMENT ON COLUMN public.student_daily_log.expected_arrival_time IS 'Expected arrival time for students with partial absences. Used for tracking when a student should arrive after being absent, separate from actual check_in_time which represents physical presence.';


--
-- Name: COLUMN student_daily_log.expected_checkout_time; Type: COMMENT; Schema: public; Owner: supabase_admin
--

COMMENT ON COLUMN public.student_daily_log.expected_checkout_time IS 'Expected checkout time for students with partial absences. Used for tracking when a student should leave due to partial absence, separate from actual check_out_time which represents physical presence.';


--
-- Name: student_emergency_information; Type: TABLE; Schema: public; Owner: supabase_admin
--

CREATE TABLE public.student_emergency_information (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    student_id uuid NOT NULL,
    school_id uuid NOT NULL,
    medical_information jsonb DEFAULT '{}'::jsonb,
    medication_location text,
    staff_instructions text,
    emergency_procedures text,
    emergency_contacts jsonb DEFAULT '[]'::jsonb,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    created_by uuid,
    updated_by uuid
);


ALTER TABLE public.student_emergency_information OWNER TO supabase_admin;

--
-- Name: student_pickup_arrangement_overrides; Type: TABLE; Schema: public; Owner: supabase_admin
--

CREATE TABLE public.student_pickup_arrangement_overrides (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    student_id uuid NOT NULL,
    school_id uuid NOT NULL,
    pickup_date date NOT NULL,
    pickup_type text NOT NULL,
    authorized_person_id uuid,
    notes text,
    created_by uuid NOT NULL,
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone DEFAULT now()
);


ALTER TABLE public.student_pickup_arrangement_overrides OWNER TO supabase_admin;

--
-- Name: student_presence_events; Type: TABLE; Schema: public; Owner: supabase_admin
--

CREATE TABLE public.student_presence_events (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    daily_log_id uuid NOT NULL,
    student_id uuid NOT NULL,
    event_type public.presence_event_type NOT NULL,
    "timestamp" timestamp without time zone DEFAULT now() NOT NULL,
    method text,
    performed_by uuid,
    notes text,
    school_id uuid NOT NULL
);


ALTER TABLE public.student_presence_events OWNER TO supabase_admin;

--
-- Name: student_weekly_pickup_arrangements; Type: TABLE; Schema: public; Owner: supabase_admin
--

CREATE TABLE public.student_weekly_pickup_arrangements (
    id uuid NOT NULL,
    student_id uuid NOT NULL,
    school_id uuid NOT NULL,
    weekday integer NOT NULL,
    pickup_type text NOT NULL,
    notes text,
    valid_from date NOT NULL,
    valid_until date,
    created_by uuid NOT NULL,
    created_at timestamp without time zone DEFAULT now(),
    updated_at timestamp without time zone DEFAULT now()
);


ALTER TABLE public.student_weekly_pickup_arrangements OWNER TO supabase_admin;

--
-- Name: subject_class_hours; Type: TABLE; Schema: public; Owner: supabase_admin
--

CREATE TABLE public.subject_class_hours (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    school_id uuid NOT NULL,
    subject_id uuid NOT NULL,
    class_id uuid NOT NULL,
    hours_per_week integer NOT NULL,
    created_at timestamp without time zone DEFAULT now()
);


ALTER TABLE public.subject_class_hours OWNER TO supabase_admin;

--
-- Name: subject_grade_hours; Type: TABLE; Schema: public; Owner: supabase_admin
--

CREATE TABLE public.subject_grade_hours (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    school_id uuid NOT NULL,
    subject_id uuid NOT NULL,
    grade_level text NOT NULL,
    hours_per_week integer NOT NULL,
    created_at timestamp without time zone DEFAULT now()
);


ALTER TABLE public.subject_grade_hours OWNER TO supabase_admin;

--
-- Name: subject_icons; Type: TABLE; Schema: public; Owner: supabase_admin
--

CREATE TABLE public.subject_icons (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    name text NOT NULL,
    icon_path text NOT NULL,
    description text,
    "Tags" text[]
);


ALTER TABLE public.subject_icons OWNER TO supabase_admin;

--
-- Name: subjects; Type: TABLE; Schema: public; Owner: supabase_admin
--

CREATE TABLE public.subjects (
    id uuid DEFAULT extensions.uuid_generate_v4() NOT NULL,
    name text NOT NULL,
    color text,
    school_id uuid,
    icon_id uuid,
    subject_type public.subject_type_enum DEFAULT 'school_subject'::public.subject_type_enum NOT NULL,
    is_system_subject boolean DEFAULT false NOT NULL,
    icon text,
    abbreviation text
);


ALTER TABLE public.subjects OWNER TO supabase_admin;

--
-- Name: substitutions; Type: TABLE; Schema: public; Owner: supabase_admin
--

CREATE TABLE public.substitutions (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    original_lesson_id uuid,
    reason text,
    created_by uuid,
    created_at timestamp without time zone DEFAULT now(),
    valid_until date,
    status text DEFAULT 'draft'::text,
    notes text,
    substitute_staff_id uuid,
    absent_teacher_ids uuid[],
    school_id uuid NOT NULL
);


ALTER TABLE public.substitutions OWNER TO supabase_admin;

--
-- Name: user_codes; Type: TABLE; Schema: public; Owner: supabase_admin
--

CREATE TABLE public.user_codes (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    profile_id uuid NOT NULL,
    code character varying(6) NOT NULL,
    created_at timestamp with time zone DEFAULT now(),
    used_at timestamp with time zone,
    code_instance integer DEFAULT 1,
    expires_at timestamp with time zone DEFAULT (now() + '30 days'::interval),
    revoked_at timestamp with time zone,
    created_by uuid,
    notes text,
    code_attempts integer DEFAULT 0,
    school_id uuid NOT NULL
);


ALTER TABLE public.user_codes OWNER TO supabase_admin;

--
-- Name: COLUMN user_codes.code_attempts; Type: COMMENT; Schema: public; Owner: supabase_admin
--

COMMENT ON COLUMN public.user_codes.code_attempts IS 'Number of failed attempts to use this code (e.g., wrong date of birth)';


--
-- Name: user_group_members; Type: TABLE; Schema: public; Owner: supabase_admin
--

CREATE TABLE public.user_group_members (
    group_id uuid NOT NULL,
    user_id uuid NOT NULL,
    school_id uuid NOT NULL
);


ALTER TABLE public.user_group_members OWNER TO supabase_admin;

--
-- Name: user_groups; Type: TABLE; Schema: public; Owner: supabase_admin
--

CREATE TABLE public.user_groups (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    name text NOT NULL,
    description text,
    created_by uuid,
    school_id uuid NOT NULL,
    created_at timestamp without time zone DEFAULT now()
);


ALTER TABLE public.user_groups OWNER TO supabase_admin;

--
-- Name: user_profiles; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.user_profiles (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    school_id uuid NOT NULL,
    created_at timestamp without time zone DEFAULT now(),
    first_name text,
    last_name text,
    date_of_birth date,
    gender text,
    profile_picture_url text,
    role_id uuid,
    account_status public.account_status_enum DEFAULT 'none'::public.account_status_enum NOT NULL
);


ALTER TABLE public.user_profiles OWNER TO postgres;

--
-- Name: COLUMN user_profiles.account_status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.user_profiles.account_status IS 'Tracks the current state of a linked login account (e.g. invited, active, deleted).';


--
-- Name: user_roles; Type: TABLE; Schema: public; Owner: supabase_admin
--

CREATE TABLE public.user_roles (
    id bigint NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    user_profile_id uuid NOT NULL,
    role_id uuid NOT NULL,
    school_id uuid NOT NULL
);


ALTER TABLE public.user_roles OWNER TO supabase_admin;

--
-- Name: TABLE user_roles; Type: COMMENT; Schema: public; Owner: supabase_admin
--

COMMENT ON TABLE public.user_roles IS 'Assigns roles to users';


--
-- Name: user_roles_id_seq; Type: SEQUENCE; Schema: public; Owner: supabase_admin
--

ALTER TABLE public.user_roles ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME public.user_roles_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: v_is_subrole; Type: TABLE; Schema: public; Owner: supabase_admin
--

CREATE TABLE public.v_is_subrole (
    is_subrole boolean
);


ALTER TABLE public.v_is_subrole OWNER TO supabase_admin;

--
-- Name: v_primary_email; Type: TABLE; Schema: public; Owner: supabase_admin
--

CREATE TABLE public.v_primary_email (
    text text
);


ALTER TABLE public.v_primary_email OWNER TO supabase_admin;

--
-- Name: vw_attendance_dashboard; Type: VIEW; Schema: public; Owner: supabase_admin
--

CREATE VIEW public.vw_attendance_dashboard WITH (security_invoker='true') AS
 SELECT COALESCE((dl.id)::text, (a.id)::text) AS id,
    ((up.first_name || ' '::text) || up.last_name) AS student_name,
    sc.name AS student_class,
    COALESCE(dl.date, a.start_date) AS date,
        CASE
            WHEN ((dl.id IS NULL) AND (a.start_date <> a.end_date)) THEN (((a.start_date)::text || ' - '::text) || (a.end_date)::text)
            WHEN (dl.id IS NOT NULL) THEN
            CASE
                WHEN ((dl.expected_checkout_time IS NOT NULL) AND (dl.expected_arrival_time IS NOT NULL)) THEN (("left"((dl.expected_checkout_time)::text, 5) || ''::text) || "left"((dl.expected_arrival_time)::text, 5))
                WHEN (dl.expected_arrival_time IS NOT NULL) THEN ('ab '::text || "left"((dl.expected_arrival_time)::text, 5))
                WHEN (dl.expected_checkout_time IS NOT NULL) THEN ('bis '::text || "left"((dl.expected_checkout_time)::text, 5))
                ELSE NULL::text
            END
            WHEN ((lesson_times.earliest_start IS NOT NULL) AND (lesson_times.latest_end IS NOT NULL)) THEN (("left"((lesson_times.earliest_start)::text, 5) || ''::text) || "left"((lesson_times.latest_end)::text, 5))
            WHEN (lesson_times.earliest_start IS NOT NULL) THEN ('ab '::text || "left"((lesson_times.earliest_start)::text, 5))
            ELSE NULL::text
        END AS date_range,
        CASE
            WHEN ((dl.id IS NULL) AND (a.start_date <> a.end_date)) THEN 'Mehrere Tage'::text
            WHEN ((dl.id IS NOT NULL) AND ((dl.expected_checkout_time IS NOT NULL) OR (dl.expected_arrival_time IS NOT NULL))) THEN 'Zeitfenster'::text
            WHEN (dl.id IS NOT NULL) THEN 'Ganzer Tag'::text
            WHEN (lesson_times.earliest_start IS NOT NULL) THEN 'Zeitfenster'::text
            ELSE 'Ganzer Tag'::text
        END AS duration,
    COALESCE(a.absence_status, 'unentschuldigt'::text) AS status,
    a.reason,
    (a.attachment_url IS NOT NULL) AS has_attachment,
    a.is_excused,
    creator.first_name AS created_by,
    COALESCE(dl.created_at, a.created_at) AS created_at,
    a.status AS approval_status,
        CASE
            WHEN (a.recurrence_id IS NOT NULL) THEN 'recurring'::text
            ELSE 'single'::text
        END AS recurrence_type,
        CASE
            WHEN (dl.id IS NOT NULL) THEN 'system'::text
            ELSE 'manual'::text
        END AS source_type,
    a.id AS absence_note_id
   FROM ((((((public.student_absence_notes a
     JOIN public.user_profiles up ON ((a.student_id = up.id)))
     JOIN public.profile_info_student pis ON ((up.id = pis.profile_id)))
     JOIN public.structure_classes sc ON ((pis.class_id = sc.id)))
     LEFT JOIN public.user_profiles creator ON ((a.created_by = creator.id)))
     LEFT JOIN public.student_daily_log dl ON ((dl.absence_note_id = a.id)))
     LEFT JOIN ( SELECT sal.absence_note_id,
            min((cl.start_datetime)::time without time zone) AS earliest_start,
            max((cl.end_datetime)::time without time zone) AS latest_end
           FROM (public.student_attendance_logs sal
             JOIN public.course_lessons cl ON ((sal.lesson_id = cl.id)))
          WHERE (sal.absence_note_id IS NOT NULL)
          GROUP BY sal.absence_note_id) lesson_times ON ((lesson_times.absence_note_id = a.id)))
  WHERE ((a.deleted_at IS NULL) AND ((dl.id IS NOT NULL) OR (NOT (EXISTS ( SELECT 1
           FROM public.student_daily_log sdl
          WHERE (sdl.absence_note_id = a.id))))))
  ORDER BY COALESCE(dl.date, a.start_date) DESC, sc.name, up.last_name;


ALTER VIEW public.vw_attendance_dashboard OWNER TO supabase_admin;

--
-- Name: vw_class_checkins_today; Type: VIEW; Schema: public; Owner: supabase_admin
--

CREATE VIEW public.vw_class_checkins_today AS
 WITH student_status_today AS (
         SELECT s_1.profile_id AS student_id,
            s_1.class_id,
            d.presence_status
           FROM (public.profile_info_student s_1
             LEFT JOIN public.student_daily_log d ON (((d.student_id = s_1.profile_id) AND (d.date = CURRENT_DATE))))
          WHERE (s_1.school_id = ( SELECT user_profiles.school_id
                   FROM public.user_profiles
                  WHERE (user_profiles.id = auth.uid())))
        ), categorized AS (
         SELECT ss.class_id,
            ss.student_id,
                CASE
                    WHEN (ss.presence_status = ANY (ARRAY['present'::public.presence_status, 'late'::public.presence_status, 'left_early'::public.presence_status])) THEN 'present'::text
                    WHEN (ss.presence_status = ANY (ARRAY['absent_unexcused'::public.presence_status, 'absent_excused'::public.presence_status, 'left_without_notice'::public.presence_status, 'temporarily_offsite'::public.presence_status])) THEN 'absent'::text
                    ELSE 'unmarked'::text
                END AS status
           FROM student_status_today ss
        )
 SELECT c.id AS class_id,
    c.name AS class_name,
    c.school_id,
    count(DISTINCT s.profile_id) AS students_in_class,
    count(DISTINCT
        CASE
            WHEN (cat.status = 'present'::text) THEN cat.student_id
            ELSE NULL::uuid
        END) AS students_present_today,
    count(DISTINCT
        CASE
            WHEN (cat.status = 'absent'::text) THEN cat.student_id
            ELSE NULL::uuid
        END) AS students_absent_today,
    count(DISTINCT
        CASE
            WHEN (cat.status <> 'unmarked'::text) THEN cat.student_id
            ELSE NULL::uuid
        END) AS students_marked_today
   FROM ((public.structure_classes c
     LEFT JOIN public.profile_info_student s ON ((s.class_id = c.id)))
     LEFT JOIN categorized cat ON (((cat.class_id = c.id) AND (cat.student_id = s.profile_id))))
  WHERE (c.school_id = ( SELECT user_profiles.school_id
           FROM public.user_profiles
          WHERE (user_profiles.id = auth.uid())))
  GROUP BY c.id, c.name, c.school_id;


ALTER VIEW public.vw_class_checkins_today OWNER TO supabase_admin;

--
-- Name: vw_course_schedules_detailed; Type: VIEW; Schema: public; Owner: supabase_admin
--

CREATE VIEW public.vw_course_schedules_detailed WITH (security_invoker='true') AS
 WITH teacher_names_lookup AS (
         SELECT cs_1.id AS schedule_id,
            array_agg(((up.first_name || ' '::text) || up.last_name) ORDER BY up.last_name) AS teacher_names
           FROM ((public.course_schedules cs_1
             CROSS JOIN LATERAL unnest(cs_1.teacher_ids) teacher_id(teacher_id))
             JOIN public.user_profiles up ON ((up.id = teacher_id.teacher_id)))
          GROUP BY cs_1.id
        ), enrollment_data AS (
         SELECT cs_1.id AS schedule_id,
            count(ce.id) AS enrolled_count,
            array_agg((((up.first_name || ' '::text) || up.last_name) || COALESCE(((' ('::text || sc.name) || ')'::text), ''::text)) ORDER BY up.last_name) AS enrolled_names
           FROM ((((public.course_schedules cs_1
             JOIN public.course_enrollments ce ON (((ce.course_id = cs_1.course_id) AND (ce.school_id = cs_1.school_id) AND (CURRENT_DATE >= ce.start_date) AND (CURRENT_DATE <= ce.end_date))))
             JOIN public.user_profiles up ON ((up.id = ce.student_id)))
             JOIN public.profile_info_student pis ON ((pis.profile_id = ce.student_id)))
             LEFT JOIN public.structure_classes sc ON ((sc.id = pis.class_id)))
          GROUP BY cs_1.id
        )
 SELECT cs.id,
    cs.course_id,
    cl.name AS course_name,
    cl.is_for_year_g AS year_groups,
    cs.start_date,
    cs.end_date,
    COALESCE(sp.start_time, cs.start_time) AS start_time,
    COALESCE(sp.end_time, cs.end_time) AS end_time,
    cs.day_id,
    d.name_en AS day_name_en,
    d.name_de AS day_name_de,
    cs.room_id,
    r.name AS scheduled_room_name,
    cs.school_id,
    cs.teacher_ids,
    cs.period_id,
    sp.block_number,
    sp.label AS period_label,
    sp.group_label,
    cs.class_id,
    c.name AS class_name,
    cs.subject_id,
    s.name AS subject_name,
    cs.meeting_name,
    cs.notes,
    cs.is_archived,
    COALESCE(tnl.teacher_names, ARRAY[]::text[]) AS teacher_names,
    COALESCE(ed.enrolled_count, (0)::bigint) AS enrolled_students_count,
    ed.enrolled_names AS enrolled_students_names,
    cs.valid_from,
    cs.valid_until,
    cs.created_at
   FROM ((((((((public.course_schedules cs
     LEFT JOIN public.structure_days d ON ((cs.day_id = d.id)))
     LEFT JOIN public.course_list cl ON ((cs.course_id = cl.id)))
     LEFT JOIN public.structure_rooms r ON ((cs.room_id = r.id)))
     LEFT JOIN public.schedule_periods sp ON ((cs.period_id = sp.id)))
     LEFT JOIN public.structure_classes c ON ((cs.class_id = c.id)))
     LEFT JOIN public.subjects s ON ((cs.subject_id = s.id)))
     LEFT JOIN teacher_names_lookup tnl ON ((tnl.schedule_id = cs.id)))
     LEFT JOIN enrollment_data ed ON ((ed.schedule_id = cs.id)));


ALTER VIEW public.vw_course_schedules_detailed OWNER TO supabase_admin;

--
-- Name: vw_course_summary; Type: VIEW; Schema: public; Owner: supabase_admin
--

CREATE VIEW public.vw_course_summary WITH (security_invoker='true') AS
 SELECT c.id AS course_id,
    c.name AS course_name,
    c.course_code,
    c.max_students,
    c.is_for_year_g,
    (c.max_students - count(DISTINCT ce.student_id)) AS free_spaces,
    s.id AS subject_id,
    s.name AS subject_name,
    si.icon_path AS subject_icon_path,
    count(DISTINCT ce.student_id) AS student_count,
    COALESCE(array_agg(DISTINCT (cs.day_id)::text ORDER BY (cs.day_id)::text), ARRAY[''::text]) AS weekday_ids,
    COALESCE(array_agg(DISTINCT concat_ws(' '::text, up.first_name, up.last_name)), ARRAY['noch nicht gesteckt'::text]) AS teacher_names,
    COALESCE(array_agg(DISTINCT up.first_name), ARRAY['noch nicht gesteckt'::text]) AS teacher_first_names,
    COALESCE(array_agg(DISTINCT up.last_name), ARRAY['noch nicht gesteckt'::text]) AS teacher_last_names,
    COALESCE(array_agg(DISTINCT tid.teacher_id), ARRAY[]::uuid[]) AS teacher_ids,
    COALESCE(array_agg(DISTINCT concat_ws(' '::text, up2.first_name, up2.last_name)), ARRAY[]::text[]) AS possible_staff_names,
    COALESCE(array_agg(DISTINCT staff_id.staff_id), ARRAY[]::uuid[]) AS possible_staff_ids,
    COALESCE(array_agg(DISTINCT concat((cpt.weekday)::text, '|', (cpt.schedule_period_id)::text)), ARRAY[]::text[]) AS possible_time_slots,
    c.start_date,
    c.end_date,
    c.description,
    c.wichtige_infos AS important_information,
    c.description_visible_to_parents,
    c.created_at,
    c.updated_at,
    c.possible_room_id,
    r.name AS possible_room_name,
    r.room_number AS possible_room_number,
    r.floor AS possible_room_floor,
    r.building AS possible_room_building
   FROM ((((((((((public.course_list c
     LEFT JOIN public.subjects s ON ((c.subject_id = s.id)))
     LEFT JOIN public.subject_icons si ON ((s.icon_id = si.id)))
     LEFT JOIN public.course_enrollments ce ON ((ce.course_id = c.id)))
     LEFT JOIN public.course_schedules cs ON ((cs.course_id = c.id)))
     LEFT JOIN LATERAL unnest(cs.teacher_ids) tid(teacher_id) ON (true))
     LEFT JOIN public.user_profiles up ON ((up.id = tid.teacher_id)))
     LEFT JOIN LATERAL unnest(c.possible_staff_members) staff_id(staff_id) ON (true))
     LEFT JOIN public.user_profiles up2 ON ((up2.id = staff_id.staff_id)))
     LEFT JOIN public.course_possible_times cpt ON ((cpt.course_id = c.id)))
     LEFT JOIN public.structure_rooms r ON ((r.id = c.possible_room_id)))
  WHERE (c.is_active = true)
  GROUP BY c.id, c.name, c.course_code, c.max_students, c.is_for_year_g, s.id, s.name, si.icon_path, c.start_date, c.end_date, c.description, c.wichtige_infos, c.description_visible_to_parents, c.created_at, c.updated_at, c.possible_room_id, r.name, r.room_number, r.floor, r.building;


ALTER VIEW public.vw_course_summary OWNER TO supabase_admin;

--
-- Name: vw_daily_absences; Type: VIEW; Schema: public; Owner: supabase_admin
--

CREATE VIEW public.vw_daily_absences WITH (security_invoker='true') AS
 SELECT sa.id AS absence_id,
    sa.staff_id,
    ((up.first_name || ' '::text) || up.last_name) AS staff_name,
    sa.reason,
    sa.start_period,
    sa.end_period,
    ((sa.start_period IS NULL) AND (sa.end_period IS NULL)) AS is_full_day,
    ((sa.date)::timestamp without time zone AT TIME ZONE 'UTC'::text) AS start_of_day_utc,
    (((COALESCE(sa.end_date, sa.date))::timestamp without time zone AT TIME ZONE 'UTC'::text) + '23:59:59.999'::interval) AS end_of_day_utc,
    (to_char((sa.date)::timestamp with time zone, 'DD.MM.YYYY'::text) ||
        CASE
            WHEN ((sa.end_date IS NOT NULL) AND (sa.end_date <> sa.date)) THEN ('  '::text || to_char((sa.end_date)::timestamp with time zone, 'DD.MM.YYYY'::text))
            ELSE ''::text
        END) AS formatted_date_range,
    COALESCE(json_agg(json_build_object('lesson_id', cl.id, 'course_id', cl.course_id, 'course_name', c.name, 'start_datetime', cl.start_datetime, 'end_datetime', cl.end_datetime, 'room_id', cl.room_id) ORDER BY cl.start_datetime) FILTER (WHERE (cl.id IS NOT NULL)), '[]'::json) AS lessons
   FROM (((public.staff_absences sa
     JOIN public.user_profiles up ON ((sa.staff_id = up.id)))
     LEFT JOIN public.course_lessons cl ON (((sa.staff_id = ANY (cl.teacher_ids)) AND (cl.is_cancelled = false) AND ((cl.start_datetime)::date >= sa.date) AND ((cl.start_datetime)::date <= COALESCE(sa.end_date, sa.date)))))
     LEFT JOIN public.course_list c ON ((c.id = cl.course_id)))
  GROUP BY sa.id, sa.staff_id, up.first_name, up.last_name, sa.reason, sa.start_period, sa.end_period, sa.date, sa.end_date;


ALTER VIEW public.vw_daily_absences OWNER TO supabase_admin;

--
-- Name: vw_daily_attendance_by_class; Type: VIEW; Schema: public; Owner: supabase_admin
--

CREATE VIEW public.vw_daily_attendance_by_class WITH (security_invoker='true') AS
 WITH current_attendance_date AS (
         SELECT CURRENT_DATE AS today
        ), class_attendance_summary AS (
         SELECT s.class_id,
            count(*) AS total_students,
            sum(
                CASE
                    WHEN (dl.student_id IS NOT NULL) THEN 1
                    ELSE 0
                END) AS marked_students,
            sum(
                CASE
                    WHEN (dl.presence_status = 'present'::public.presence_status) THEN 1
                    ELSE 0
                END) AS present_count,
            sum(
                CASE
                    WHEN (dl.presence_status = 'absent_excused'::public.presence_status) THEN 1
                    ELSE 0
                END) AS absent_excused_count,
            sum(
                CASE
                    WHEN (dl.presence_status = 'absent_unexcused'::public.presence_status) THEN 1
                    ELSE 0
                END) AS absent_unexcused_count,
            sum(
                CASE
                    WHEN (dl.presence_status = ANY (ARRAY['left_early'::public.presence_status, 'temporarily_offsite'::public.presence_status, 'left_without_notice'::public.presence_status])) THEN 1
                    ELSE 0
                END) AS partial_presence_count
           FROM ((public.profile_info_student s
             JOIN current_attendance_date cad_1 ON (true))
             LEFT JOIN public.student_daily_log dl ON (((dl.student_id = s.profile_id) AND (dl.date = cad_1.today))))
          GROUP BY s.class_id
        )
 SELECT c.id AS class_id,
    c.name AS class_name,
    cad.today AS attendance_date,
    cas.total_students,
    cas.present_count,
    cas.absent_excused_count,
    cas.absent_unexcused_count,
    cas.partial_presence_count,
    (cas.total_students - cas.marked_students) AS unmarked_count
   FROM ((public.structure_classes c
     JOIN class_attendance_summary cas ON ((cas.class_id = c.id)))
     CROSS JOIN current_attendance_date cad);


ALTER VIEW public.vw_daily_attendance_by_class OWNER TO supabase_admin;

--
-- Name: vw_daily_attendance_overview; Type: VIEW; Schema: public; Owner: supabase_admin
--

CREATE VIEW public.vw_daily_attendance_overview WITH (security_invoker='true') AS
 WITH current_date_cte AS (
         SELECT CURRENT_DATE AS today
        ), attendance_summary AS (
         SELECT count(s.profile_id) AS total_students,
            sum(
                CASE
                    WHEN (dl.student_id IS NOT NULL) THEN 1
                    ELSE 0
                END) AS marked_students,
            sum(
                CASE
                    WHEN (dl.presence_status = 'present'::public.presence_status) THEN 1
                    ELSE 0
                END) AS present_count,
            sum(
                CASE
                    WHEN (dl.presence_status = 'absent_excused'::public.presence_status) THEN 1
                    ELSE 0
                END) AS absent_excused_count,
            sum(
                CASE
                    WHEN (dl.presence_status = 'absent_unexcused'::public.presence_status) THEN 1
                    ELSE 0
                END) AS absent_unexcused_count,
            sum(
                CASE
                    WHEN (dl.presence_status = ANY (ARRAY['left_early'::public.presence_status, 'temporarily_offsite'::public.presence_status, 'left_without_notice'::public.presence_status])) THEN 1
                    ELSE 0
                END) AS partial_presence_count
           FROM ((public.profile_info_student s
             CROSS JOIN current_date_cte cdc_1)
             LEFT JOIN public.student_daily_log dl ON (((dl.student_id = s.profile_id) AND (dl.date = cdc_1.today))))
        )
 SELECT cdc.today AS attendance_date,
    ats.total_students,
    ats.present_count,
    ats.absent_excused_count,
    ats.absent_unexcused_count,
    ats.partial_presence_count,
    (ats.total_students - ats.marked_students) AS unmarked_count
   FROM (attendance_summary ats
     CROSS JOIN current_date_cte cdc);


ALTER VIEW public.vw_daily_attendance_overview OWNER TO supabase_admin;

--
-- Name: vw_enrollments_with_students; Type: VIEW; Schema: public; Owner: supabase_admin
--

CREATE VIEW public.vw_enrollments_with_students WITH (security_invoker='true') AS
 SELECT e.id,
    e.student_id,
    e.course_id,
    e.assigned_at,
    e.school_id,
    e.schedule_ids,
    e.is_trial,
    e.start_date,
    e.end_date,
    u.first_name,
    u.last_name,
    u.gender,
    u.profile_picture_url,
    u.school_id AS user_school_id,
    s.class_id,
    c.name AS class_name,
    s.notes,
    s.nickname,
    s.allergies
   FROM (((public.course_enrollments e
     JOIN public.user_profiles u ON ((e.student_id = u.id)))
     LEFT JOIN public.profile_info_student s ON ((s.profile_id = u.id)))
     LEFT JOIN public.structure_classes c ON ((s.class_id = c.id)))
  ORDER BY e.school_id, u.last_name, u.first_name, e.start_date DESC;


ALTER VIEW public.vw_enrollments_with_students OWNER TO supabase_admin;

--
-- Name: vw_erzieher; Type: VIEW; Schema: public; Owner: supabase_admin
--

CREATE VIEW public.vw_erzieher WITH (security_invoker='true') AS
 WITH staff_contacts AS (
         SELECT c.profile_id,
            json_agg(jsonb_build_object('id', c.id, 'contact_type', c.type, 'contact_value', c.value, 'notes', c.notes, 'is_primary', c.is_primary, 'status', c.status) ORDER BY c.is_primary DESC, c.type) AS contacts
           FROM public.contacts c
          WHERE (c.status = 'valid'::text)
          GROUP BY c.profile_id
        )
 SELECT u.id,
    u.first_name,
    u.last_name,
    u.date_of_birth,
    u.gender,
    u.school_id,
    u.profile_picture_url,
    u.account_status,
    s.status,
    s.login_active,
    s.last_invited_at,
    s.joined_at,
    s.employee_id,
    s.colour,
    u.role_id,
    COALESCE(sc.contacts, '[]'::json) AS contacts
   FROM ((public.user_profiles u
     JOIN public.profile_info_staff s ON ((u.id = s.profile_id)))
     LEFT JOIN staff_contacts sc ON ((sc.profile_id = u.id)))
  WHERE (u.role_id = '34fbd171-b2f5-4b3d-8e00-5f033269e885'::uuid)
  ORDER BY u.school_id, u.last_name, u.first_name;


ALTER VIEW public.vw_erzieher OWNER TO supabase_admin;

--
-- Name: vw_erzieher_with_email; Type: VIEW; Schema: public; Owner: supabase_admin
--

CREATE VIEW public.vw_erzieher_with_email WITH (security_invoker='true') AS
 WITH staff_contacts AS (
         SELECT c.profile_id,
            json_agg(jsonb_build_object('id', c.id, 'contact_type', c.type, 'contact_value', c.value, 'notes', c.notes, 'is_primary', c.is_primary, 'status', c.status) ORDER BY c.is_primary DESC, c.type) AS contacts,
            ( SELECT c2.value
                   FROM public.contacts c2
                  WHERE ((c2.profile_id = c.profile_id) AND (c2.type = 'email'::text) AND (c2.status = 'valid'::text))
                  ORDER BY c2.is_primary DESC
                 LIMIT 1) AS email
           FROM public.contacts c
          WHERE (c.status = 'valid'::text)
          GROUP BY c.profile_id
        )
 SELECT u.id,
    u.first_name,
    u.last_name,
    u.date_of_birth,
    u.gender,
    u.school_id,
    u.profile_picture_url,
    u.account_status,
    sc.email,
    s.status,
    s.login_active,
    s.last_invited_at,
    s.joined_at,
    s.employee_id,
    s.colour,
    u.role_id,
    COALESCE(sc.contacts, '[]'::json) AS contacts
   FROM ((public.user_profiles u
     JOIN public.profile_info_staff s ON ((u.id = s.profile_id)))
     LEFT JOIN staff_contacts sc ON ((sc.profile_id = u.id)))
  WHERE (u.role_id = '34fbd171-b2f5-4b3d-8e00-5f033269e885'::uuid)
  ORDER BY u.school_id, u.last_name, u.first_name;


ALTER VIEW public.vw_erzieher_with_email OWNER TO supabase_admin;

--
-- Name: vw_externa; Type: VIEW; Schema: public; Owner: supabase_admin
--

CREATE VIEW public.vw_externa WITH (security_invoker='true') AS
 WITH external_contacts AS (
         SELECT c.profile_id,
            json_agg(jsonb_build_object('id', c.id, 'contact_type', c.type, 'contact_value', c.value, 'notes', c.notes, 'is_primary', c.is_primary, 'status', c.status) ORDER BY c.is_primary DESC, c.type) AS contacts
           FROM public.contacts c
          WHERE (c.status = 'valid'::text)
          GROUP BY c.profile_id
        )
 SELECT u.id,
    u.first_name,
    u.last_name,
    u.date_of_birth,
    u.gender,
    u.school_id,
    u.profile_picture_url,
    u.account_status,
    s.status,
    s.login_active,
    s.last_invited_at,
    s.joined_at,
    s.employee_id,
    s.colour,
    u.role_id,
    COALESCE(ec.contacts, '[]'::json) AS contacts
   FROM ((public.user_profiles u
     JOIN public.profile_info_staff s ON ((u.id = s.profile_id)))
     LEFT JOIN external_contacts ec ON ((ec.profile_id = u.id)))
  WHERE (u.role_id = '2da8793c-44e9-4aba-887e-9f83cdb37527'::uuid)
  ORDER BY u.school_id, u.last_name, u.first_name;


ALTER VIEW public.vw_externa OWNER TO supabase_admin;

--
-- Name: vw_family_all_members; Type: VIEW; Schema: public; Owner: supabase_admin
--

CREATE VIEW public.vw_family_all_members WITH (security_invoker='true') AS
 WITH family_child_relationships AS (
         SELECT link.family_id,
            link.adult_profile_id,
            json_agg(json_build_object('student_id', link.child_profile_id, 'relationship', link.relationship) ORDER BY link.relationship, link.child_profile_id) AS child_relationships
           FROM public.family_member_child_links link
          GROUP BY link.family_id, link.adult_profile_id
        ), adult_members AS (
         SELECT fm.family_id,
            fm.profile_id AS member_profile_id,
            'adult'::text AS member_type,
            up.first_name,
            up.last_name,
            NULL::text AS nickname,
            pifm.default_relationship,
            fm.is_primary_guardian,
            NULL::uuid AS student_id,
            NULL::uuid AS student_class,
            NULL::date AS date_of_birth,
            COALESCE(fcr.child_relationships, '[]'::json) AS child_relationships
           FROM (((public.family_members fm
             JOIN public.user_profiles up ON ((fm.profile_id = up.id)))
             LEFT JOIN public.profile_info_family_member pifm ON ((fm.profile_id = pifm.profile_id)))
             LEFT JOIN family_child_relationships fcr ON (((fcr.family_id = fm.family_id) AND (fcr.adult_profile_id = fm.profile_id))))
          WHERE ((fm.role = ANY (ARRAY['parent'::text, 'guardian'::text, 'staff'::text, 'other'::text])) AND (fm.removed_at IS NULL))
        ), child_members AS (
         SELECT fmcl.family_id,
            fmcl.child_profile_id AS member_profile_id,
            'child'::text AS member_type,
            up.first_name,
            up.last_name,
            pis.nickname,
            NULL::text AS default_relationship,
            NULL::boolean AS is_primary_guardian,
            fmcl.child_profile_id AS student_id,
            pis.class_id AS student_class,
            pis.date_of_birth,
            NULL::json AS child_relationships
           FROM ((public.family_member_child_links fmcl
             JOIN public.user_profiles up ON ((fmcl.child_profile_id = up.id)))
             LEFT JOIN public.profile_info_student pis ON ((fmcl.child_profile_id = pis.profile_id)))
        )
 SELECT adult_members.family_id,
    adult_members.member_profile_id,
    adult_members.member_type,
    adult_members.first_name,
    adult_members.last_name,
    adult_members.nickname,
    adult_members.default_relationship,
    adult_members.is_primary_guardian,
    adult_members.student_id,
    adult_members.student_class,
    adult_members.date_of_birth,
    adult_members.child_relationships
   FROM adult_members
UNION ALL
 SELECT child_members.family_id,
    child_members.member_profile_id,
    child_members.member_type,
    child_members.first_name,
    child_members.last_name,
    child_members.nickname,
    child_members.default_relationship,
    child_members.is_primary_guardian,
    child_members.student_id,
    child_members.student_class,
    child_members.date_of_birth,
    child_members.child_relationships
   FROM child_members
  ORDER BY 1, 3 DESC, 5, 4;


ALTER VIEW public.vw_family_all_members OWNER TO supabase_admin;

--
-- Name: vw_lesson_attendance_badges; Type: VIEW; Schema: public; Owner: authenticated
--

CREATE VIEW public.vw_lesson_attendance_badges AS
SELECT
    NULL::uuid AS lesson_id,
    NULL::bigint AS total_students,
    NULL::bigint AS present_count,
    NULL::bigint AS late_count,
    NULL::bigint AS absent_count,
    NULL::text AS attendance_status;


ALTER VIEW public.vw_lesson_attendance_badges OWNER TO authenticated;

--
-- Name: vw_lesson_view_enriched; Type: VIEW; Schema: public; Owner: supabase_admin
--

CREATE VIEW public.vw_lesson_view_enriched AS
SELECT
    NULL::uuid AS lesson_id,
    NULL::uuid AS course_id,
    NULL::text AS course_name,
    NULL::uuid AS subject_id,
    NULL::text AS subject_name,
    NULL::uuid AS class_id,
    NULL::text AS class_name,
    NULL::timestamp without time zone AS start_datetime,
    NULL::timestamp without time zone AS end_datetime,
    NULL::uuid[] AS teacher_ids,
    NULL::text[] AS teacher_names,
    NULL::boolean AS substitute_detected,
    NULL::text AS room_name,
    NULL::text[] AS period_names,
    NULL::bigint AS student_count,
    NULL::text[] AS student_names_with_class,
    NULL::bigint AS attendance_present_count,
    NULL::numeric AS attendance_percent,
    NULL::text[] AS warnings,
    NULL::text AS is_type;


ALTER VIEW public.vw_lesson_view_enriched OWNER TO supabase_admin;

--
-- Name: vw_lessons_needing_substitute; Type: VIEW; Schema: public; Owner: supabase_admin
--

CREATE VIEW public.vw_lessons_needing_substitute WITH (security_invoker='true') AS
 WITH relevant_absences AS (
         SELECT staff_absences.id,
            staff_absences.staff_id,
            staff_absences.date,
            staff_absences.reason,
            staff_absences.notes,
            staff_absences.created_at,
            staff_absences.school_id,
            staff_absences.substitution_status,
            staff_absences.is_approved,
            staff_absences.approved_by,
            staff_absences.end_date,
            staff_absences.start_period,
            staff_absences.end_period,
            staff_absences.attachment_url,
            staff_absences.created_by
           FROM public.staff_absences
          WHERE (staff_absences.is_approved = true)
        ), lesson_absences AS (
         SELECT cl_1.id AS lesson_id,
            sa.staff_id,
            sa.is_approved
           FROM ((public.course_lessons cl_1
             JOIN public.schedule_periods sp_1 ON ((sp_1.id = cl_1.period_id)))
             JOIN public.staff_absences sa ON ((sa.staff_id = ANY (cl_1.teacher_ids))))
          WHERE ((cl_1.is_cancelled = false) AND ((cl_1.start_datetime)::date >= sa.date) AND ((cl_1.start_datetime)::date <= COALESCE(sa.end_date, sa.date)) AND (((sa.start_period IS NULL) AND (sa.end_period IS NULL)) OR ((sp_1.block_number IS NOT NULL) AND (sa.start_period IS NOT NULL) AND (sa.end_period IS NOT NULL) AND (sp_1.block_number >= sa.start_period) AND (sp_1.block_number <= sa.end_period))))
        ), proposed_substitutes AS (
         SELECT sub.original_lesson_id,
            array_agg(DISTINCT sub.substitute_staff_id) AS substitute_ids,
            array_agg(DISTINCT concat_ws(' '::text, up.first_name, up.last_name)) AS substitute_names,
            max(
                CASE
                    WHEN (sub.status = 'confirmed'::text) THEN 1
                    WHEN (sub.status = ANY (ARRAY['pending'::text, 'draft'::text])) THEN 2
                    ELSE 3
                END) AS substitution_rank
           FROM (public.substitutions sub
             LEFT JOIN public.user_profiles up ON ((up.id = sub.substitute_staff_id)))
          GROUP BY sub.original_lesson_id
        ), lesson_approval_status AS (
         SELECT lesson_absences.lesson_id,
            bool_or(lesson_absences.is_approved) AS has_approved_absence
           FROM lesson_absences
          GROUP BY lesson_absences.lesson_id
        )
 SELECT cl.id AS lesson_id,
    cl.teacher_ids,
    ARRAY( SELECT concat_ws(' '::text, up.first_name, up.last_name) AS concat_ws
           FROM (unnest(cl.teacher_ids) tid(tid)
             JOIN public.user_profiles up ON ((up.id = tid.tid)))) AS all_teacher_names,
    ARRAY( SELECT la.staff_id
           FROM lesson_absences la
          WHERE (la.lesson_id = cl.id)) AS absent_teacher_ids,
    ARRAY( SELECT concat_ws(' '::text, up.first_name, up.last_name) AS concat_ws
           FROM (lesson_absences la
             JOIN public.user_profiles up ON ((up.id = la.staff_id)))
          WHERE (la.lesson_id = cl.id)) AS absent_teacher_names,
    COALESCE(las.has_approved_absence, false) AS is_approved,
        CASE
            WHEN COALESCE(las.has_approved_absence, false) THEN 'Abwesenheit genehmigt'::text
            ELSE 'Noch nicht genehmigt'::text
        END AS absence_status,
    (cardinality(cl.teacher_ids) > 1) AS has_other_teachers,
    sp.label AS period_label,
    sp.block_number AS period_number,
    subj.name AS subject_name,
    sc.name AS class_name,
    sr.name AS room_name,
    cl.start_datetime,
    sd.id AS day_id,
    sd.name_en AS day_name_en,
    sd.name_de AS day_name_de,
        CASE
            WHEN (ps.substitution_rank = 1) THEN 'confirmed'::text
            WHEN (ps.substitution_rank = 2) THEN 'pending'::text
            WHEN ((ps.substitution_rank IS NULL) AND (cardinality(cl.teacher_ids) > 1)) THEN 'team_teaching'::text
            WHEN (ps.substitution_rank IS NULL) THEN 'required'::text
            ELSE 'required'::text
        END AS substitution_status,
    COALESCE(ps.substitute_ids, ARRAY[]::uuid[]) AS proposed_substitute_ids,
    COALESCE(ps.substitute_names, ARRAY[]::text[]) AS proposed_substitute_names
   FROM (((((((public.course_lessons cl
     LEFT JOIN public.schedule_periods sp ON ((sp.id = cl.period_id)))
     LEFT JOIN public.subjects subj ON ((subj.id = cl.subject_id)))
     LEFT JOIN public.structure_classes sc ON ((sc.id = cl.class_id)))
     LEFT JOIN public.structure_rooms sr ON ((sr.id = cl.room_id)))
     LEFT JOIN public.structure_days sd ON (((EXTRACT(isodow FROM cl.start_datetime))::integer = sd.day_number)))
     LEFT JOIN proposed_substitutes ps ON ((ps.original_lesson_id = cl.id)))
     LEFT JOIN lesson_approval_status las ON ((las.lesson_id = cl.id)))
  WHERE ((cl.is_cancelled = false) AND (EXISTS ( SELECT 1
           FROM lesson_absences la
          WHERE (la.lesson_id = cl.id))) AND ((cl.start_datetime)::date >= CURRENT_DATE));


ALTER VIEW public.vw_lessons_needing_substitute OWNER TO supabase_admin;

--
-- Name: vw_parent_course_windows; Type: VIEW; Schema: public; Owner: supabase_admin
--

CREATE VIEW public.vw_parent_course_windows WITH (security_invoker='true') AS
 WITH windows AS (
         SELECT w_1.id AS window_id,
            w_1.school_id,
            w_1.semester_id,
            w_1.registration_period_id,
            rp.title AS period_title,
            rp.status AS period_status,
            rp.max_wishes_total,
            rp.max_wishes_per_day,
            w_1.course_id,
            c.name AS course_name,
            c.course_code,
            c.is_active AS course_active,
            w_1.opens_at,
            w_1.closes_at,
            w_1.grade_levels,
            c.description_visible_to_parents,
            c.description AS course_description,
            c.wichtige_infos AS course_wichtige_infos,
            c.pictures AS course_pictures
           FROM ((public.course_registration_windows w_1
             JOIN public.registration_periods rp ON ((rp.id = w_1.registration_period_id)))
             JOIN public.course_list c ON ((c.id = w_1.course_id)))
          WHERE (c.is_active = true)
        ), sched AS (
         SELECT s_1.window_id,
            array_agg(s_1.day_id ORDER BY s_1.day_id) FILTER (WHERE (s_1.day_id IS NOT NULL)) AS schedule_day_ids,
            array_agg(s_1.period_id ORDER BY s_1.period_id) FILTER (WHERE (s_1.period_id IS NOT NULL)) AS schedule_period_ids,
            array_agg(s_1.time_range ORDER BY s_1.time_range) AS schedule_time_ranges,
            array_agg(jsonb_build_object('day_id', s_1.day_id, 'period_id', s_1.period_id, 'start_time', s_1.start_time_fmt, 'end_time', s_1.end_time_fmt) ORDER BY s_1.day_id, s_1.period_id, s_1.start_time) AS schedule_slots
           FROM ( SELECT DISTINCT w_1.window_id,
                    cs.day_id,
                    cs.period_id,
                    to_char((cs.start_time)::interval, 'HH24:MI'::text) AS start_time_fmt,
                    to_char((cs.end_time)::interval, 'HH24:MI'::text) AS end_time_fmt,
                    ((to_char((cs.start_time)::interval, 'HH24:MI'::text) || '-'::text) || to_char((cs.end_time)::interval, 'HH24:MI'::text)) AS time_range,
                    cs.start_time
                   FROM (windows w_1
                     JOIN public.course_schedules cs ON (((cs.school_id = w_1.school_id) AND (cs.course_id = w_1.course_id) AND (COALESCE(cs.is_archived, false) = false) AND (daterange(cs.start_date, cs.end_date, '[]'::text) && daterange((w_1.opens_at)::date, (w_1.closes_at)::date, '[]'::text)))))) s_1
          GROUP BY s_1.window_id
        )
 SELECT w.window_id,
    w.school_id,
    w.semester_id,
    w.registration_period_id,
    w.period_title,
    w.period_status,
    w.max_wishes_total,
    w.max_wishes_per_day,
    w.course_id,
    w.course_name,
    w.course_code,
    w.course_active,
    w.opens_at,
    w.closes_at,
    w.grade_levels,
    ((now() >= w.opens_at) AND (now() <= w.closes_at)) AS is_open,
    (now() < w.opens_at) AS is_scheduled,
    (now() >= w.closes_at) AS is_closed,
    s.schedule_day_ids,
    s.schedule_period_ids,
    s.schedule_time_ranges,
    s.schedule_slots,
    w.description_visible_to_parents,
    w.course_description,
        CASE
            WHEN w.description_visible_to_parents THEN w.course_description
            ELSE NULL::text
        END AS course_description_for_parents,
    w.course_wichtige_infos,
    w.course_pictures,
        CASE
            WHEN (array_length(w.course_pictures, 1) >= 1) THEN w.course_pictures[1]
            ELSE NULL::text
        END AS course_picture_first
   FROM (windows w
     LEFT JOIN sched s ON ((s.window_id = w.window_id)))
  ORDER BY w.closes_at;


ALTER VIEW public.vw_parent_course_windows OWNER TO supabase_admin;

--
-- Name: vw_parent_open_registration_cta; Type: VIEW; Schema: public; Owner: supabase_admin
--

CREATE VIEW public.vw_parent_open_registration_cta WITH (security_invoker='true') AS
 WITH windows AS (
         SELECT w.id,
            w.school_id,
            w.course_id,
            w.semester_id,
            w.opens_at,
            w.closes_at,
            w.created_at,
            w.created_by,
            w.registration_period_id,
            w.grade_levels
           FROM (public.course_registration_windows w
             JOIN public.course_list c ON ((c.id = w.course_id)))
          WHERE (c.is_active = true)
        ), period_bounds AS (
         SELECT w.registration_period_id,
            min(w.opens_at) AS opens_first_at,
            max(w.closes_at) AS closes_last_at
           FROM windows w
          GROUP BY w.registration_period_id
        ), period_grades AS (
         SELECT w.registration_period_id,
            unnest(COALESCE(w.grade_levels, '{}'::integer[])) AS g
           FROM windows w
        ), grades_agg AS (
         SELECT period_grades.registration_period_id,
            array_agg(DISTINCT period_grades.g ORDER BY period_grades.g) AS eligible_grades
           FROM period_grades
          GROUP BY period_grades.registration_period_id
        ), periods AS (
         SELECT rp.id AS registration_period_id,
            rp.school_id,
            rp.semester_id,
            rp.title AS period_title,
            pb.opens_first_at,
            pb.closes_last_at,
            ga.eligible_grades
           FROM ((public.registration_periods rp
             JOIN period_bounds pb ON ((pb.registration_period_id = rp.id)))
             LEFT JOIN grades_agg ga ON ((ga.registration_period_id = rp.id)))
        )
 SELECT p.registration_period_id,
    p.school_id,
    p.semester_id,
    p.period_title,
    p.opens_first_at,
    p.closes_last_at,
    p.eligible_grades,
    (((now() AT TIME ZONE 'Europe/Berlin'::text) >= p.opens_first_at) AND ((now() AT TIME ZONE 'Europe/Berlin'::text) <= p.closes_last_at)) AS is_open,
    ('Die Flex-Module sind jetzt ge철ffnet  bis '::text || to_char((p.closes_last_at AT TIME ZONE 'Europe/Berlin'::text), 'DD.MM.YYYY'::text)) AS headline_de,
    'Jetzt w채hlen'::text AS cta_label_de,
    ('/parent/registration?period_id='::text || (p.registration_period_id)::text) AS cta_href
   FROM periods p
  WHERE (((now() AT TIME ZONE 'Europe/Berlin'::text) >= p.opens_first_at) AND ((now() AT TIME ZONE 'Europe/Berlin'::text) <= p.closes_last_at))
  ORDER BY p.closes_last_at;


ALTER VIEW public.vw_parent_open_registration_cta OWNER TO supabase_admin;

--
-- Name: vw_react_lesson_details; Type: VIEW; Schema: public; Owner: authenticated
--

CREATE VIEW public.vw_react_lesson_details WITH (security_invoker='true') AS
 SELECT cl.id AS lesson_id,
    s.name AS subject_name,
    sc.name AS class_name,
    sr.name AS room_name,
    cl.start_datetime,
    cl.end_datetime,
        CASE
            WHEN (sub.id IS NOT NULL) THEN 'substitute'::text
            WHEN (cl.is_cancelled = true) THEN 'cancelled'::text
            ELSE 'regular'::text
        END AS lesson_type,
    (sub.id IS NOT NULL) AS is_substitute,
    cl.is_cancelled,
    sub.substitute_staff_id,
    sub.reason AS cancellation_reason,
    COALESCE(cl.primary_teacher_id, cl.teacher_ids[1]) AS assigned_teacher_id,
        CASE
            WHEN (sub.substitute_staff_id IS NOT NULL) THEN ARRAY[concat(COALESCE(sub_teacher.first_name, ''::text), ' ', COALESCE(sub_teacher.last_name, ''::text))]
            ELSE
            CASE
                WHEN (array_length(cl.teacher_ids, 1) > 0) THEN ARRAY( SELECT concat(up.first_name, ' ', up.last_name) AS concat
                   FROM (unnest(cl.teacher_ids) tid(tid)
                     JOIN public.user_profiles up ON ((up.id = tid.tid)))
                  ORDER BY up.first_name, up.last_name)
                WHEN (cl.primary_teacher_id IS NOT NULL) THEN ARRAY[concat(primary_teacher.first_name, ' ', primary_teacher.last_name)]
                ELSE ARRAY[]::text[]
            END
        END AS teacher_names,
    count(DISTINCT COALESCE(ce.student_id, pis_class.profile_id)) AS student_count,
    array_agg(DISTINCT concat(COALESCE(up_course.first_name, up_class.first_name), ' ', COALESCE(up_course.last_name, up_class.last_name), ' (', COALESCE(sc_course.name, sc_class.name), ')')) FILTER (WHERE (COALESCE(up_course.id, up_class.id) IS NOT NULL)) AS student_names_with_class,
    date(cl.start_datetime) AS lesson_date,
    sp.block_number AS period_number,
    cl.notes,
    (count(sal.id) > 0) AS attendance_taken,
    cl.course_id,
    cl.subject_id,
    cl.class_id,
    cl.room_id,
    cl.school_id,
    s.color AS subject_color,
    s.abbreviation AS subject_abbreviation,
    sc.year AS class_year,
    sc.grade_level,
    sr.room_number,
    sr.building,
    sp.start_time AS period_start_time,
    sp.end_time AS period_end_time,
    sp.label AS period_label
   FROM (((((((((((((((public.course_lessons cl
     LEFT JOIN public.subjects s ON ((cl.subject_id = s.id)))
     LEFT JOIN public.structure_classes sc ON ((cl.class_id = sc.id)))
     LEFT JOIN public.structure_rooms sr ON ((cl.room_id = sr.id)))
     LEFT JOIN public.schedule_periods sp ON ((cl.period_id = sp.id)))
     LEFT JOIN public.substitutions sub ON ((sub.original_lesson_id = cl.id)))
     LEFT JOIN public.user_profiles sub_teacher ON ((sub.substitute_staff_id = sub_teacher.id)))
     LEFT JOIN public.user_profiles primary_teacher ON ((cl.primary_teacher_id = primary_teacher.id)))
     LEFT JOIN public.course_enrollments ce ON (((ce.course_id = cl.course_id) AND ((cl.start_datetime)::date >= ce.start_date) AND ((cl.start_datetime)::date <= ce.end_date))))
     LEFT JOIN public.user_profiles up_course ON ((up_course.id = ce.student_id)))
     LEFT JOIN public.profile_info_student pis_course ON ((pis_course.profile_id = ce.student_id)))
     LEFT JOIN public.structure_classes sc_course ON ((sc_course.id = pis_course.class_id)))
     LEFT JOIN public.profile_info_student pis_class ON (((pis_class.class_id = cl.class_id) AND (cl.course_id IS NULL))))
     LEFT JOIN public.user_profiles up_class ON ((up_class.id = pis_class.profile_id)))
     LEFT JOIN public.structure_classes sc_class ON ((sc_class.id = pis_class.class_id)))
     LEFT JOIN public.student_attendance_logs sal ON ((sal.lesson_id = cl.id)))
  WHERE (cl.is_archived = false)
  GROUP BY cl.id, s.name, sc.name, sr.name, cl.start_datetime, cl.end_datetime, cl.is_cancelled, sub.id, sub.substitute_staff_id, sub.reason, cl.primary_teacher_id, cl.teacher_ids, sub_teacher.first_name, sub_teacher.last_name, primary_teacher.first_name, primary_teacher.last_name, sp.block_number, cl.notes, cl.course_id, cl.subject_id, cl.class_id, cl.room_id, cl.school_id, s.color, s.abbreviation, sc.year, sc.grade_level, sr.room_number, sr.building, sp.start_time, sp.end_time, sp.label
  ORDER BY cl.start_datetime DESC;


ALTER VIEW public.vw_react_lesson_details OWNER TO authenticated;

--
-- Name: vw_registration_period_courses_by_day; Type: VIEW; Schema: public; Owner: supabase_admin
--

CREATE VIEW public.vw_registration_period_courses_by_day WITH (security_invoker='true') AS
 WITH windows AS (
         SELECT crw.id AS window_id,
            crw.course_id,
            crw.school_id,
            crw.registration_period_id,
            crw.semester_id,
            crw.opens_at,
            crw.closes_at,
            COALESCE(crw.grade_levels, cl.is_for_year_g) AS grade_levels_effective,
            cl.name AS course_name,
            cl.max_students
           FROM (public.course_registration_windows crw
             JOIN public.course_list cl ON ((cl.id = crw.course_id)))
          WHERE (cl.is_active = true)
        ), course_days AS (
         SELECT DISTINCT w_1.window_id,
            w_1.course_id,
            w_1.school_id,
            w_1.registration_period_id,
            w_1.semester_id,
            cs.day_id
           FROM (windows w_1
             JOIN public.course_schedules cs ON ((cs.course_id = w_1.course_id)))
        ), days AS (
         SELECT d_1.id AS day_id,
            d_1.day_number AS day_of_week,
            d_1.name_en AS day_name
           FROM public.structure_days d_1
          WHERE ((d_1.day_number >= 1) AND (d_1.day_number <= 5))
        ), teacher_names AS (
         SELECT cs.course_id,
            cs.day_id,
            string_agg(DISTINCT ((up.first_name || ' '::text) || up.last_name), ', '::text ORDER BY ((up.first_name || ' '::text) || up.last_name)) AS teacher
           FROM ((public.course_schedules cs
             LEFT JOIN LATERAL unnest(cs.teacher_ids) t(teacher_id) ON (true))
             LEFT JOIN public.user_profiles up ON ((up.id = t.teacher_id)))
          GROUP BY cs.course_id, cs.day_id
        ), room_names AS (
         SELECT cs.course_id,
            cs.day_id,
            COALESCE(string_agg(DISTINCT r.name, ', '::text ORDER BY r.name), ''::text) AS room
           FROM (public.course_schedules cs
             LEFT JOIN public.structure_rooms r ON ((r.id = cs.room_id)))
          GROUP BY cs.course_id, cs.day_id
        ), available_grades AS (
         SELECT w_1.course_id,
            w_1.school_id,
            string_agg(DISTINCT sc.name, ','::text ORDER BY sc.name) AS available_grades
           FROM (windows w_1
             LEFT JOIN public.structure_classes sc ON (((sc.school_id = w_1.school_id) AND (w_1.grade_levels_effective IS NOT NULL) AND (sc.grade_level = ANY (w_1.grade_levels_effective)))))
          GROUP BY w_1.course_id, w_1.school_id
        ), enrolled_counts AS (
         SELECT w_1.course_id,
            cs.day_id,
            w_1.semester_id,
            count(DISTINCT ce.student_id) AS enrolled_count
           FROM (((windows w_1
             JOIN public.course_schedules cs ON ((cs.course_id = w_1.course_id)))
             LEFT JOIN public.structure_school_semesters sss ON ((sss.id = w_1.semester_id)))
             LEFT JOIN public.course_enrollments ce ON (((ce.course_id = w_1.course_id) AND ((ce.start_date IS NULL) OR (sss.end_date IS NULL) OR (ce.start_date <= sss.end_date)) AND ((ce.end_date IS NULL) OR (sss.start_date IS NULL) OR (ce.end_date >= sss.start_date)))))
          GROUP BY w_1.course_id, cs.day_id, w_1.semester_id
        ), draft_enrolled_counts AS (
         SELECT cad.registration_period_id,
            cad.semester_id,
            cad.school_id,
            cad.day_of_week,
            cad.target_course_id AS course_id,
            count(*) AS draft_enrolled_count
           FROM public.course_allocation_drafts cad
          WHERE (cad.target_course_id IS NOT NULL)
          GROUP BY cad.registration_period_id, cad.semester_id, cad.school_id, cad.day_of_week, cad.target_course_id
        )
 SELECT cd.course_id AS id,
    w.window_id,
    w.course_name AS name,
    COALESCE(tn.teacher, ''::text) AS teacher,
    COALESCE(rm.room, ''::text) AS room,
    w.max_students AS max_capacity,
    COALESCE(ag.available_grades, ''::text) AS available_grades,
    d.day_name AS day,
    d.day_of_week,
    ((now() < w.opens_at) OR (now() > w.closes_at)) AS is_locked,
    COALESCE(dc.draft_enrolled_count, COALESCE(ec.enrolled_count, (0)::bigint)) AS enrolled_count,
    w.school_id,
    w.registration_period_id,
    w.semester_id
   FROM (((((((course_days cd
     JOIN windows w ON ((w.window_id = cd.window_id)))
     JOIN days d ON ((d.day_id = cd.day_id)))
     LEFT JOIN teacher_names tn ON (((tn.course_id = cd.course_id) AND (tn.day_id = cd.day_id))))
     LEFT JOIN room_names rm ON (((rm.course_id = cd.course_id) AND (rm.day_id = cd.day_id))))
     LEFT JOIN available_grades ag ON (((ag.course_id = cd.course_id) AND (ag.school_id = cd.school_id))))
     LEFT JOIN enrolled_counts ec ON (((ec.course_id = cd.course_id) AND (ec.day_id = cd.day_id) AND (ec.semester_id = w.semester_id))))
     LEFT JOIN draft_enrolled_counts dc ON (((dc.registration_period_id = w.registration_period_id) AND (dc.semester_id = w.semester_id) AND (dc.school_id = w.school_id) AND (dc.day_of_week = d.day_of_week) AND (dc.course_id = cd.course_id))));


ALTER VIEW public.vw_registration_period_courses_by_day OWNER TO supabase_admin;

--
-- Name: vw_registration_period_students_by_day; Type: VIEW; Schema: public; Owner: supabase_admin
--

CREATE VIEW public.vw_registration_period_students_by_day WITH (security_invoker='true') AS
 WITH submissions AS (
         SELECT sws.id AS submission_id,
            sws.student_id,
            sws.school_id,
            sws.registration_period_id,
            sws.semester_id
           FROM public.student_course_wish_submissions sws
        ), choices_pivot AS (
         SELECT scwc.submission_id,
            scwc.day_of_week,
            bool_or(scwc.no_offer) AS has_no_offer,
            max(
                CASE
                    WHEN (scwc.rank = 1) THEN (scwc.window_id)::text
                    ELSE NULL::text
                END) AS rank1_window,
            max(
                CASE
                    WHEN (scwc.rank = 2) THEN (scwc.window_id)::text
                    ELSE NULL::text
                END) AS rank2_window,
            max(
                CASE
                    WHEN (scwc.rank = 3) THEN (scwc.window_id)::text
                    ELSE NULL::text
                END) AS rank3_window
           FROM public.student_course_wish_choices scwc
          GROUP BY scwc.submission_id, scwc.day_of_week
        ), students AS (
         SELECT p.id AS student_id,
            concat_ws(' '::text, p.first_name, p.last_name) AS full_name,
            COALESCE(c.name, ''::text) AS class_name
           FROM ((public.user_profiles p
             JOIN public.profile_info_student s_1 ON ((s_1.profile_id = p.id)))
             LEFT JOIN public.structure_classes c ON ((s_1.class_id = c.id)))
        )
 SELECT s.student_id AS id,
    st.full_name AS name,
    st.class_name AS class,
        CASE
            WHEN ((cp.has_no_offer IS TRUE) AND (cp.rank1_window IS NULL)) THEN 'go-home'::text
            ELSE COALESCE(cp.rank1_window, 'go-home'::text)
        END AS first_choice,
    COALESCE(cp.rank2_window, 'go-home'::text) AS second_choice,
    COALESCE(cp.rank3_window, 'go-home'::text) AS third_choice,
    cp.day_of_week,
    s.school_id,
    s.registration_period_id,
    s.semester_id,
        CASE
            WHEN (cad.special_target = ANY (ARRAY['waiting'::text, 'go-home'::text])) THEN NULL::uuid
            ELSE COALESCE(cad.target_course_id, fe.course_id)
        END AS current_enrollment
   FROM ((((submissions s
     JOIN choices_pivot cp ON ((cp.submission_id = s.submission_id)))
     JOIN students st ON ((st.student_id = s.student_id)))
     LEFT JOIN LATERAL ( SELECT ce2.course_id
           FROM ((((public.course_enrollments ce2
             JOIN public.course_schedules cs2 ON ((cs2.course_id = ce2.course_id)))
             JOIN public.structure_days sd2 ON ((sd2.id = cs2.day_id)))
             JOIN public.course_registration_windows w2 ON (((w2.course_id = ce2.course_id) AND (w2.school_id = s.school_id) AND (w2.registration_period_id = s.registration_period_id) AND (w2.semester_id = s.semester_id))))
             JOIN public.structure_school_semesters sb ON ((sb.id = s.semester_id)))
          WHERE ((ce2.student_id = s.student_id) AND (sd2.day_number = cp.day_of_week) AND ((ce2.start_date IS NULL) OR (sb.end_date IS NULL) OR (ce2.start_date <= sb.end_date)) AND ((ce2.end_date IS NULL) OR (sb.start_date IS NULL) OR (ce2.end_date >= sb.start_date)))
          ORDER BY cs2.start_time, ce2.course_id
         LIMIT 1) fe ON (true))
     LEFT JOIN public.course_allocation_drafts cad ON (((cad.registration_period_id = s.registration_period_id) AND (cad.semester_id = s.semester_id) AND (cad.school_id = s.school_id) AND (cad.student_id = s.student_id) AND (cad.day_of_week = cp.day_of_week))))
  WHERE ((cp.day_of_week >= 1) AND (cp.day_of_week <= 5));


ALTER VIEW public.vw_registration_period_students_by_day OWNER TO supabase_admin;

--
-- Name: vw_school_days; Type: VIEW; Schema: public; Owner: supabase_admin
--

CREATE VIEW public.vw_school_days WITH (security_invoker='true') AS
 SELECT sd.school_id,
    d.id AS day_id,
    d.day_number,
    d.name_en,
    d.name_de
   FROM (public.structure_school_days sd
     JOIN public.structure_days d ON ((sd.day_id = d.id)));


ALTER VIEW public.vw_school_days OWNER TO supabase_admin;

--
-- Name: vw_staff; Type: VIEW; Schema: public; Owner: supabase_admin
--

CREATE VIEW public.vw_staff WITH (security_invoker='true') AS
 WITH staff_contacts AS (
         SELECT c.profile_id,
            json_agg(jsonb_build_object('id', c.id, 'contact_type', c.type, 'contact_value', c.value, 'notes', c.notes, 'is_primary', c.is_primary, 'status', c.status) ORDER BY c.is_primary DESC, c.type) AS contacts
           FROM public.contacts c
          WHERE (c.status = 'valid'::text)
          GROUP BY c.profile_id
        )
 SELECT u.id,
    u.first_name,
    u.last_name,
    u.date_of_birth,
    u.gender,
    u.school_id,
    u.profile_picture_url,
    u.account_status,
    s.status,
    s.login_active,
    s.last_invited_at,
    s.joined_at,
    s.employee_id,
    s.colour,
    u.role_id,
    COALESCE(sc.contacts, '[]'::json) AS contacts
   FROM ((public.user_profiles u
     JOIN public.profile_info_staff s ON ((u.id = s.profile_id)))
     LEFT JOIN staff_contacts sc ON ((sc.profile_id = u.id)))
  ORDER BY u.school_id, u.last_name, u.first_name;


ALTER VIEW public.vw_staff OWNER TO supabase_admin;

--
-- Name: vw_staff_availability_next_7_days; Type: VIEW; Schema: public; Owner: supabase_admin
--

CREATE VIEW public.vw_staff_availability_next_7_days WITH (security_invoker='true') AS
 WITH active_staff AS (
         SELECT up.id AS staff_id,
            up.first_name,
            up.last_name,
            up.school_id,
            up.profile_picture_url,
            COALESCE(r.name, 'Unknown'::text) AS role_name
           FROM (((public.user_profiles up
             LEFT JOIN public.user_roles ur ON ((ur.user_profile_id = up.id)))
             LEFT JOIN public.roles r ON ((r.id = ur.role_id)))
             JOIN public.profile_info_staff pis ON ((pis.profile_id = up.id)))
          WHERE ((r.name = ANY (ARRAY['Teacher'::text, 'Admin'::text])) OR (r.name IS NULL))
        ), next_7_days AS (
         SELECT ((CURRENT_DATE + ((i.i)::double precision * '1 day'::interval)))::date AS actual_date
           FROM generate_series(0, 6) i(i)
        ), school_days AS (
         SELECT structure_days.id AS day_id,
            structure_days.day_number,
            structure_days.name_en,
            structure_days.name_de
           FROM public.structure_days
        ), slot_matrix AS (
         SELECT s_1.staff_id,
            s_1.first_name,
            s_1.last_name,
            s_1.school_id,
            s_1.profile_picture_url,
            s_1.role_name,
            d.actual_date AS date,
            sd.day_id,
            sd.day_number,
            sd.name_en AS day_name_en,
            sd.name_de AS day_name_de,
            p.id AS period_id,
            p.block_number,
            p.start_time,
            p.end_time,
            p.label AS period_label
           FROM (((active_staff s_1
             CROSS JOIN next_7_days d)
             JOIN school_days sd ON (((sd.day_number)::numeric = EXTRACT(dow FROM d.actual_date))))
             JOIN public.schedule_periods p ON (((p.school_id = s_1.school_id) AND (p.block_type = 'instructional'::text))))
        ), holiday_days AS (
         SELECT schedule_calendar_exceptions.school_id,
            schedule_calendar_exceptions.date,
            schedule_calendar_exceptions.end_date,
            schedule_calendar_exceptions.notes
           FROM public.schedule_calendar_exceptions
          WHERE (schedule_calendar_exceptions.type = ANY (ARRAY['holiday'::text, 'school_closed'::text, 'no_courses'::text]))
        ), lesson_staff_info AS (
         SELECT cl.id AS lesson_id,
            (cl.start_datetime)::date AS lesson_date,
            cl.period_id,
            unnest(cl.teacher_ids) AS staff_id,
            subj.name AS subject_name,
            sc.name AS class_name,
            cl.meeting_name,
            cl.is_cancelled,
            cl.school_id
           FROM ((public.course_lessons cl
             LEFT JOIN public.subjects subj ON ((subj.id = cl.subject_id)))
             LEFT JOIN public.structure_classes sc ON ((sc.id = cl.class_id)))
          WHERE (((cl.start_datetime)::date >= CURRENT_DATE) AND ((cl.start_datetime)::date <= (CURRENT_DATE + '6 days'::interval)))
        ), colleagues AS (
         SELECT l.id AS lesson_id,
            array_agg(DISTINCT ((up.first_name || ' '::text) || up.last_name)) AS colleague_names
           FROM (public.course_lessons l
             LEFT JOIN public.user_profiles up ON ((up.id = ANY (l.teacher_ids))))
          WHERE (((l.start_datetime)::date >= CURRENT_DATE) AND ((l.start_datetime)::date <= (CURRENT_DATE + '6 days'::interval)))
          GROUP BY l.id
        ), absences AS (
         SELECT staff_absences.staff_id,
            staff_absences.date AS absence_date,
            staff_absences.start_period,
            staff_absences.end_period,
            staff_absences.reason AS absence_reason
           FROM public.staff_absences
          WHERE ((staff_absences.is_approved = true) AND (staff_absences.date >= CURRENT_DATE) AND (staff_absences.date <= (CURRENT_DATE + '6 days'::interval)))
        ), substituting AS (
         SELECT sub.substitute_staff_id AS staff_id,
            (cl.start_datetime)::date AS date,
            cl.period_id
           FROM (public.substitutions sub
             JOIN public.course_lessons cl ON ((cl.id = sub.original_lesson_id)))
          WHERE (((cl.start_datetime)::date >= CURRENT_DATE) AND ((cl.start_datetime)::date <= (CURRENT_DATE + '6 days'::interval)) AND (sub.status = ANY (ARRAY['draft'::text, 'confirmed'::text])))
        ), slots AS (
         SELECT sm.staff_id,
            sm.first_name,
            sm.last_name,
            sm.school_id,
            sm.profile_picture_url,
            sm.role_name,
            sm.date,
            sm.day_id,
            sm.day_number,
            sm.day_name_en,
            sm.day_name_de,
            sm.period_id,
            sm.block_number,
            sm.start_time,
            sm.end_time,
            sm.period_label,
            lsi.lesson_id,
            lsi.subject_name,
            lsi.class_name,
            lsi.meeting_name,
            lsi.is_cancelled,
            c.colleague_names,
            a.absence_reason,
                CASE
                    WHEN (h.school_id IS NOT NULL) THEN 'no_school'::text
                    WHEN lsi.is_cancelled THEN 'cancelled'::text
                    WHEN (s2.staff_id IS NOT NULL) THEN 'substituting'::text
                    WHEN ((lsi.lesson_id IS NOT NULL) AND (cardinality(c.colleague_names) > 1)) THEN 'team_teaching'::text
                    WHEN (lsi.lesson_id IS NOT NULL) THEN 'teaching'::text
                    WHEN (a.staff_id IS NOT NULL) THEN 'absent'::text
                    ELSE 'not_scheduled'::text
                END AS status,
            h.notes AS holiday_or_event_name
           FROM (((((slot_matrix sm
             LEFT JOIN lesson_staff_info lsi ON (((lsi.staff_id = sm.staff_id) AND (lsi.lesson_date = sm.date) AND (lsi.period_id = sm.period_id))))
             LEFT JOIN colleagues c ON ((c.lesson_id = lsi.lesson_id)))
             LEFT JOIN absences a ON (((a.staff_id = sm.staff_id) AND (a.absence_date = sm.date) AND (sm.block_number >= COALESCE(a.start_period, sm.block_number)) AND (sm.block_number <= COALESCE(a.end_period, sm.block_number)))))
             LEFT JOIN substituting s2 ON (((s2.staff_id = sm.staff_id) AND (s2.date = sm.date) AND (s2.period_id = sm.period_id))))
             LEFT JOIN LATERAL ( SELECT h_1.school_id,
                    h_1.date,
                    h_1.end_date,
                    h_1.notes
                   FROM holiday_days h_1
                  WHERE ((h_1.school_id = sm.school_id) AND (sm.date >= h_1.date) AND (sm.date <= COALESCE(h_1.end_date, h_1.date)))
                 LIMIT 1) h ON (true))
        ), on_duty AS (
         SELECT slots.staff_id,
            slots.date,
            bool_or((slots.status = ANY (ARRAY['teaching'::text, 'team_teaching'::text, 'substituting'::text]))) AS is_on_duty_today
           FROM slots
          GROUP BY slots.staff_id, slots.date
        )
 SELECT s.staff_id,
    s.first_name,
    s.last_name,
    s.school_id,
    s.profile_picture_url,
    s.role_name,
    s.date,
    s.day_id,
    s.day_number,
    s.day_name_en,
    s.day_name_de,
    s.period_id,
    s.block_number,
    s.start_time,
    s.end_time,
    s.period_label,
    s.lesson_id,
    s.subject_name,
    s.class_name,
    s.meeting_name,
    s.is_cancelled,
    s.colleague_names,
    s.absence_reason,
    s.status,
    s.holiday_or_event_name,
    od.is_on_duty_today,
        CASE
            WHEN (od.is_on_duty_today = false) THEN 'heute nicht im Dienst'::text
            ELSE NULL::text
        END AS dienst_status_text,
        CASE
            WHEN (s.status = 'absent'::text) THEN 5
            WHEN (s.status = ANY (ARRAY['no_school'::text, 'cancelled'::text])) THEN 6
            WHEN ((od.is_on_duty_today = false) AND (s.status = 'not_scheduled'::text)) THEN 4
            WHEN (s.status = 'teaching'::text) THEN 5
            WHEN (s.status = 'substituting'::text) THEN 3
            WHEN (s.status = 'team_teaching'::text) THEN 2
            WHEN ((od.is_on_duty_today = true) AND (s.status = 'not_scheduled'::text)) THEN 1
            ELSE 99
        END AS availability_sort_number
   FROM (slots s
     LEFT JOIN on_duty od ON (((od.staff_id = s.staff_id) AND (od.date = s.date))))
  ORDER BY
        CASE
            WHEN (s.status = 'absent'::text) THEN 5
            WHEN (s.status = ANY (ARRAY['no_school'::text, 'cancelled'::text])) THEN 6
            WHEN ((od.is_on_duty_today = false) AND (s.status = 'not_scheduled'::text)) THEN 4
            WHEN (s.status = 'teaching'::text) THEN 5
            WHEN (s.status = 'substituting'::text) THEN 3
            WHEN (s.status = 'team_teaching'::text) THEN 2
            WHEN ((od.is_on_duty_today = true) AND (s.status = 'not_scheduled'::text)) THEN 1
            ELSE 99
        END, s.staff_id, s.date, s.block_number;


ALTER VIEW public.vw_staff_availability_next_7_days OWNER TO supabase_admin;

--
-- Name: vw_staff_period_availability; Type: VIEW; Schema: public; Owner: supabase_admin
--

CREATE VIEW public.vw_staff_period_availability WITH (security_invoker='true') AS
 WITH teaching_roles AS (
         SELECT r.id AS role_id
           FROM public.roles r
          WHERE (r.name = ANY (ARRAY['Teacher'::text, 'Admin'::text]))
        ), teaching_staff AS (
         SELECT up.id AS staff_id,
            ((up.first_name || ' '::text) || up.last_name) AS full_name,
            r.name AS role
           FROM (((public.user_profiles up
             JOIN public.user_roles ur ON ((ur.user_profile_id = up.id)))
             JOIN teaching_roles tr ON ((ur.role_id = tr.role_id)))
             JOIN public.roles r ON ((ur.role_id = r.id)))
        ), school_periods AS (
         SELECT sp_1.id AS period_id,
            sp_1.school_id,
            sp_1.block_number,
            sp_1.label AS period_label,
            sp_1.start_time,
            sp_1.end_time
           FROM public.schedule_periods sp_1
          ORDER BY sp_1.block_number
        ), staff_absences AS (
         SELECT sa.staff_id,
            sa.date,
            sa.end_date,
            sa.start_period,
            sa.end_period,
            sa.is_approved
           FROM public.staff_absences sa
          WHERE (sa.is_approved = true)
        ), lesson_teachers AS (
         SELECT cl.id AS lesson_id,
            cl.period_id,
            cl.is_cancelled,
            t.teacher_id,
            cl.start_datetime
           FROM (public.course_lessons cl
             JOIN LATERAL unnest(cl.teacher_ids) t(teacher_id) ON (true))
        ), lesson_details AS (
         SELECT cl.id AS lesson_id,
            cl.period_id,
            cl.class_id,
            cl.subject_id,
            cl.room_id,
            cl.is_cancelled
           FROM public.course_lessons cl
        ), staff_scheduled_or_absent_today AS (
         SELECT ts_1.staff_id,
                CASE
                    WHEN (EXISTS ( SELECT 1
                       FROM lesson_teachers lt
                      WHERE ((lt.teacher_id = ts_1.staff_id) AND (lt.is_cancelled = false) AND ((lt.start_datetime)::date = (CURRENT_DATE AT TIME ZONE 'Europe/Berlin'::text))))) THEN true
                    WHEN (EXISTS ( SELECT 1
                       FROM staff_absences sa
                      WHERE ((sa.staff_id = ts_1.staff_id) AND (sa.date <= (CURRENT_DATE AT TIME ZONE 'Europe/Berlin'::text)) AND ((sa.end_date IS NULL) OR (sa.end_date >= (CURRENT_DATE AT TIME ZONE 'Europe/Berlin'::text)))))) THEN true
                    ELSE false
                END AS is_scheduled_or_absent_today
           FROM teaching_staff ts_1
        )
 SELECT ts.staff_id,
    ts.full_name,
    ts.role,
    sp.school_id,
    sp.block_number AS period_number,
    sp.period_label,
        CASE
            WHEN (EXISTS ( SELECT 1
               FROM staff_absences sa
              WHERE ((sa.staff_id = ts.staff_id) AND (sa.date <= (CURRENT_DATE AT TIME ZONE 'Europe/Berlin'::text)) AND ((sa.end_date IS NULL) OR (sa.end_date >= (CURRENT_DATE AT TIME ZONE 'Europe/Berlin'::text))) AND ((sa.start_period IS NULL) OR (sa.start_period <= sp.block_number)) AND ((sa.end_period IS NULL) OR (sa.end_period >= sp.block_number))))) THEN 'MARKED ABSENT'::text
            WHEN (EXISTS ( SELECT 1
               FROM lesson_teachers lt
              WHERE ((lt.teacher_id = ts.staff_id) AND (lt.period_id = sp.period_id) AND (lt.is_cancelled = false) AND ((lt.start_datetime)::date = (CURRENT_DATE AT TIME ZONE 'Europe/Berlin'::text))))) THEN 'BUSY'::text
            WHEN (ssat.is_scheduled_or_absent_today = false) THEN 'NOT SCHEDULED TODAY'::text
            ELSE 'AVAILABLE'::text
        END AS status,
        CASE
            WHEN (EXISTS ( SELECT 1
               FROM (lesson_teachers lt
                 JOIN lesson_details ld ON ((ld.lesson_id = lt.lesson_id)))
              WHERE ((lt.teacher_id = ts.staff_id) AND (lt.period_id = sp.period_id) AND (lt.is_cancelled = false) AND ((lt.start_datetime)::date = (CURRENT_DATE AT TIME ZONE 'Europe/Berlin'::text))))) THEN ( SELECT concat('Class: ', ld.class_id, ', Subject: ', ld.subject_id, ', Room: ', ld.room_id) AS concat
               FROM (lesson_teachers lt
                 JOIN lesson_details ld ON ((ld.lesson_id = lt.lesson_id)))
              WHERE ((lt.teacher_id = ts.staff_id) AND (lt.period_id = sp.period_id) AND (lt.is_cancelled = false) AND ((lt.start_datetime)::date = (CURRENT_DATE AT TIME ZONE 'Europe/Berlin'::text)))
             LIMIT 1)
            ELSE NULL::text
        END AS lesson_info
   FROM ((teaching_staff ts
     CROSS JOIN school_periods sp)
     LEFT JOIN staff_scheduled_or_absent_today ssat ON ((ssat.staff_id = ts.staff_id)))
  ORDER BY ts.full_name, sp.block_number;


ALTER VIEW public.vw_staff_period_availability OWNER TO supabase_admin;

--
-- Name: vw_staff_with_preferences; Type: VIEW; Schema: public; Owner: supabase_admin
--

CREATE VIEW public.vw_staff_with_preferences WITH (security_invoker='true') AS
 WITH staff_base AS (
         SELECT s.profile_id,
            s.skills,
            s.roles,
            s.school_id,
            s.status,
            s.login_active,
            s.last_invited_at,
            s.joined_at,
            s.employee_id,
            s.kurzung,
            s.hours_account,
            s.credit_hours,
            s.age_reduction,
            s.subjects_stud,
            s.credit_hours_note,
            s.colour,
            u.id AS user_id,
            u.first_name,
            u.last_name,
            concat(u.first_name, ' ', u.last_name) AS name
           FROM (public.profile_info_staff s
             JOIN public.user_profiles u ON ((u.id = s.profile_id)))
        ), studied_subjects_agg AS (
         SELECT sb_1.profile_id,
            json_agg(DISTINCT jsonb_build_object('id', subj.id, 'name', subj.name, 'color', subj.color, 'icon_id', subj.icon_id)) AS studied_subjects
           FROM staff_base sb_1,
            (LATERAL unnest(sb_1.subjects_stud) subject_id(subject_id)
             JOIN public.subjects subj ON ((subj.id = subject_id.subject_id)))
          GROUP BY sb_1.profile_id
        ), preference_subjects AS (
         SELECT p.id AS preference_id,
            json_agg(jsonb_build_object('id', sp.id, 'name', sp.name, 'color', sp.color, 'icon_id', sp.icon_id)) AS subject_pref_data
           FROM public.staff_yearly_preferences p,
            (LATERAL unnest(p.subject_pref) sp_id(sp_id)
             JOIN public.subjects sp ON ((sp.id = sp_id.sp_id)))
          GROUP BY p.id
        ), preference_classes AS (
         SELECT p.id AS preference_id,
            json_agg(jsonb_build_object('id', c.id, 'name', c.name, 'grade_level', c.grade_level)) AS class_info_data
           FROM public.staff_yearly_preferences p,
            (LATERAL unnest(p.classes) class_id(class_id)
             JOIN public.structure_classes c ON ((c.id = class_id.class_id)))
          GROUP BY p.id
        ), preferences_complete AS (
         SELECT p.staff_profile_id,
            json_agg(jsonb_build_object('id', p.id, 'semester_id', p.semester_id, 'subject_pref', COALESCE(ps.subject_pref_data, '[]'::json), 'classes', p.classes, 'class_info', COALESCE(pc_1.class_info_data, '[]'::json), 'clubs', p.clubs, 'team', p.team, 'efob_team', p.efob_team, 'wishes', p.wishes, 'needs', p.needs, 'created_at', p.created_at, 'updated_at', p.updated_at) ORDER BY p.semester_id) AS preferences
           FROM ((public.staff_yearly_preferences p
             LEFT JOIN preference_subjects ps ON ((ps.preference_id = p.id)))
             LEFT JOIN preference_classes pc_1 ON ((pc_1.preference_id = p.id)))
          GROUP BY p.staff_profile_id
        )
 SELECT sb.user_id,
    sb.first_name,
    sb.last_name,
    sb.name,
    sb.profile_id,
    sb.kurzung,
    sb.subjects_stud,
    COALESCE(ssa.studied_subjects, '[]'::json) AS studied_subjects,
    sb.hours_account,
    sb.credit_hours,
    sb.age_reduction,
    sb.school_id,
    sb.status,
    sb.roles,
    sb.skills,
    sb.joined_at,
    sb.colour,
    COALESCE(pc.preferences, '[]'::json) AS preferences
   FROM ((staff_base sb
     LEFT JOIN studied_subjects_agg ssa ON ((ssa.profile_id = sb.profile_id)))
     LEFT JOIN preferences_complete pc ON ((pc.staff_profile_id = sb.profile_id)));


ALTER VIEW public.vw_staff_with_preferences OWNER TO supabase_admin;

--
-- Name: vw_structure_school_years_with_periods; Type: VIEW; Schema: public; Owner: supabase_admin
--

CREATE VIEW public.vw_structure_school_years_with_periods WITH (security_invoker='true', security_barrier='true') AS
 SELECT y.id AS school_year_id,
    y.school_id,
    y.label AS year_label,
    y.start_date AS year_start,
    y.end_date AS year_end,
    COALESCE(json_agg(jsonb_build_object('id', s.id, 'name', s.name, 'start_date', s.start_date, 'end_date', s.end_date, 'is_active', s.is_active, 'created_at', s.created_at) ORDER BY s.start_date) FILTER (WHERE (s.id IS NOT NULL)), '[]'::json) AS semesters
   FROM (public.structure_school_years y
     LEFT JOIN public.structure_school_semesters s ON ((y.id = s.school_year_id)))
  GROUP BY y.id, y.school_id, y.label, y.start_date, y.end_date;


ALTER VIEW public.vw_structure_school_years_with_periods OWNER TO supabase_admin;

--
-- Name: vw_student_attendance_today; Type: VIEW; Schema: public; Owner: supabase_admin
--

CREATE VIEW public.vw_student_attendance_today WITH (security_invoker='true') AS
 WITH students_with_attendance AS (
         SELECT s.id AS student_id,
            i.class_id
           FROM (public.user_profiles s
             JOIN public.profile_info_student i ON ((s.id = i.profile_id)))
          WHERE ((EXISTS ( SELECT 1
                   FROM public.student_daily_log d_1
                  WHERE ((d_1.student_id = s.id) AND (d_1.date = CURRENT_DATE)))) OR (EXISTS ( SELECT 1
                   FROM public.student_attendance_logs a_1
                  WHERE ((a_1.student_id = s.id) AND (a_1."timestamp" >= CURRENT_DATE) AND (a_1."timestamp" < (CURRENT_DATE + '1 day'::interval))))))
        )
 SELECT swa.student_id,
    swa.class_id,
    d.presence_status,
    a.status AS lesson_status,
    a.lesson_id
   FROM ((students_with_attendance swa
     LEFT JOIN public.student_daily_log d ON (((swa.student_id = d.student_id) AND (d.date = CURRENT_DATE))))
     LEFT JOIN public.student_attendance_logs a ON (((swa.student_id = a.student_id) AND (a."timestamp" >= CURRENT_DATE) AND (a."timestamp" < (CURRENT_DATE + '1 day'::interval)))));


ALTER VIEW public.vw_student_attendance_today OWNER TO supabase_admin;

--
-- Name: vw_student_profiles; Type: VIEW; Schema: public; Owner: supabase_admin
--

CREATE VIEW public.vw_student_profiles WITH (security_invoker='true') AS
 SELECT p.id AS profile_id,
    p.first_name,
    s.middle_name,
    p.last_name,
    s.nickname,
    p.gender,
    p.date_of_birth,
    p.profile_picture_url,
    s.class_id,
    c.name AS class_name,
    c.grade_level,
    c.teacher_id,
    s.notes,
    s.allergies,
    s.school_id,
    fm.family_id,
    f.family_code,
    f.family_name,
    COALESCE(parents_data.parents, '[]'::json) AS parents,
    COALESCE(siblings_data.siblings, '[]'::json) AS siblings
   FROM ((((((public.user_profiles p
     JOIN public.profile_info_student s ON ((s.profile_id = p.id)))
     LEFT JOIN public.structure_classes c ON ((s.class_id = c.id)))
     LEFT JOIN public.family_members fm ON (((fm.profile_id = p.id) AND (fm.role = 'student'::text) AND (fm.removed_at IS NULL))))
     LEFT JOIN public.families f ON ((f.id = fm.family_id)))
     LEFT JOIN LATERAL ( SELECT json_agg(json_build_object('profile_id', fm2.profile_id, 'role', fm2.role, 'relation_description', fm2.relation_description, 'is_primary_guardian', fm2.is_primary_guardian, 'first_name', up.first_name, 'last_name', up.last_name, 'profile_picture_url', up.profile_picture_url, 'authorized_for_pickup', fmcl.authorized_for_pickup, 'account_status', up.account_status) ORDER BY up.first_name) AS parents
           FROM ((public.family_members fm2
             JOIN public.user_profiles up ON ((up.id = fm2.profile_id)))
             LEFT JOIN public.family_member_child_links fmcl ON (((fmcl.family_id = fm2.family_id) AND (fmcl.adult_profile_id = fm2.profile_id) AND (fmcl.child_profile_id = p.id))))
          WHERE ((fm2.family_id = fm.family_id) AND (fm2.role = 'parent'::text) AND (fm2.removed_at IS NULL))) parents_data ON ((fm.family_id IS NOT NULL)))
     LEFT JOIN LATERAL ( SELECT json_agg(json_build_object('profile_id', fm2.profile_id, 'role', fm2.role, 'relation_description', fm2.relation_description, 'first_name', up.first_name, 'last_name', up.last_name, 'profile_picture_url', up.profile_picture_url, 'class_name', c2.name, 'grade_level', c2.grade_level, 'authorized_for_pickup', (fm2.profile_id = ANY (s.authorized_pickup_ids))) ORDER BY up.first_name) AS siblings
           FROM (((public.family_members fm2
             JOIN public.user_profiles up ON ((up.id = fm2.profile_id)))
             JOIN public.profile_info_student s2 ON ((s2.profile_id = fm2.profile_id)))
             LEFT JOIN public.structure_classes c2 ON ((c2.id = s2.class_id)))
          WHERE ((fm2.family_id = fm.family_id) AND (fm2.role = 'student'::text) AND (fm2.profile_id <> p.id) AND (fm2.removed_at IS NULL))) siblings_data ON ((fm.family_id IS NOT NULL)));


ALTER VIEW public.vw_student_profiles OWNER TO supabase_admin;

--
-- Name: vw_subject_grade_hours; Type: VIEW; Schema: public; Owner: supabase_admin
--

CREATE VIEW public.vw_subject_grade_hours WITH (security_invoker='true') AS
 SELECT s.id AS subject_id,
    s.name AS subject_name,
    s.icon,
    s.color,
    s.subject_type,
    s.school_id,
    g.grade_level,
    g.hours_per_week
   FROM (public.subjects s
     LEFT JOIN public.subject_grade_hours g ON ((g.subject_id = s.id)));


ALTER VIEW public.vw_subject_grade_hours OWNER TO supabase_admin;

--
-- Name: vw_subjects_with_grade_and_class_hours; Type: VIEW; Schema: public; Owner: supabase_admin
--

CREATE VIEW public.vw_subjects_with_grade_and_class_hours AS
SELECT
    NULL::uuid AS subject_id,
    NULL::text AS subject_name,
    NULL::text AS abbreviation,
    NULL::text AS icon,
    NULL::text AS color,
    NULL::public.subject_type_enum AS subject_type,
    NULL::uuid AS school_id,
    NULL::json AS grade_hours;


ALTER VIEW public.vw_subjects_with_grade_and_class_hours OWNER TO supabase_admin;

--
-- Name: vw_user_roles; Type: VIEW; Schema: public; Owner: supabase_admin
--

CREATE VIEW public.vw_user_roles AS
 SELECT ur.user_profile_id,
    array_agg(r.name ORDER BY r.name) AS roles
   FROM (public.user_roles ur
     JOIN public.roles r ON ((ur.role_id = r.id)))
  GROUP BY ur.user_profile_id;


ALTER VIEW public.vw_user_roles OWNER TO supabase_admin;

--
-- Name: vwm_class_user_creation_stats; Type: MATERIALIZED VIEW; Schema: public; Owner: supabase_admin
--

CREATE MATERIALIZED VIEW public.vwm_class_user_creation_stats AS
 WITH student_data AS (
         SELECT s.profile_id AS student_profile_id,
            s.class_id,
            c.name AS class_name,
            up.account_status AS student_account_status
           FROM ((public.profile_info_student s
             JOIN public.structure_classes c ON ((s.class_id = c.id)))
             JOIN public.user_profiles up ON ((up.id = s.profile_id)))
        ), family_links AS (
         SELECT DISTINCT fcl.child_profile_id,
            fcl.adult_profile_id
           FROM public.family_member_child_links fcl
        ), parent_accounts AS (
         SELECT fcl.child_profile_id,
            up.id AS parent_profile_id,
            up.account_status
           FROM (family_links fcl
             JOIN public.user_profiles up ON ((up.id = fcl.adult_profile_id)))
        ), one_parent_per_student AS (
         SELECT parent_accounts.child_profile_id,
            (min((parent_accounts.parent_profile_id)::text))::uuid AS one_parent_id
           FROM parent_accounts
          WHERE (parent_accounts.account_status <> 'none'::public.account_status_enum)
          GROUP BY parent_accounts.child_profile_id
        ), final AS (
         SELECT sd.class_name,
            count(sd.student_profile_id) AS total_students,
            count(sd.student_profile_id) FILTER (WHERE (sd.student_account_status <> 'none'::public.account_status_enum)) AS students_with_accounts,
            count(sd.student_profile_id) FILTER (WHERE (opps.one_parent_id IS NOT NULL)) AS students_with_at_least_one_parent_account
           FROM (student_data sd
             LEFT JOIN one_parent_per_student opps ON ((opps.child_profile_id = sd.student_profile_id)))
          GROUP BY sd.class_name
        ), with_totals AS (
         SELECT final.class_name,
            final.total_students,
            final.students_with_accounts,
            final.students_with_at_least_one_parent_account
           FROM final
        UNION ALL
         SELECT 'Alle'::text AS class_name,
            sum(final.total_students) AS sum,
            sum(final.students_with_accounts) AS sum,
            sum(final.students_with_at_least_one_parent_account) AS sum
           FROM final
        )
 SELECT with_totals.class_name,
    with_totals.total_students,
    with_totals.students_with_accounts,
    with_totals.students_with_at_least_one_parent_account,
    round(((100.0 * with_totals.students_with_accounts) / NULLIF(with_totals.total_students, (0)::numeric)), 1) AS student_account_percent,
    round(((100.0 * with_totals.students_with_at_least_one_parent_account) / NULLIF(with_totals.total_students, (0)::numeric)), 1) AS parent_account_percent
   FROM with_totals
  ORDER BY
        CASE
            WHEN (with_totals.class_name = 'Alle'::text) THEN 'Z'::text
            ELSE with_totals.class_name
        END
  WITH NO DATA;


ALTER MATERIALIZED VIEW public.vwm_class_user_creation_stats OWNER TO supabase_admin;

--
-- Name: vwm_school_semesters_with_year_label; Type: MATERIALIZED VIEW; Schema: public; Owner: supabase_admin
--

CREATE MATERIALIZED VIEW public.vwm_school_semesters_with_year_label AS
 SELECT s.id AS semester_id,
    s.school_id,
    s.school_year_id,
    sy.label AS school_year_label,
    s.name AS semester_name,
    s.start_date AS semester_start,
    s.end_date AS semester_end,
    s.is_active,
    s.created_at
   FROM (public.structure_school_semesters s
     JOIN public.structure_school_years sy ON ((s.school_year_id = sy.id)))
  WITH NO DATA;


ALTER MATERIALIZED VIEW public.vwm_school_semesters_with_year_label OWNER TO supabase_admin;

--
-- Name: messages; Type: TABLE; Schema: realtime; Owner: supabase_realtime_admin
--

CREATE TABLE realtime.messages (
    topic text NOT NULL,
    extension text NOT NULL,
    payload jsonb,
    event text,
    private boolean DEFAULT false,
    updated_at timestamp without time zone DEFAULT now() NOT NULL,
    inserted_at timestamp without time zone DEFAULT now() NOT NULL,
    id uuid DEFAULT gen_random_uuid() NOT NULL
)
PARTITION BY RANGE (inserted_at);


ALTER TABLE realtime.messages OWNER TO supabase_realtime_admin;

--
-- Name: messages_2025_08_25; Type: TABLE; Schema: realtime; Owner: supabase_admin
--

CREATE TABLE realtime.messages_2025_08_25 (
    topic text NOT NULL,
    extension text NOT NULL,
    payload jsonb,
    event text,
    private boolean DEFAULT false,
    updated_at timestamp without time zone DEFAULT now() NOT NULL,
    inserted_at timestamp without time zone DEFAULT now() NOT NULL,
    id uuid DEFAULT gen_random_uuid() NOT NULL
);


ALTER TABLE realtime.messages_2025_08_25 OWNER TO supabase_admin;

--
-- Name: messages_2025_08_26; Type: TABLE; Schema: realtime; Owner: supabase_admin
--

CREATE TABLE realtime.messages_2025_08_26 (
    topic text NOT NULL,
    extension text NOT NULL,
    payload jsonb,
    event text,
    private boolean DEFAULT false,
    updated_at timestamp without time zone DEFAULT now() NOT NULL,
    inserted_at timestamp without time zone DEFAULT now() NOT NULL,
    id uuid DEFAULT gen_random_uuid() NOT NULL
);


ALTER TABLE realtime.messages_2025_08_26 OWNER TO supabase_admin;

--
-- Name: messages_2025_08_27; Type: TABLE; Schema: realtime; Owner: supabase_admin
--

CREATE TABLE realtime.messages_2025_08_27 (
    topic text NOT NULL,
    extension text NOT NULL,
    payload jsonb,
    event text,
    private boolean DEFAULT false,
    updated_at timestamp without time zone DEFAULT now() NOT NULL,
    inserted_at timestamp without time zone DEFAULT now() NOT NULL,
    id uuid DEFAULT gen_random_uuid() NOT NULL
);


ALTER TABLE realtime.messages_2025_08_27 OWNER TO supabase_admin;

--
-- Name: messages_2025_08_28; Type: TABLE; Schema: realtime; Owner: supabase_admin
--

CREATE TABLE realtime.messages_2025_08_28 (
    topic text NOT NULL,
    extension text NOT NULL,
    payload jsonb,
    event text,
    private boolean DEFAULT false,
    updated_at timestamp without time zone DEFAULT now() NOT NULL,
    inserted_at timestamp without time zone DEFAULT now() NOT NULL,
    id uuid DEFAULT gen_random_uuid() NOT NULL
);


ALTER TABLE realtime.messages_2025_08_28 OWNER TO supabase_admin;

--
-- Name: messages_2025_08_29; Type: TABLE; Schema: realtime; Owner: supabase_admin
--

CREATE TABLE realtime.messages_2025_08_29 (
    topic text NOT NULL,
    extension text NOT NULL,
    payload jsonb,
    event text,
    private boolean DEFAULT false,
    updated_at timestamp without time zone DEFAULT now() NOT NULL,
    inserted_at timestamp without time zone DEFAULT now() NOT NULL,
    id uuid DEFAULT gen_random_uuid() NOT NULL
);


ALTER TABLE realtime.messages_2025_08_29 OWNER TO supabase_admin;

--
-- Name: messages_2025_08_30; Type: TABLE; Schema: realtime; Owner: supabase_admin
--

CREATE TABLE realtime.messages_2025_08_30 (
    topic text NOT NULL,
    extension text NOT NULL,
    payload jsonb,
    event text,
    private boolean DEFAULT false,
    updated_at timestamp without time zone DEFAULT now() NOT NULL,
    inserted_at timestamp without time zone DEFAULT now() NOT NULL,
    id uuid DEFAULT gen_random_uuid() NOT NULL
);


ALTER TABLE realtime.messages_2025_08_30 OWNER TO supabase_admin;

--
-- Name: messages_2025_08_31; Type: TABLE; Schema: realtime; Owner: supabase_admin
--

CREATE TABLE realtime.messages_2025_08_31 (
    topic text NOT NULL,
    extension text NOT NULL,
    payload jsonb,
    event text,
    private boolean DEFAULT false,
    updated_at timestamp without time zone DEFAULT now() NOT NULL,
    inserted_at timestamp without time zone DEFAULT now() NOT NULL,
    id uuid DEFAULT gen_random_uuid() NOT NULL
);


ALTER TABLE realtime.messages_2025_08_31 OWNER TO supabase_admin;

--
-- Name: schema_migrations; Type: TABLE; Schema: realtime; Owner: supabase_admin
--

CREATE TABLE realtime.schema_migrations (
    version bigint NOT NULL,
    inserted_at timestamp(0) without time zone
);


ALTER TABLE realtime.schema_migrations OWNER TO supabase_admin;

--
-- Name: subscription; Type: TABLE; Schema: realtime; Owner: supabase_admin
--

CREATE TABLE realtime.subscription (
    id bigint NOT NULL,
    subscription_id uuid NOT NULL,
    entity regclass NOT NULL,
    filters realtime.user_defined_filter[] DEFAULT '{}'::realtime.user_defined_filter[] NOT NULL,
    claims jsonb NOT NULL,
    claims_role regrole GENERATED ALWAYS AS (realtime.to_regrole((claims ->> 'role'::text))) STORED NOT NULL,
    created_at timestamp without time zone DEFAULT timezone('utc'::text, now()) NOT NULL
);


ALTER TABLE realtime.subscription OWNER TO supabase_admin;

--
-- Name: subscription_id_seq; Type: SEQUENCE; Schema: realtime; Owner: supabase_admin
--

ALTER TABLE realtime.subscription ALTER COLUMN id ADD GENERATED ALWAYS AS IDENTITY (
    SEQUENCE NAME realtime.subscription_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: buckets; Type: TABLE; Schema: storage; Owner: supabase_storage_admin
--

CREATE TABLE storage.buckets (
    id text NOT NULL,
    name text NOT NULL,
    owner uuid,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    public boolean DEFAULT false,
    avif_autodetection boolean DEFAULT false,
    file_size_limit bigint,
    allowed_mime_types text[],
    owner_id text
);


ALTER TABLE storage.buckets OWNER TO supabase_storage_admin;

--
-- Name: COLUMN buckets.owner; Type: COMMENT; Schema: storage; Owner: supabase_storage_admin
--

COMMENT ON COLUMN storage.buckets.owner IS 'Field is deprecated, use owner_id instead';


--
-- Name: migrations; Type: TABLE; Schema: storage; Owner: supabase_storage_admin
--

CREATE TABLE storage.migrations (
    id integer NOT NULL,
    name character varying(100) NOT NULL,
    hash character varying(40) NOT NULL,
    executed_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);


ALTER TABLE storage.migrations OWNER TO supabase_storage_admin;

--
-- Name: objects; Type: TABLE; Schema: storage; Owner: supabase_storage_admin
--

CREATE TABLE storage.objects (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    bucket_id text,
    name text,
    owner uuid,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    last_accessed_at timestamp with time zone DEFAULT now(),
    metadata jsonb,
    path_tokens text[] GENERATED ALWAYS AS (string_to_array(name, '/'::text)) STORED,
    version text,
    owner_id text,
    user_metadata jsonb,
    level integer
);


ALTER TABLE storage.objects OWNER TO supabase_storage_admin;

--
-- Name: COLUMN objects.owner; Type: COMMENT; Schema: storage; Owner: supabase_storage_admin
--

COMMENT ON COLUMN storage.objects.owner IS 'Field is deprecated, use owner_id instead';


--
-- Name: prefixes; Type: TABLE; Schema: storage; Owner: supabase_storage_admin
--

CREATE TABLE storage.prefixes (
    bucket_id text NOT NULL,
    name text NOT NULL COLLATE pg_catalog."C",
    level integer GENERATED ALWAYS AS (storage.get_level(name)) STORED NOT NULL,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);


ALTER TABLE storage.prefixes OWNER TO supabase_storage_admin;

--
-- Name: s3_multipart_uploads; Type: TABLE; Schema: storage; Owner: supabase_storage_admin
--

CREATE TABLE storage.s3_multipart_uploads (
    id text NOT NULL,
    in_progress_size bigint DEFAULT 0 NOT NULL,
    upload_signature text NOT NULL,
    bucket_id text NOT NULL,
    key text NOT NULL COLLATE pg_catalog."C",
    version text NOT NULL,
    owner_id text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    user_metadata jsonb
);


ALTER TABLE storage.s3_multipart_uploads OWNER TO supabase_storage_admin;

--
-- Name: s3_multipart_uploads_parts; Type: TABLE; Schema: storage; Owner: supabase_storage_admin
--

CREATE TABLE storage.s3_multipart_uploads_parts (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    upload_id text NOT NULL,
    size bigint DEFAULT 0 NOT NULL,
    part_number integer NOT NULL,
    bucket_id text NOT NULL,
    key text NOT NULL COLLATE pg_catalog."C",
    etag text NOT NULL,
    owner_id text,
    version text NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL
);


ALTER TABLE storage.s3_multipart_uploads_parts OWNER TO supabase_storage_admin;

--
-- Name: tenants; Type: TABLE; Schema: storage; Owner: postgres
--

CREATE TABLE storage.tenants (
    id text NOT NULL,
    name text NOT NULL,
    slug text NOT NULL
);


ALTER TABLE storage.tenants OWNER TO postgres;

--
-- Name: hooks; Type: TABLE; Schema: supabase_functions; Owner: supabase_functions_admin
--

CREATE TABLE supabase_functions.hooks (
    id bigint NOT NULL,
    hook_table_id integer NOT NULL,
    hook_name text NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    request_id bigint
);


ALTER TABLE supabase_functions.hooks OWNER TO supabase_functions_admin;

--
-- Name: TABLE hooks; Type: COMMENT; Schema: supabase_functions; Owner: supabase_functions_admin
--

COMMENT ON TABLE supabase_functions.hooks IS 'Supabase Functions Hooks: Audit trail for triggered hooks.';


--
-- Name: hooks_id_seq; Type: SEQUENCE; Schema: supabase_functions; Owner: supabase_functions_admin
--

CREATE SEQUENCE supabase_functions.hooks_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE supabase_functions.hooks_id_seq OWNER TO supabase_functions_admin;

--
-- Name: hooks_id_seq; Type: SEQUENCE OWNED BY; Schema: supabase_functions; Owner: supabase_functions_admin
--

ALTER SEQUENCE supabase_functions.hooks_id_seq OWNED BY supabase_functions.hooks.id;


--
-- Name: migrations; Type: TABLE; Schema: supabase_functions; Owner: supabase_functions_admin
--

CREATE TABLE supabase_functions.migrations (
    version text NOT NULL,
    inserted_at timestamp with time zone DEFAULT now() NOT NULL
);


ALTER TABLE supabase_functions.migrations OWNER TO supabase_functions_admin;

--
-- Name: messages_2025_08_25; Type: TABLE ATTACH; Schema: realtime; Owner: supabase_admin
--

ALTER TABLE ONLY realtime.messages ATTACH PARTITION realtime.messages_2025_08_25 FOR VALUES FROM ('2025-08-25 00:00:00') TO ('2025-08-26 00:00:00');


--
-- Name: messages_2025_08_26; Type: TABLE ATTACH; Schema: realtime; Owner: supabase_admin
--

ALTER TABLE ONLY realtime.messages ATTACH PARTITION realtime.messages_2025_08_26 FOR VALUES FROM ('2025-08-26 00:00:00') TO ('2025-08-27 00:00:00');


--
-- Name: messages_2025_08_27; Type: TABLE ATTACH; Schema: realtime; Owner: supabase_admin
--

ALTER TABLE ONLY realtime.messages ATTACH PARTITION realtime.messages_2025_08_27 FOR VALUES FROM ('2025-08-27 00:00:00') TO ('2025-08-28 00:00:00');


--
-- Name: messages_2025_08_28; Type: TABLE ATTACH; Schema: realtime; Owner: supabase_admin
--

ALTER TABLE ONLY realtime.messages ATTACH PARTITION realtime.messages_2025_08_28 FOR VALUES FROM ('2025-08-28 00:00:00') TO ('2025-08-29 00:00:00');


--
-- Name: messages_2025_08_29; Type: TABLE ATTACH; Schema: realtime; Owner: supabase_admin
--

ALTER TABLE ONLY realtime.messages ATTACH PARTITION realtime.messages_2025_08_29 FOR VALUES FROM ('2025-08-29 00:00:00') TO ('2025-08-30 00:00:00');


--
-- Name: messages_2025_08_30; Type: TABLE ATTACH; Schema: realtime; Owner: supabase_admin
--

ALTER TABLE ONLY realtime.messages ATTACH PARTITION realtime.messages_2025_08_30 FOR VALUES FROM ('2025-08-30 00:00:00') TO ('2025-08-31 00:00:00');


--
-- Name: messages_2025_08_31; Type: TABLE ATTACH; Schema: realtime; Owner: supabase_admin
--

ALTER TABLE ONLY realtime.messages ATTACH PARTITION realtime.messages_2025_08_31 FOR VALUES FROM ('2025-08-31 00:00:00') TO ('2025-09-01 00:00:00');


--
-- Name: refresh_tokens id; Type: DEFAULT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.refresh_tokens ALTER COLUMN id SET DEFAULT nextval('auth.refresh_tokens_id_seq'::regclass);


--
-- Name: debug_logs id; Type: DEFAULT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.debug_logs ALTER COLUMN id SET DEFAULT nextval('public.debug_logs_id_seq'::regclass);


--
-- Name: ingest_interview_debug_log id; Type: DEFAULT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.ingest_interview_debug_log ALTER COLUMN id SET DEFAULT nextval('public.ingest_interview_debug_log_id_seq'::regclass);


--
-- Name: recurrence_debug_log id; Type: DEFAULT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.recurrence_debug_log ALTER COLUMN id SET DEFAULT nextval('public.recurrence_debug_log_id_seq'::regclass);


--
-- Name: schema_change_log id; Type: DEFAULT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.schema_change_log ALTER COLUMN id SET DEFAULT nextval('public.schema_change_log_id_seq'::regclass);


--
-- Name: structure_days id; Type: DEFAULT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.structure_days ALTER COLUMN id SET DEFAULT nextval('public.structure_days_id_seq'::regclass);


--
-- Name: hooks id; Type: DEFAULT; Schema: supabase_functions; Owner: supabase_functions_admin
--

ALTER TABLE ONLY supabase_functions.hooks ALTER COLUMN id SET DEFAULT nextval('supabase_functions.hooks_id_seq'::regclass);


--
-- Name: user_profiles profiles_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.user_profiles
    ADD CONSTRAINT profiles_pkey PRIMARY KEY (id);


--
-- Name: vwm_user_login_profiles; Type: MATERIALIZED VIEW; Schema: public; Owner: supabase_admin
--

CREATE MATERIALIZED VIEW public.vwm_user_login_profiles AS
 SELECT up.id,
    up.first_name,
    up.last_name,
    COALESCE(( SELECT r.name
           FROM (public.user_roles ur_1
             JOIN public.roles r ON ((ur_1.role_id = r.id)))
          WHERE ((ur_1.user_profile_id = up.id) AND (r.is_subrole = false))
         LIMIT 1), ( SELECT r.name
           FROM public.roles r
          WHERE (r.id = up.role_id))) AS role_name,
    COALESCE(array_agg(sr.name ORDER BY sr.name) FILTER (WHERE ((sr.name IS NOT NULL) AND (sr.is_subrole = true))), '{}'::text[]) AS subrole_names
   FROM ((public.user_profiles up
     LEFT JOIN public.user_roles ur ON ((up.id = ur.user_profile_id)))
     LEFT JOIN public.roles sr ON ((ur.role_id = sr.id)))
  GROUP BY up.id, up.first_name, up.last_name
  WITH NO DATA;


ALTER MATERIALIZED VIEW public.vwm_user_login_profiles OWNER TO supabase_admin;

--
-- Name: extensions extensions_pkey; Type: CONSTRAINT; Schema: _realtime; Owner: supabase_admin
--

ALTER TABLE ONLY _realtime.extensions
    ADD CONSTRAINT extensions_pkey PRIMARY KEY (id);


--
-- Name: schema_migrations schema_migrations_pkey; Type: CONSTRAINT; Schema: _realtime; Owner: supabase_admin
--

ALTER TABLE ONLY _realtime.schema_migrations
    ADD CONSTRAINT schema_migrations_pkey PRIMARY KEY (version);


--
-- Name: tenants tenants_pkey; Type: CONSTRAINT; Schema: _realtime; Owner: supabase_admin
--

ALTER TABLE ONLY _realtime.tenants
    ADD CONSTRAINT tenants_pkey PRIMARY KEY (id);


--
-- Name: mfa_amr_claims amr_id_pk; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.mfa_amr_claims
    ADD CONSTRAINT amr_id_pk PRIMARY KEY (id);


--
-- Name: audit_log_entries audit_log_entries_pkey; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.audit_log_entries
    ADD CONSTRAINT audit_log_entries_pkey PRIMARY KEY (id);


--
-- Name: flow_state flow_state_pkey; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.flow_state
    ADD CONSTRAINT flow_state_pkey PRIMARY KEY (id);


--
-- Name: identities identities_pkey; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.identities
    ADD CONSTRAINT identities_pkey PRIMARY KEY (id);


--
-- Name: identities identities_provider_id_provider_unique; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.identities
    ADD CONSTRAINT identities_provider_id_provider_unique UNIQUE (provider_id, provider);


--
-- Name: instances instances_pkey; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.instances
    ADD CONSTRAINT instances_pkey PRIMARY KEY (id);


--
-- Name: mfa_amr_claims mfa_amr_claims_session_id_authentication_method_pkey; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.mfa_amr_claims
    ADD CONSTRAINT mfa_amr_claims_session_id_authentication_method_pkey UNIQUE (session_id, authentication_method);


--
-- Name: mfa_challenges mfa_challenges_pkey; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.mfa_challenges
    ADD CONSTRAINT mfa_challenges_pkey PRIMARY KEY (id);


--
-- Name: mfa_factors mfa_factors_last_challenged_at_key; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.mfa_factors
    ADD CONSTRAINT mfa_factors_last_challenged_at_key UNIQUE (last_challenged_at);


--
-- Name: mfa_factors mfa_factors_pkey; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.mfa_factors
    ADD CONSTRAINT mfa_factors_pkey PRIMARY KEY (id);


--
-- Name: one_time_tokens one_time_tokens_pkey; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.one_time_tokens
    ADD CONSTRAINT one_time_tokens_pkey PRIMARY KEY (id);


--
-- Name: refresh_tokens refresh_tokens_pkey; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.refresh_tokens
    ADD CONSTRAINT refresh_tokens_pkey PRIMARY KEY (id);


--
-- Name: refresh_tokens refresh_tokens_token_unique; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.refresh_tokens
    ADD CONSTRAINT refresh_tokens_token_unique UNIQUE (token);


--
-- Name: saml_providers saml_providers_entity_id_key; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.saml_providers
    ADD CONSTRAINT saml_providers_entity_id_key UNIQUE (entity_id);


--
-- Name: saml_providers saml_providers_pkey; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.saml_providers
    ADD CONSTRAINT saml_providers_pkey PRIMARY KEY (id);


--
-- Name: saml_relay_states saml_relay_states_pkey; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.saml_relay_states
    ADD CONSTRAINT saml_relay_states_pkey PRIMARY KEY (id);


--
-- Name: schema_migrations schema_migrations_pkey; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.schema_migrations
    ADD CONSTRAINT schema_migrations_pkey PRIMARY KEY (version);


--
-- Name: sessions sessions_pkey; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.sessions
    ADD CONSTRAINT sessions_pkey PRIMARY KEY (id);


--
-- Name: sso_domains sso_domains_pkey; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.sso_domains
    ADD CONSTRAINT sso_domains_pkey PRIMARY KEY (id);


--
-- Name: sso_providers sso_providers_pkey; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.sso_providers
    ADD CONSTRAINT sso_providers_pkey PRIMARY KEY (id);


--
-- Name: users users_phone_key; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.users
    ADD CONSTRAINT users_phone_key UNIQUE (phone);


--
-- Name: users users_pkey; Type: CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.users
    ADD CONSTRAINT users_pkey PRIMARY KEY (id);


--
-- Name: course_applications applications_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.course_applications
    ADD CONSTRAINT applications_pkey PRIMARY KEY (id);


--
-- Name: course_enrollments assignments_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.course_enrollments
    ADD CONSTRAINT assignments_pkey PRIMARY KEY (id);


--
-- Name: bulletin_post_users bulletin_post_users_pkey; Type: CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.bulletin_post_users
    ADD CONSTRAINT bulletin_post_users_pkey PRIMARY KEY (post_id, user_id);


--
-- Name: bulletin_posts bulletin_posts_pkey; Type: CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.bulletin_posts
    ADD CONSTRAINT bulletin_posts_pkey PRIMARY KEY (id);


--
-- Name: bulletin_recurrences bulletin_recurrences_pkey; Type: CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.bulletin_recurrences
    ADD CONSTRAINT bulletin_recurrences_pkey PRIMARY KEY (id);


--
-- Name: course_allocation_drafts cad_unique_student; Type: CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.course_allocation_drafts
    ADD CONSTRAINT cad_unique_student UNIQUE (registration_period_id, semester_id, school_id, day_of_week, student_id);


--
-- Name: schedule_calendar_exceptions calendar_exceptions_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.schedule_calendar_exceptions
    ADD CONSTRAINT calendar_exceptions_pkey PRIMARY KEY (id);


--
-- Name: change_log change_log_pkey; Type: CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.change_log
    ADD CONSTRAINT change_log_pkey PRIMARY KEY (id);


--
-- Name: structure_classes classes_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.structure_classes
    ADD CONSTRAINT classes_pkey PRIMARY KEY (id);


--
-- Name: contacts contacts_pkey; Type: CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.contacts
    ADD CONSTRAINT contacts_pkey PRIMARY KEY (id);


--
-- Name: course_allocation_drafts course_allocation_drafts_pkey; Type: CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.course_allocation_drafts
    ADD CONSTRAINT course_allocation_drafts_pkey PRIMARY KEY (id);


--
-- Name: course_notes course_notes_pkey; Type: CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.course_notes
    ADD CONSTRAINT course_notes_pkey PRIMARY KEY (id);


--
-- Name: course_offers course_offers_pkey; Type: CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.course_offers
    ADD CONSTRAINT course_offers_pkey PRIMARY KEY (id);


--
-- Name: course_possible_times course_possible_times_pkey; Type: CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.course_possible_times
    ADD CONSTRAINT course_possible_times_pkey PRIMARY KEY (id);


--
-- Name: course_registration_windows course_registration_windows_pkey; Type: CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.course_registration_windows
    ADD CONSTRAINT course_registration_windows_pkey PRIMARY KEY (id);


--
-- Name: course_schedules course_schedules_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.course_schedules
    ADD CONSTRAINT course_schedules_pkey PRIMARY KEY (id);


--
-- Name: course_lessons course_sessions_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.course_lessons
    ADD CONSTRAINT course_sessions_pkey PRIMARY KEY (id);


--
-- Name: course_list courses_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.course_list
    ADD CONSTRAINT courses_pkey PRIMARY KEY (id);


--
-- Name: schedule_daily_rostering daily_assignments_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.schedule_daily_rostering
    ADD CONSTRAINT daily_assignments_pkey PRIMARY KEY (id);


--
-- Name: debug_logs debug_logs_pkey; Type: CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.debug_logs
    ADD CONSTRAINT debug_logs_pkey PRIMARY KEY (id);


--
-- Name: document_types document_types_name_key; Type: CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.document_types
    ADD CONSTRAINT document_types_name_key UNIQUE (name);


--
-- Name: document_types document_types_pkey; Type: CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.document_types
    ADD CONSTRAINT document_types_pkey PRIMARY KEY (id);


--
-- Name: families families_family_code_key; Type: CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.families
    ADD CONSTRAINT families_family_code_key UNIQUE (family_code);


--
-- Name: families families_pkey; Type: CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.families
    ADD CONSTRAINT families_pkey PRIMARY KEY (id);


--
-- Name: family_member_child_links family_member_child_links_pkey; Type: CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.family_member_child_links
    ADD CONSTRAINT family_member_child_links_pkey PRIMARY KEY (id);


--
-- Name: family_members family_members_pkey; Type: CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.family_members
    ADD CONSTRAINT family_members_pkey PRIMARY KEY (family_id, profile_id);


--
-- Name: ingest_interview_debug_log ingest_interview_debug_log_pkey; Type: CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.ingest_interview_debug_log
    ADD CONSTRAINT ingest_interview_debug_log_pkey PRIMARY KEY (id);


--
-- Name: lesson_diary_entries lesson_diary_entries_pkey; Type: CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.lesson_diary_entries
    ADD CONSTRAINT lesson_diary_entries_pkey PRIMARY KEY (id);


--
-- Name: profile_info_family_member parent_info_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.profile_info_family_member
    ADD CONSTRAINT parent_info_pkey PRIMARY KEY (profile_id);


--
-- Name: protected_roles protected_roles_pkey; Type: CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.protected_roles
    ADD CONSTRAINT protected_roles_pkey PRIMARY KEY (role_id);


--
-- Name: public_holiday_and_breaks public_holiday_and_breaks_pkey; Type: CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.public_holiday_and_breaks
    ADD CONSTRAINT public_holiday_and_breaks_pkey PRIMARY KEY (id);


--
-- Name: published_drafts published_drafts_pkey; Type: CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.published_drafts
    ADD CONSTRAINT published_drafts_pkey PRIMARY KEY (id);


--
-- Name: recurrence_debug_log recurrence_debug_log_pkey; Type: CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.recurrence_debug_log
    ADD CONSTRAINT recurrence_debug_log_pkey PRIMARY KEY (id);


--
-- Name: registration_periods registration_periods_pkey; Type: CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.registration_periods
    ADD CONSTRAINT registration_periods_pkey PRIMARY KEY (id);


--
-- Name: roles roles_name_key; Type: CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.roles
    ADD CONSTRAINT roles_name_key UNIQUE (name);


--
-- Name: roles roles_pkey; Type: CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.roles
    ADD CONSTRAINT roles_pkey PRIMARY KEY (id);


--
-- Name: structure_rooms rooms_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.structure_rooms
    ADD CONSTRAINT rooms_pkey PRIMARY KEY (id);


--
-- Name: schedule_drafts schedule_drafts_pkey; Type: CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.schedule_drafts
    ADD CONSTRAINT schedule_drafts_pkey PRIMARY KEY (id);


--
-- Name: schema_change_log schema_change_log_pkey; Type: CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.schema_change_log
    ADD CONSTRAINT schema_change_log_pkey PRIMARY KEY (id);


--
-- Name: structure_school_semesters school_periods_pkey; Type: CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.structure_school_semesters
    ADD CONSTRAINT school_periods_pkey PRIMARY KEY (id);


--
-- Name: structure_school_years school_years_pkey; Type: CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.structure_school_years
    ADD CONSTRAINT school_years_pkey PRIMARY KEY (id);


--
-- Name: structure_schools schools_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.structure_schools
    ADD CONSTRAINT schools_pkey PRIMARY KEY (id);


--
-- Name: staff_absence_comments staff_absence_comments_pkey; Type: CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.staff_absence_comments
    ADD CONSTRAINT staff_absence_comments_pkey PRIMARY KEY (id);


--
-- Name: staff_absences staff_absences_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.staff_absences
    ADD CONSTRAINT staff_absences_pkey PRIMARY KEY (id);


--
-- Name: staff_class_links staff_class_links_pkey; Type: CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.staff_class_links
    ADD CONSTRAINT staff_class_links_pkey PRIMARY KEY (staff_id, class_id);


--
-- Name: staff_contracts staff_contracts_pkey; Type: CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.staff_contracts
    ADD CONSTRAINT staff_contracts_pkey PRIMARY KEY (id);


--
-- Name: staff_documents staff_documents_pkey; Type: CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.staff_documents
    ADD CONSTRAINT staff_documents_pkey PRIMARY KEY (id);


--
-- Name: staff_duty_plan staff_duty_plan_pkey; Type: CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.staff_duty_plan
    ADD CONSTRAINT staff_duty_plan_pkey PRIMARY KEY (id);


--
-- Name: profile_info_staff staff_info_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.profile_info_staff
    ADD CONSTRAINT staff_info_pkey PRIMARY KEY (profile_id);


--
-- Name: staff_subjects staff_subjects_pkey; Type: CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.staff_subjects
    ADD CONSTRAINT staff_subjects_pkey PRIMARY KEY (staff_id, subject_id);


--
-- Name: staff_work_contracts staff_work_contracts_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.staff_work_contracts
    ADD CONSTRAINT staff_work_contracts_pkey PRIMARY KEY (id);


--
-- Name: staff_yearly_preferences staff_yearly_preferences_pkey; Type: CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.staff_yearly_preferences
    ADD CONSTRAINT staff_yearly_preferences_pkey PRIMARY KEY (id);


--
-- Name: structure_days structure_days_day_number_key; Type: CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.structure_days
    ADD CONSTRAINT structure_days_day_number_key UNIQUE (day_number);


--
-- Name: structure_days structure_days_pkey; Type: CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.structure_days
    ADD CONSTRAINT structure_days_pkey PRIMARY KEY (id);


--
-- Name: structure_school_days structure_school_days_pkey; Type: CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.structure_school_days
    ADD CONSTRAINT structure_school_days_pkey PRIMARY KEY (school_id, day_id);


--
-- Name: student_absence_notes student_absence_notes_pkey; Type: CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.student_absence_notes
    ADD CONSTRAINT student_absence_notes_pkey PRIMARY KEY (id);


--
-- Name: student_absence_recurrences student_absence_recurrences_date_check; Type: CHECK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE public.student_absence_recurrences
    ADD CONSTRAINT student_absence_recurrences_date_check CHECK ((end_date >= start_date)) NOT VALID;


--
-- Name: student_absence_recurrences student_absence_recurrences_pkey; Type: CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.student_absence_recurrences
    ADD CONSTRAINT student_absence_recurrences_pkey PRIMARY KEY (id);


--
-- Name: student_absence_recurrences student_absence_recurrences_repeat_unit_check; Type: CHECK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE public.student_absence_recurrences
    ADD CONSTRAINT student_absence_recurrences_repeat_unit_check CHECK ((repeat_every_unit = ANY (ARRAY['day'::text, 'week'::text, 'month'::text]))) NOT VALID;


--
-- Name: student_absence_recurrences student_absence_recurrences_week_days_check; Type: CHECK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE public.student_absence_recurrences
    ADD CONSTRAINT student_absence_recurrences_week_days_check CHECK (((week_days IS NULL) OR ((array_length(week_days, 1) > 0) AND (week_days <@ ARRAY[(1)::smallint, (2)::smallint, (3)::smallint, (4)::smallint, (5)::smallint, (6)::smallint, (7)::smallint])))) NOT VALID;


--
-- Name: student_attendance_logs student_attendance_logs_pkey; Type: CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.student_attendance_logs
    ADD CONSTRAINT student_attendance_logs_pkey PRIMARY KEY (id);


--
-- Name: student_course_wish_choices student_course_wish_choices_pkey; Type: CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.student_course_wish_choices
    ADD CONSTRAINT student_course_wish_choices_pkey PRIMARY KEY (id);


--
-- Name: student_course_wish_choices student_course_wish_choices_submission_id_day_of_week_rank_key; Type: CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.student_course_wish_choices
    ADD CONSTRAINT student_course_wish_choices_submission_id_day_of_week_rank_key UNIQUE (submission_id, day_of_week, rank);


--
-- Name: student_course_wish_submissions student_course_wish_submissio_student_id_registration_perio_key; Type: CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.student_course_wish_submissions
    ADD CONSTRAINT student_course_wish_submissio_student_id_registration_perio_key UNIQUE (student_id, registration_period_id);


--
-- Name: student_course_wish_submissions student_course_wish_submissions_pkey; Type: CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.student_course_wish_submissions
    ADD CONSTRAINT student_course_wish_submissions_pkey PRIMARY KEY (id);


--
-- Name: student_daily_log student_daily_log_pkey; Type: CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.student_daily_log
    ADD CONSTRAINT student_daily_log_pkey PRIMARY KEY (id);


--
-- Name: student_emergency_information student_emergency_information_pkey; Type: CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.student_emergency_information
    ADD CONSTRAINT student_emergency_information_pkey PRIMARY KEY (id);


--
-- Name: profile_info_student student_info_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.profile_info_student
    ADD CONSTRAINT student_info_pkey PRIMARY KEY (profile_id);


--
-- Name: student_pickup_arrangement_overrides student_pickup_arrangement_overrides_pkey; Type: CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.student_pickup_arrangement_overrides
    ADD CONSTRAINT student_pickup_arrangement_overrides_pkey PRIMARY KEY (id);


--
-- Name: student_presence_events student_presence_events_pkey; Type: CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.student_presence_events
    ADD CONSTRAINT student_presence_events_pkey PRIMARY KEY (id);


--
-- Name: student_weekly_pickup_arrangements student_weekly_pickup_arrangements_pkey; Type: CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.student_weekly_pickup_arrangements
    ADD CONSTRAINT student_weekly_pickup_arrangements_pkey PRIMARY KEY (id);


--
-- Name: subject_class_hours subject_class_hours_pkey; Type: CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.subject_class_hours
    ADD CONSTRAINT subject_class_hours_pkey PRIMARY KEY (id);


--
-- Name: subject_grade_hours subject_grade_hours_pkey; Type: CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.subject_grade_hours
    ADD CONSTRAINT subject_grade_hours_pkey PRIMARY KEY (id);


--
-- Name: subject_icons subject_icons_name_key; Type: CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.subject_icons
    ADD CONSTRAINT subject_icons_name_key UNIQUE (name);


--
-- Name: subject_icons subject_icons_pkey; Type: CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.subject_icons
    ADD CONSTRAINT subject_icons_pkey PRIMARY KEY (id);


--
-- Name: subjects subjects_pkey; Type: CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.subjects
    ADD CONSTRAINT subjects_pkey PRIMARY KEY (id);


--
-- Name: substitutions substitutions_pkey; Type: CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.substitutions
    ADD CONSTRAINT substitutions_pkey PRIMARY KEY (id);


--
-- Name: schedule_periods time_blocks_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.schedule_periods
    ADD CONSTRAINT time_blocks_pkey PRIMARY KEY (id);


--
-- Name: course_registration_windows uniq_course_window_per_period; Type: CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.course_registration_windows
    ADD CONSTRAINT uniq_course_window_per_period UNIQUE (registration_period_id, course_id);


--
-- Name: family_member_child_links unique_child_adult_in_family; Type: CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.family_member_child_links
    ADD CONSTRAINT unique_child_adult_in_family UNIQUE (family_id, adult_profile_id, child_profile_id);


--
-- Name: course_possible_times unique_course_possible_time; Type: CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.course_possible_times
    ADD CONSTRAINT unique_course_possible_time UNIQUE (course_id, weekday, schedule_period_id);


--
-- Name: profile_info_family_member unique_profile_info; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.profile_info_family_member
    ADD CONSTRAINT unique_profile_info UNIQUE (profile_id);


--
-- Name: user_roles unique_profile_role; Type: CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.user_roles
    ADD CONSTRAINT unique_profile_role UNIQUE (user_profile_id, role_id);


--
-- Name: student_emergency_information unique_student_emergency_info; Type: CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.student_emergency_information
    ADD CONSTRAINT unique_student_emergency_info UNIQUE (student_id);


--
-- Name: student_attendance_logs unique_student_lesson_attendance; Type: CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.student_attendance_logs
    ADD CONSTRAINT unique_student_lesson_attendance UNIQUE (student_id, lesson_id);


--
-- Name: student_daily_log unique_student_school_date; Type: CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.student_daily_log
    ADD CONSTRAINT unique_student_school_date UNIQUE (student_id, school_id, date);


--
-- Name: course_schedules uq_course_sched_course; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.course_schedules
    ADD CONSTRAINT uq_course_sched_course UNIQUE (school_id, course_id, period_id, day_id);


--
-- Name: course_schedules uq_course_sched_schoollesson; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.course_schedules
    ADD CONSTRAINT uq_course_sched_schoollesson UNIQUE (school_id, subject_id, class_id, period_id, day_id);


--
-- Name: user_codes user_codes_pkey; Type: CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.user_codes
    ADD CONSTRAINT user_codes_pkey PRIMARY KEY (id);


--
-- Name: user_group_members user_group_members_pkey; Type: CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.user_group_members
    ADD CONSTRAINT user_group_members_pkey PRIMARY KEY (group_id, user_id);


--
-- Name: user_groups user_groups_pkey; Type: CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.user_groups
    ADD CONSTRAINT user_groups_pkey PRIMARY KEY (id);


--
-- Name: user_roles user_roles_pkey; Type: CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.user_roles
    ADD CONSTRAINT user_roles_pkey PRIMARY KEY (id);


--
-- Name: messages messages_pkey; Type: CONSTRAINT; Schema: realtime; Owner: supabase_realtime_admin
--

ALTER TABLE ONLY realtime.messages
    ADD CONSTRAINT messages_pkey PRIMARY KEY (id, inserted_at);


--
-- Name: messages_2025_08_25 messages_2025_08_25_pkey; Type: CONSTRAINT; Schema: realtime; Owner: supabase_admin
--

ALTER TABLE ONLY realtime.messages_2025_08_25
    ADD CONSTRAINT messages_2025_08_25_pkey PRIMARY KEY (id, inserted_at);


--
-- Name: messages_2025_08_26 messages_2025_08_26_pkey; Type: CONSTRAINT; Schema: realtime; Owner: supabase_admin
--

ALTER TABLE ONLY realtime.messages_2025_08_26
    ADD CONSTRAINT messages_2025_08_26_pkey PRIMARY KEY (id, inserted_at);


--
-- Name: messages_2025_08_27 messages_2025_08_27_pkey; Type: CONSTRAINT; Schema: realtime; Owner: supabase_admin
--

ALTER TABLE ONLY realtime.messages_2025_08_27
    ADD CONSTRAINT messages_2025_08_27_pkey PRIMARY KEY (id, inserted_at);


--
-- Name: messages_2025_08_28 messages_2025_08_28_pkey; Type: CONSTRAINT; Schema: realtime; Owner: supabase_admin
--

ALTER TABLE ONLY realtime.messages_2025_08_28
    ADD CONSTRAINT messages_2025_08_28_pkey PRIMARY KEY (id, inserted_at);


--
-- Name: messages_2025_08_29 messages_2025_08_29_pkey; Type: CONSTRAINT; Schema: realtime; Owner: supabase_admin
--

ALTER TABLE ONLY realtime.messages_2025_08_29
    ADD CONSTRAINT messages_2025_08_29_pkey PRIMARY KEY (id, inserted_at);


--
-- Name: messages_2025_08_30 messages_2025_08_30_pkey; Type: CONSTRAINT; Schema: realtime; Owner: supabase_admin
--

ALTER TABLE ONLY realtime.messages_2025_08_30
    ADD CONSTRAINT messages_2025_08_30_pkey PRIMARY KEY (id, inserted_at);


--
-- Name: messages_2025_08_31 messages_2025_08_31_pkey; Type: CONSTRAINT; Schema: realtime; Owner: supabase_admin
--

ALTER TABLE ONLY realtime.messages_2025_08_31
    ADD CONSTRAINT messages_2025_08_31_pkey PRIMARY KEY (id, inserted_at);


--
-- Name: subscription pk_subscription; Type: CONSTRAINT; Schema: realtime; Owner: supabase_admin
--

ALTER TABLE ONLY realtime.subscription
    ADD CONSTRAINT pk_subscription PRIMARY KEY (id);


--
-- Name: schema_migrations schema_migrations_pkey; Type: CONSTRAINT; Schema: realtime; Owner: supabase_admin
--

ALTER TABLE ONLY realtime.schema_migrations
    ADD CONSTRAINT schema_migrations_pkey PRIMARY KEY (version);


--
-- Name: buckets buckets_pkey; Type: CONSTRAINT; Schema: storage; Owner: supabase_storage_admin
--

ALTER TABLE ONLY storage.buckets
    ADD CONSTRAINT buckets_pkey PRIMARY KEY (id);


--
-- Name: migrations migrations_name_key; Type: CONSTRAINT; Schema: storage; Owner: supabase_storage_admin
--

ALTER TABLE ONLY storage.migrations
    ADD CONSTRAINT migrations_name_key UNIQUE (name);


--
-- Name: migrations migrations_pkey; Type: CONSTRAINT; Schema: storage; Owner: supabase_storage_admin
--

ALTER TABLE ONLY storage.migrations
    ADD CONSTRAINT migrations_pkey PRIMARY KEY (id);


--
-- Name: objects objects_pkey; Type: CONSTRAINT; Schema: storage; Owner: supabase_storage_admin
--

ALTER TABLE ONLY storage.objects
    ADD CONSTRAINT objects_pkey PRIMARY KEY (id);


--
-- Name: prefixes prefixes_pkey; Type: CONSTRAINT; Schema: storage; Owner: supabase_storage_admin
--

ALTER TABLE ONLY storage.prefixes
    ADD CONSTRAINT prefixes_pkey PRIMARY KEY (bucket_id, level, name);


--
-- Name: s3_multipart_uploads_parts s3_multipart_uploads_parts_pkey; Type: CONSTRAINT; Schema: storage; Owner: supabase_storage_admin
--

ALTER TABLE ONLY storage.s3_multipart_uploads_parts
    ADD CONSTRAINT s3_multipart_uploads_parts_pkey PRIMARY KEY (id);


--
-- Name: s3_multipart_uploads s3_multipart_uploads_pkey; Type: CONSTRAINT; Schema: storage; Owner: supabase_storage_admin
--

ALTER TABLE ONLY storage.s3_multipart_uploads
    ADD CONSTRAINT s3_multipart_uploads_pkey PRIMARY KEY (id);


--
-- Name: tenants tenants_pkey; Type: CONSTRAINT; Schema: storage; Owner: postgres
--

ALTER TABLE ONLY storage.tenants
    ADD CONSTRAINT tenants_pkey PRIMARY KEY (id);


--
-- Name: hooks hooks_pkey; Type: CONSTRAINT; Schema: supabase_functions; Owner: supabase_functions_admin
--

ALTER TABLE ONLY supabase_functions.hooks
    ADD CONSTRAINT hooks_pkey PRIMARY KEY (id);


--
-- Name: migrations migrations_pkey; Type: CONSTRAINT; Schema: supabase_functions; Owner: supabase_functions_admin
--

ALTER TABLE ONLY supabase_functions.migrations
    ADD CONSTRAINT migrations_pkey PRIMARY KEY (version);


--
-- Name: extensions_tenant_external_id_index; Type: INDEX; Schema: _realtime; Owner: supabase_admin
--

CREATE INDEX extensions_tenant_external_id_index ON _realtime.extensions USING btree (tenant_external_id);


--
-- Name: extensions_tenant_external_id_type_index; Type: INDEX; Schema: _realtime; Owner: supabase_admin
--

CREATE UNIQUE INDEX extensions_tenant_external_id_type_index ON _realtime.extensions USING btree (tenant_external_id, type);


--
-- Name: tenants_external_id_index; Type: INDEX; Schema: _realtime; Owner: supabase_admin
--

CREATE UNIQUE INDEX tenants_external_id_index ON _realtime.tenants USING btree (external_id);


--
-- Name: audit_logs_instance_id_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX audit_logs_instance_id_idx ON auth.audit_log_entries USING btree (instance_id);


--
-- Name: confirmation_token_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE UNIQUE INDEX confirmation_token_idx ON auth.users USING btree (confirmation_token) WHERE ((confirmation_token)::text !~ '^[0-9 ]*$'::text);


--
-- Name: email_change_token_current_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE UNIQUE INDEX email_change_token_current_idx ON auth.users USING btree (email_change_token_current) WHERE ((email_change_token_current)::text !~ '^[0-9 ]*$'::text);


--
-- Name: email_change_token_new_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE UNIQUE INDEX email_change_token_new_idx ON auth.users USING btree (email_change_token_new) WHERE ((email_change_token_new)::text !~ '^[0-9 ]*$'::text);


--
-- Name: factor_id_created_at_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX factor_id_created_at_idx ON auth.mfa_factors USING btree (user_id, created_at);


--
-- Name: flow_state_created_at_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX flow_state_created_at_idx ON auth.flow_state USING btree (created_at DESC);


--
-- Name: identities_email_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX identities_email_idx ON auth.identities USING btree (email text_pattern_ops);


--
-- Name: INDEX identities_email_idx; Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON INDEX auth.identities_email_idx IS 'Auth: Ensures indexed queries on the email column';


--
-- Name: identities_user_id_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX identities_user_id_idx ON auth.identities USING btree (user_id);


--
-- Name: idx_auth_code; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX idx_auth_code ON auth.flow_state USING btree (auth_code);


--
-- Name: idx_user_id_auth_method; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX idx_user_id_auth_method ON auth.flow_state USING btree (user_id, authentication_method);


--
-- Name: mfa_challenge_created_at_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX mfa_challenge_created_at_idx ON auth.mfa_challenges USING btree (created_at DESC);


--
-- Name: mfa_factors_user_friendly_name_unique; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE UNIQUE INDEX mfa_factors_user_friendly_name_unique ON auth.mfa_factors USING btree (friendly_name, user_id) WHERE (TRIM(BOTH FROM friendly_name) <> ''::text);


--
-- Name: mfa_factors_user_id_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX mfa_factors_user_id_idx ON auth.mfa_factors USING btree (user_id);


--
-- Name: one_time_tokens_relates_to_hash_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX one_time_tokens_relates_to_hash_idx ON auth.one_time_tokens USING hash (relates_to);


--
-- Name: one_time_tokens_token_hash_hash_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX one_time_tokens_token_hash_hash_idx ON auth.one_time_tokens USING hash (token_hash);


--
-- Name: one_time_tokens_user_id_token_type_key; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE UNIQUE INDEX one_time_tokens_user_id_token_type_key ON auth.one_time_tokens USING btree (user_id, token_type);


--
-- Name: reauthentication_token_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE UNIQUE INDEX reauthentication_token_idx ON auth.users USING btree (reauthentication_token) WHERE ((reauthentication_token)::text !~ '^[0-9 ]*$'::text);


--
-- Name: recovery_token_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE UNIQUE INDEX recovery_token_idx ON auth.users USING btree (recovery_token) WHERE ((recovery_token)::text !~ '^[0-9 ]*$'::text);


--
-- Name: refresh_tokens_instance_id_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX refresh_tokens_instance_id_idx ON auth.refresh_tokens USING btree (instance_id);


--
-- Name: refresh_tokens_instance_id_user_id_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX refresh_tokens_instance_id_user_id_idx ON auth.refresh_tokens USING btree (instance_id, user_id);


--
-- Name: refresh_tokens_parent_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX refresh_tokens_parent_idx ON auth.refresh_tokens USING btree (parent);


--
-- Name: refresh_tokens_session_id_revoked_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX refresh_tokens_session_id_revoked_idx ON auth.refresh_tokens USING btree (session_id, revoked);


--
-- Name: refresh_tokens_updated_at_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX refresh_tokens_updated_at_idx ON auth.refresh_tokens USING btree (updated_at DESC);


--
-- Name: saml_providers_sso_provider_id_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX saml_providers_sso_provider_id_idx ON auth.saml_providers USING btree (sso_provider_id);


--
-- Name: saml_relay_states_created_at_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX saml_relay_states_created_at_idx ON auth.saml_relay_states USING btree (created_at DESC);


--
-- Name: saml_relay_states_for_email_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX saml_relay_states_for_email_idx ON auth.saml_relay_states USING btree (for_email);


--
-- Name: saml_relay_states_sso_provider_id_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX saml_relay_states_sso_provider_id_idx ON auth.saml_relay_states USING btree (sso_provider_id);


--
-- Name: sessions_not_after_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX sessions_not_after_idx ON auth.sessions USING btree (not_after DESC);


--
-- Name: sessions_user_id_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX sessions_user_id_idx ON auth.sessions USING btree (user_id);


--
-- Name: sso_domains_domain_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE UNIQUE INDEX sso_domains_domain_idx ON auth.sso_domains USING btree (lower(domain));


--
-- Name: sso_domains_sso_provider_id_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX sso_domains_sso_provider_id_idx ON auth.sso_domains USING btree (sso_provider_id);


--
-- Name: sso_providers_resource_id_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE UNIQUE INDEX sso_providers_resource_id_idx ON auth.sso_providers USING btree (lower(resource_id));


--
-- Name: unique_phone_factor_per_user; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE UNIQUE INDEX unique_phone_factor_per_user ON auth.mfa_factors USING btree (user_id, phone);


--
-- Name: user_id_created_at_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX user_id_created_at_idx ON auth.sessions USING btree (user_id, created_at);


--
-- Name: users_email_partial_key; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE UNIQUE INDEX users_email_partial_key ON auth.users USING btree (email) WHERE (is_sso_user = false);


--
-- Name: INDEX users_email_partial_key; Type: COMMENT; Schema: auth; Owner: supabase_auth_admin
--

COMMENT ON INDEX auth.users_email_partial_key IS 'Auth: A partial unique index that applies only when is_sso_user is false';


--
-- Name: users_instance_id_email_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX users_instance_id_email_idx ON auth.users USING btree (instance_id, lower((email)::text));


--
-- Name: users_instance_id_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX users_instance_id_idx ON auth.users USING btree (instance_id);


--
-- Name: users_is_anonymous_idx; Type: INDEX; Schema: auth; Owner: supabase_auth_admin
--

CREATE INDEX users_is_anonymous_idx ON auth.users USING btree (is_anonymous);


--
-- Name: cad_idx_counts; Type: INDEX; Schema: public; Owner: supabase_admin
--

CREATE INDEX cad_idx_counts ON public.course_allocation_drafts USING btree (registration_period_id, semester_id, school_id, day_of_week, target_course_id);


--
-- Name: idx_absence_notes_date_range; Type: INDEX; Schema: public; Owner: supabase_admin
--

CREATE INDEX idx_absence_notes_date_range ON public.student_absence_notes USING btree (start_date, end_date);


--
-- Name: idx_absence_notes_school_status; Type: INDEX; Schema: public; Owner: supabase_admin
--

CREATE INDEX idx_absence_notes_school_status ON public.student_absence_notes USING btree (school_id, status) WHERE (deleted_at IS NULL);


--
-- Name: idx_absence_notes_student_date; Type: INDEX; Schema: public; Owner: supabase_admin
--

CREATE INDEX idx_absence_notes_student_date ON public.student_absence_notes USING btree (student_id, start_date);


--
-- Name: idx_absences_staff_date; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_absences_staff_date ON public.staff_absences USING btree (staff_id, date);


--
-- Name: idx_attendance_student_lesson; Type: INDEX; Schema: public; Owner: supabase_admin
--

CREATE INDEX idx_attendance_student_lesson ON public.student_attendance_logs USING btree (student_id, lesson_id);


--
-- Name: idx_bulletin_post_users_user_id; Type: INDEX; Schema: public; Owner: supabase_admin
--

CREATE INDEX idx_bulletin_post_users_user_id ON public.bulletin_post_users USING btree (user_id);


--
-- Name: idx_bulletin_posts_visible_groups; Type: INDEX; Schema: public; Owner: supabase_admin
--

CREATE INDEX idx_bulletin_posts_visible_groups ON public.bulletin_posts USING gin (visible_groups);


--
-- Name: idx_course_applications_school_period; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_course_applications_school_period ON public.course_applications USING btree (school_id, registration_period_id);


--
-- Name: idx_course_enrollments_school_course; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_course_enrollments_school_course ON public.course_enrollments USING btree (school_id, course_id);


--
-- Name: idx_course_lessons_class_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_course_lessons_class_id ON public.course_lessons USING btree (class_id);


--
-- Name: idx_course_lessons_course_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_course_lessons_course_id ON public.course_lessons USING btree (course_id);


--
-- Name: idx_course_lessons_primary_teacher_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_course_lessons_primary_teacher_id ON public.course_lessons USING btree (primary_teacher_id);


--
-- Name: idx_course_lessons_schedule; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_course_lessons_schedule ON public.course_lessons USING btree (schedule_id);


--
-- Name: idx_course_lessons_schedule_date; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_course_lessons_schedule_date ON public.course_lessons USING btree (schedule_id, start_datetime);


--
-- Name: idx_course_lessons_schedule_start; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_course_lessons_schedule_start ON public.course_lessons USING btree (schedule_id, start_datetime);


--
-- Name: idx_course_lessons_school_date; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_course_lessons_school_date ON public.course_lessons USING btree (school_id, start_datetime);


--
-- Name: idx_course_lessons_start; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_course_lessons_start ON public.course_lessons USING btree (start_datetime);


--
-- Name: idx_course_lessons_teacher_ids; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_course_lessons_teacher_ids ON public.course_lessons USING gin (teacher_ids);


--
-- Name: idx_course_lessons_timespan; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_course_lessons_timespan ON public.course_lessons USING btree (school_id, class_id, start_datetime, end_datetime);


--
-- Name: idx_course_notes_context; Type: INDEX; Schema: public; Owner: supabase_admin
--

CREATE INDEX idx_course_notes_context ON public.course_notes USING btree (school_id, registration_period_id, semester_id, day_of_week);


--
-- Name: idx_course_notes_course_id; Type: INDEX; Schema: public; Owner: supabase_admin
--

CREATE INDEX idx_course_notes_course_id ON public.course_notes USING btree (course_id);


--
-- Name: idx_course_notes_day_of_week; Type: INDEX; Schema: public; Owner: supabase_admin
--

CREATE INDEX idx_course_notes_day_of_week ON public.course_notes USING btree (day_of_week);


--
-- Name: idx_course_notes_is_problem; Type: INDEX; Schema: public; Owner: supabase_admin
--

CREATE INDEX idx_course_notes_is_problem ON public.course_notes USING btree (is_problem);


--
-- Name: idx_course_notes_is_resolved; Type: INDEX; Schema: public; Owner: supabase_admin
--

CREATE INDEX idx_course_notes_is_resolved ON public.course_notes USING btree (is_resolved);


--
-- Name: idx_course_offers_approved_by; Type: INDEX; Schema: public; Owner: supabase_admin
--

CREATE INDEX idx_course_offers_approved_by ON public.course_offers USING btree (approved_by);


--
-- Name: idx_course_offers_converted_course; Type: INDEX; Schema: public; Owner: supabase_admin
--

CREATE INDEX idx_course_offers_converted_course ON public.course_offers USING btree (converted_to_course_id) WHERE (converted_to_course_id IS NOT NULL);


--
-- Name: idx_course_offers_created_at; Type: INDEX; Schema: public; Owner: supabase_admin
--

CREATE INDEX idx_course_offers_created_at ON public.course_offers USING btree (created_at);


--
-- Name: idx_course_offers_grade_levels; Type: INDEX; Schema: public; Owner: supabase_admin
--

CREATE INDEX idx_course_offers_grade_levels ON public.course_offers USING gin (is_for_year_g);


--
-- Name: idx_course_offers_pending; Type: INDEX; Schema: public; Owner: supabase_admin
--

CREATE INDEX idx_course_offers_pending ON public.course_offers USING btree (school_id, status, created_at) WHERE (status = 'pending'::text);


--
-- Name: idx_course_offers_proposed_by; Type: INDEX; Schema: public; Owner: supabase_admin
--

CREATE INDEX idx_course_offers_proposed_by ON public.course_offers USING btree (proposed_by);


--
-- Name: idx_course_offers_school_id; Type: INDEX; Schema: public; Owner: supabase_admin
--

CREATE INDEX idx_course_offers_school_id ON public.course_offers USING btree (school_id);


--
-- Name: idx_course_offers_status; Type: INDEX; Schema: public; Owner: supabase_admin
--

CREATE INDEX idx_course_offers_status ON public.course_offers USING btree (status);


--
-- Name: idx_course_offers_status_school; Type: INDEX; Schema: public; Owner: supabase_admin
--

CREATE INDEX idx_course_offers_status_school ON public.course_offers USING btree (school_id, status);


--
-- Name: idx_course_possible_room_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_course_possible_room_id ON public.course_list USING btree (possible_room_id);


--
-- Name: idx_course_registration_windows_active; Type: INDEX; Schema: public; Owner: supabase_admin
--

CREATE INDEX idx_course_registration_windows_active ON public.course_registration_windows USING btree (opens_at, closes_at);


--
-- Name: idx_course_registration_windows_course; Type: INDEX; Schema: public; Owner: supabase_admin
--

CREATE INDEX idx_course_registration_windows_course ON public.course_registration_windows USING btree (course_id);


--
-- Name: idx_course_registration_windows_period; Type: INDEX; Schema: public; Owner: supabase_admin
--

CREATE INDEX idx_course_registration_windows_period ON public.course_registration_windows USING btree (registration_period_id);


--
-- Name: idx_course_registration_windows_school_semester; Type: INDEX; Schema: public; Owner: supabase_admin
--

CREATE INDEX idx_course_registration_windows_school_semester ON public.course_registration_windows USING btree (school_id, semester_id);


--
-- Name: idx_course_schedules_primary_teacher_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_course_schedules_primary_teacher_id ON public.course_schedules USING btree (primary_teacher_id);


--
-- Name: idx_course_schedules_school_course_period_day; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_course_schedules_school_course_period_day ON public.course_schedules USING btree (school_id, course_id, period_id, day_id);


--
-- Name: idx_course_schedules_school_period_day_course; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_course_schedules_school_period_day_course ON public.course_schedules USING btree (school_id, period_id, day_id, course_id);


--
-- Name: idx_course_schedules_school_period_day_subject_class; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_course_schedules_school_period_day_subject_class ON public.course_schedules USING btree (school_id, period_id, day_id, subject_id, class_id);


--
-- Name: idx_course_schedules_school_subject_class_period_day; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_course_schedules_school_subject_class_period_day ON public.course_schedules USING btree (school_id, subject_id, class_id, period_id, day_id);


--
-- Name: idx_course_subject_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_course_subject_id ON public.course_list USING btree (subject_id);


--
-- Name: idx_crw_grade_levels_gin; Type: INDEX; Schema: public; Owner: supabase_admin
--

CREATE INDEX idx_crw_grade_levels_gin ON public.course_registration_windows USING gin (grade_levels);


--
-- Name: idx_daily_log_student_date; Type: INDEX; Schema: public; Owner: supabase_admin
--

CREATE INDEX idx_daily_log_student_date ON public.student_daily_log USING btree (student_id, date);


--
-- Name: idx_family_member_child_links_adult_profile_id; Type: INDEX; Schema: public; Owner: supabase_admin
--

CREATE INDEX idx_family_member_child_links_adult_profile_id ON public.family_member_child_links USING btree (adult_profile_id);


--
-- Name: idx_family_member_child_links_child_profile_id; Type: INDEX; Schema: public; Owner: supabase_admin
--

CREATE INDEX idx_family_member_child_links_child_profile_id ON public.family_member_child_links USING btree (child_profile_id);


--
-- Name: idx_family_member_child_links_composite; Type: INDEX; Schema: public; Owner: supabase_admin
--

CREATE INDEX idx_family_member_child_links_composite ON public.family_member_child_links USING btree (adult_profile_id, child_profile_id);


--
-- Name: idx_fmcl__adult_access_child; Type: INDEX; Schema: public; Owner: supabase_admin
--

CREATE INDEX idx_fmcl__adult_access_child ON public.family_member_child_links USING btree (adult_profile_id, access_restricted, child_profile_id);


--
-- Name: idx_fmcl__adult_profile_access_child; Type: INDEX; Schema: public; Owner: supabase_admin
--

CREATE INDEX idx_fmcl__adult_profile_access_child ON public.family_member_child_links USING btree (adult_profile_id, access_restricted, child_profile_id);


--
-- Name: idx_fmcl__child_profile_id; Type: INDEX; Schema: public; Owner: supabase_admin
--

CREATE INDEX idx_fmcl__child_profile_id ON public.family_member_child_links USING btree (child_profile_id);


--
-- Name: idx_lesson_diary_entries_created_by; Type: INDEX; Schema: public; Owner: supabase_admin
--

CREATE INDEX idx_lesson_diary_entries_created_by ON public.lesson_diary_entries USING btree (created_by);


--
-- Name: idx_lesson_diary_entries_lesson_created; Type: INDEX; Schema: public; Owner: supabase_admin
--

CREATE INDEX idx_lesson_diary_entries_lesson_created ON public.lesson_diary_entries USING btree (lesson_id, created_at);


--
-- Name: idx_lesson_diary_entries_lesson_id; Type: INDEX; Schema: public; Owner: supabase_admin
--

CREATE INDEX idx_lesson_diary_entries_lesson_id ON public.lesson_diary_entries USING btree (lesson_id);


--
-- Name: idx_lesson_diary_entries_privacy; Type: INDEX; Schema: public; Owner: supabase_admin
--

CREATE INDEX idx_lesson_diary_entries_privacy ON public.lesson_diary_entries USING btree (is_private);


--
-- Name: idx_lesson_diary_entries_school_created; Type: INDEX; Schema: public; Owner: supabase_admin
--

CREATE INDEX idx_lesson_diary_entries_school_created ON public.lesson_diary_entries USING btree (school_id, created_at);


--
-- Name: idx_lesson_diary_entries_school_id; Type: INDEX; Schema: public; Owner: supabase_admin
--

CREATE INDEX idx_lesson_diary_entries_school_id ON public.lesson_diary_entries USING btree (school_id);


--
-- Name: idx_lesson_diary_entries_teacher_created; Type: INDEX; Schema: public; Owner: supabase_admin
--

CREATE INDEX idx_lesson_diary_entries_teacher_created ON public.lesson_diary_entries USING btree (created_by, created_at);


--
-- Name: idx_lesson_diary_entries_type; Type: INDEX; Schema: public; Owner: supabase_admin
--

CREATE INDEX idx_lesson_diary_entries_type ON public.lesson_diary_entries USING btree (entry_type);


--
-- Name: idx_lessons_date_period; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_lessons_date_period ON public.course_lessons USING btree (start_datetime, period_id);


--
-- Name: idx_pis__class_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_pis__class_id ON public.profile_info_student USING btree (class_id);


--
-- Name: idx_pis__profile_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_pis__profile_id ON public.profile_info_student USING btree (profile_id);


--
-- Name: idx_presence_events_student; Type: INDEX; Schema: public; Owner: supabase_admin
--

CREATE INDEX idx_presence_events_student ON public.student_presence_events USING btree (student_id, "timestamp");


--
-- Name: idx_profile_info_student__class_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_profile_info_student__class_id ON public.profile_info_student USING btree (class_id);


--
-- Name: idx_profile_info_student__profile_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_profile_info_student__profile_id ON public.profile_info_student USING btree (profile_id);


--
-- Name: idx_published_drafts_draft_id; Type: INDEX; Schema: public; Owner: supabase_admin
--

CREATE INDEX idx_published_drafts_draft_id ON public.published_drafts USING btree (draft_id);


--
-- Name: idx_published_drafts_published_at; Type: INDEX; Schema: public; Owner: supabase_admin
--

CREATE INDEX idx_published_drafts_published_at ON public.published_drafts USING btree (published_at);


--
-- Name: idx_published_drafts_school_semester; Type: INDEX; Schema: public; Owner: supabase_admin
--

CREATE INDEX idx_published_drafts_school_semester ON public.published_drafts USING btree (school_id, semester_id);


--
-- Name: idx_published_drafts_unique_success; Type: INDEX; Schema: public; Owner: supabase_admin
--

CREATE UNIQUE INDEX idx_published_drafts_unique_success ON public.published_drafts USING btree (draft_id) WHERE (status = 'success'::text);


--
-- Name: idx_registration_periods_created_by; Type: INDEX; Schema: public; Owner: supabase_admin
--

CREATE INDEX idx_registration_periods_created_by ON public.registration_periods USING btree (created_by_id);


--
-- Name: idx_registration_periods_school_semester; Type: INDEX; Schema: public; Owner: supabase_admin
--

CREATE INDEX idx_registration_periods_school_semester ON public.registration_periods USING btree (school_id, semester_id);


--
-- Name: idx_registration_periods_status; Type: INDEX; Schema: public; Owner: supabase_admin
--

CREATE INDEX idx_registration_periods_status ON public.registration_periods USING btree (status);


--
-- Name: idx_roles_name; Type: INDEX; Schema: public; Owner: supabase_admin
--

CREATE INDEX idx_roles_name ON public.roles USING btree (name);


--
-- Name: idx_roles_name_subrole; Type: INDEX; Schema: public; Owner: supabase_admin
--

CREATE INDEX idx_roles_name_subrole ON public.roles USING btree (name, is_subrole) WHERE (is_subrole = false);


--
-- Name: idx_schedule_periods_school; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_schedule_periods_school ON public.schedule_periods USING btree (school_id, block_type);


--
-- Name: idx_scwc_submission_day; Type: INDEX; Schema: public; Owner: supabase_admin
--

CREATE INDEX idx_scwc_submission_day ON public.student_course_wish_choices USING btree (submission_id, day_of_week);


--
-- Name: idx_scwc_submission_window; Type: INDEX; Schema: public; Owner: supabase_admin
--

CREATE INDEX idx_scwc_submission_window ON public.student_course_wish_choices USING btree (submission_id, window_id) WHERE (no_offer = false);


--
-- Name: idx_scws_school_period; Type: INDEX; Schema: public; Owner: supabase_admin
--

CREATE INDEX idx_scws_school_period ON public.student_course_wish_submissions USING btree (school_id, registration_period_id);


--
-- Name: idx_structure_classes__school_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_structure_classes__school_id ON public.structure_classes USING btree (school_id);


--
-- Name: idx_structure_classes_school_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_structure_classes_school_id ON public.structure_classes USING btree (school_id);


--
-- Name: idx_student_absence_recurrences_dates; Type: INDEX; Schema: public; Owner: supabase_admin
--

CREATE INDEX idx_student_absence_recurrences_dates ON public.student_absence_recurrences USING btree (start_date, end_date);


--
-- Name: idx_student_absence_recurrences_unit; Type: INDEX; Schema: public; Owner: supabase_admin
--

CREATE INDEX idx_student_absence_recurrences_unit ON public.student_absence_recurrences USING btree (repeat_every_unit);


--
-- Name: idx_student_attendance_logs_absence_note_id; Type: INDEX; Schema: public; Owner: supabase_admin
--

CREATE INDEX idx_student_attendance_logs_absence_note_id ON public.student_attendance_logs USING btree (absence_note_id);


--
-- Name: idx_student_attendance_logs_lesson; Type: INDEX; Schema: public; Owner: supabase_admin
--

CREATE INDEX idx_student_attendance_logs_lesson ON public.student_attendance_logs USING btree (lesson_id);


--
-- Name: idx_student_daily_log_absence_note_id; Type: INDEX; Schema: public; Owner: supabase_admin
--

CREATE INDEX idx_student_daily_log_absence_note_id ON public.student_daily_log USING btree (absence_note_id);


--
-- Name: idx_student_emergency_info_contacts_profile_id; Type: INDEX; Schema: public; Owner: supabase_admin
--

CREATE INDEX idx_student_emergency_info_contacts_profile_id ON public.student_emergency_information USING gin (emergency_contacts);


--
-- Name: idx_student_emergency_info_created_by; Type: INDEX; Schema: public; Owner: supabase_admin
--

CREATE INDEX idx_student_emergency_info_created_by ON public.student_emergency_information USING btree (created_by);


--
-- Name: idx_student_emergency_info_medical_conditions; Type: INDEX; Schema: public; Owner: supabase_admin
--

CREATE INDEX idx_student_emergency_info_medical_conditions ON public.student_emergency_information USING gin (medical_information);


--
-- Name: idx_student_emergency_info_school_id; Type: INDEX; Schema: public; Owner: supabase_admin
--

CREATE INDEX idx_student_emergency_info_school_id ON public.student_emergency_information USING btree (school_id);


--
-- Name: idx_student_emergency_info_student_id; Type: INDEX; Schema: public; Owner: supabase_admin
--

CREATE INDEX idx_student_emergency_info_student_id ON public.student_emergency_information USING btree (student_id);


--
-- Name: idx_student_emergency_info_updated_at; Type: INDEX; Schema: public; Owner: supabase_admin
--

CREATE INDEX idx_student_emergency_info_updated_at ON public.student_emergency_information USING btree (updated_at);


--
-- Name: idx_substitutions_substitute; Type: INDEX; Schema: public; Owner: supabase_admin
--

CREATE INDEX idx_substitutions_substitute ON public.substitutions USING btree (substitute_staff_id, status);


--
-- Name: idx_user_codes_code; Type: INDEX; Schema: public; Owner: supabase_admin
--

CREATE INDEX idx_user_codes_code ON public.user_codes USING btree (code);


--
-- Name: idx_user_codes_code_profile_status; Type: INDEX; Schema: public; Owner: supabase_admin
--

CREATE INDEX idx_user_codes_code_profile_status ON public.user_codes USING btree (code, profile_id, used_at, revoked_at, expires_at) WHERE ((used_at IS NULL) AND (revoked_at IS NULL));


--
-- Name: idx_user_codes_created_by; Type: INDEX; Schema: public; Owner: supabase_admin
--

CREATE INDEX idx_user_codes_created_by ON public.user_codes USING btree (created_by);


--
-- Name: idx_user_codes_expires_at; Type: INDEX; Schema: public; Owner: supabase_admin
--

CREATE INDEX idx_user_codes_expires_at ON public.user_codes USING btree (expires_at);


--
-- Name: idx_user_codes_profile_id; Type: INDEX; Schema: public; Owner: supabase_admin
--

CREATE INDEX idx_user_codes_profile_id ON public.user_codes USING btree (profile_id);


--
-- Name: idx_user_codes_profile_id_code_instance; Type: INDEX; Schema: public; Owner: supabase_admin
--

CREATE INDEX idx_user_codes_profile_id_code_instance ON public.user_codes USING btree (profile_id, code_instance);


--
-- Name: idx_user_codes_revoked_at; Type: INDEX; Schema: public; Owner: supabase_admin
--

CREATE INDEX idx_user_codes_revoked_at ON public.user_codes USING btree (revoked_at);


--
-- Name: idx_user_codes_unused; Type: INDEX; Schema: public; Owner: supabase_admin
--

CREATE INDEX idx_user_codes_unused ON public.user_codes USING btree (used_at, revoked_at) WHERE ((used_at IS NULL) AND (revoked_at IS NULL));


--
-- Name: idx_user_group_members_user_id; Type: INDEX; Schema: public; Owner: supabase_admin
--

CREATE INDEX idx_user_group_members_user_id ON public.user_group_members USING btree (user_id);


--
-- Name: idx_user_profiles_account_status; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_user_profiles_account_status ON public.user_profiles USING btree (account_status) WHERE (account_status <> ALL (ARRAY['deleted'::public.account_status_enum, 'suspended'::public.account_status_enum]));


--
-- Name: idx_user_profiles_role_id; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_user_profiles_role_id ON public.user_profiles USING btree (role_id);


--
-- Name: idx_user_roles_role_id; Type: INDEX; Schema: public; Owner: supabase_admin
--

CREATE INDEX idx_user_roles_role_id ON public.user_roles USING btree (role_id);


--
-- Name: idx_user_roles_user_profile_id; Type: INDEX; Schema: public; Owner: supabase_admin
--

CREATE INDEX idx_user_roles_user_profile_id ON public.user_roles USING btree (user_profile_id);


--
-- Name: ingest_interview_debug_log_created_at_idx; Type: INDEX; Schema: public; Owner: supabase_admin
--

CREATE INDEX ingest_interview_debug_log_created_at_idx ON public.ingest_interview_debug_log USING btree (created_at DESC);


--
-- Name: ingest_interview_debug_log_student_idx; Type: INDEX; Schema: public; Owner: supabase_admin
--

CREATE INDEX ingest_interview_debug_log_student_idx ON public.ingest_interview_debug_log USING btree (student_id, registration_period_id, created_at DESC);


--
-- Name: uniq_course_application_per_window; Type: INDEX; Schema: public; Owner: postgres
--

CREATE UNIQUE INDEX uniq_course_application_per_window ON public.course_applications USING btree (student_id, registration_period_id, window_id);


--
-- Name: uniq_one_priority_one_per_child; Type: INDEX; Schema: public; Owner: supabase_admin
--

CREATE UNIQUE INDEX uniq_one_priority_one_per_child ON public.family_member_child_links USING btree (family_id, child_profile_id) WHERE (pickup_priority = 1);


--
-- Name: unique_active_profile_code_instance; Type: INDEX; Schema: public; Owner: supabase_admin
--

CREATE UNIQUE INDEX unique_active_profile_code_instance ON public.user_codes USING btree (profile_id, code_instance) WHERE ((used_at IS NULL) AND (revoked_at IS NULL));


--
-- Name: INDEX unique_active_profile_code_instance; Type: COMMENT; Schema: public; Owner: supabase_admin
--

COMMENT ON INDEX public.unique_active_profile_code_instance IS 'Ensures only one active code per profile and instance. Allows multiple revoked/used codes. Expired codes are handled by application logic.';


--
-- Name: vwm_user_login_profiles_id_idx; Type: INDEX; Schema: public; Owner: supabase_admin
--

CREATE UNIQUE INDEX vwm_user_login_profiles_id_idx ON public.vwm_user_login_profiles USING btree (id);


--
-- Name: ix_realtime_subscription_entity; Type: INDEX; Schema: realtime; Owner: supabase_admin
--

CREATE INDEX ix_realtime_subscription_entity ON realtime.subscription USING btree (entity);


--
-- Name: subscription_subscription_id_entity_filters_key; Type: INDEX; Schema: realtime; Owner: supabase_admin
--

CREATE UNIQUE INDEX subscription_subscription_id_entity_filters_key ON realtime.subscription USING btree (subscription_id, entity, filters);


--
-- Name: bname; Type: INDEX; Schema: storage; Owner: supabase_storage_admin
--

CREATE UNIQUE INDEX bname ON storage.buckets USING btree (name);


--
-- Name: bucketid_objname; Type: INDEX; Schema: storage; Owner: supabase_storage_admin
--

CREATE UNIQUE INDEX bucketid_objname ON storage.objects USING btree (bucket_id, name);


--
-- Name: idx_multipart_uploads_list; Type: INDEX; Schema: storage; Owner: supabase_storage_admin
--

CREATE INDEX idx_multipart_uploads_list ON storage.s3_multipart_uploads USING btree (bucket_id, key, created_at);


--
-- Name: idx_name_bucket_level_unique; Type: INDEX; Schema: storage; Owner: supabase_storage_admin
--

CREATE UNIQUE INDEX idx_name_bucket_level_unique ON storage.objects USING btree (name COLLATE "C", bucket_id, level);


--
-- Name: idx_name_bucket_unique; Type: INDEX; Schema: storage; Owner: supabase_storage_admin
--

CREATE UNIQUE INDEX idx_name_bucket_unique ON storage.objects USING btree (name COLLATE "C", bucket_id);


--
-- Name: idx_objects_bucket_id_name; Type: INDEX; Schema: storage; Owner: supabase_storage_admin
--

CREATE INDEX idx_objects_bucket_id_name ON storage.objects USING btree (bucket_id, name COLLATE "C");


--
-- Name: idx_objects_lower_name; Type: INDEX; Schema: storage; Owner: supabase_storage_admin
--

CREATE INDEX idx_objects_lower_name ON storage.objects USING btree ((path_tokens[level]), lower(name) text_pattern_ops, bucket_id, level);


--
-- Name: idx_prefixes_lower_name; Type: INDEX; Schema: storage; Owner: supabase_storage_admin
--

CREATE INDEX idx_prefixes_lower_name ON storage.prefixes USING btree (bucket_id, level, ((string_to_array(name, '/'::text))[level]), lower(name) text_pattern_ops);


--
-- Name: name_prefix_search; Type: INDEX; Schema: storage; Owner: supabase_storage_admin
--

CREATE INDEX name_prefix_search ON storage.objects USING btree (name text_pattern_ops);


--
-- Name: objects_bucket_id_level_idx; Type: INDEX; Schema: storage; Owner: supabase_storage_admin
--

CREATE UNIQUE INDEX objects_bucket_id_level_idx ON storage.objects USING btree (bucket_id, level, name COLLATE "C");


--
-- Name: supabase_functions_hooks_h_table_id_h_name_idx; Type: INDEX; Schema: supabase_functions; Owner: supabase_functions_admin
--

CREATE INDEX supabase_functions_hooks_h_table_id_h_name_idx ON supabase_functions.hooks USING btree (hook_table_id, hook_name);


--
-- Name: supabase_functions_hooks_request_id_idx; Type: INDEX; Schema: supabase_functions; Owner: supabase_functions_admin
--

CREATE INDEX supabase_functions_hooks_request_id_idx ON supabase_functions.hooks USING btree (request_id);


--
-- Name: messages_2025_08_25_pkey; Type: INDEX ATTACH; Schema: realtime; Owner: supabase_realtime_admin
--

ALTER INDEX realtime.messages_pkey ATTACH PARTITION realtime.messages_2025_08_25_pkey;


--
-- Name: messages_2025_08_26_pkey; Type: INDEX ATTACH; Schema: realtime; Owner: supabase_realtime_admin
--

ALTER INDEX realtime.messages_pkey ATTACH PARTITION realtime.messages_2025_08_26_pkey;


--
-- Name: messages_2025_08_27_pkey; Type: INDEX ATTACH; Schema: realtime; Owner: supabase_realtime_admin
--

ALTER INDEX realtime.messages_pkey ATTACH PARTITION realtime.messages_2025_08_27_pkey;


--
-- Name: messages_2025_08_28_pkey; Type: INDEX ATTACH; Schema: realtime; Owner: supabase_realtime_admin
--

ALTER INDEX realtime.messages_pkey ATTACH PARTITION realtime.messages_2025_08_28_pkey;


--
-- Name: messages_2025_08_29_pkey; Type: INDEX ATTACH; Schema: realtime; Owner: supabase_realtime_admin
--

ALTER INDEX realtime.messages_pkey ATTACH PARTITION realtime.messages_2025_08_29_pkey;


--
-- Name: messages_2025_08_30_pkey; Type: INDEX ATTACH; Schema: realtime; Owner: supabase_realtime_admin
--

ALTER INDEX realtime.messages_pkey ATTACH PARTITION realtime.messages_2025_08_30_pkey;


--
-- Name: messages_2025_08_31_pkey; Type: INDEX ATTACH; Schema: realtime; Owner: supabase_realtime_admin
--

ALTER INDEX realtime.messages_pkey ATTACH PARTITION realtime.messages_2025_08_31_pkey;


--
-- Name: vw_subjects_with_grade_and_class_hours _RETURN; Type: RULE; Schema: public; Owner: supabase_admin
--

CREATE OR REPLACE VIEW public.vw_subjects_with_grade_and_class_hours WITH (security_invoker='true') AS
 SELECT s.id AS subject_id,
    s.name AS subject_name,
    s.abbreviation,
    s.icon,
    s.color,
    s.subject_type,
    s.school_id,
    COALESCE(json_agg(jsonb_build_object('id', g.id, 'grade_level', g.grade_level, 'hours_per_week', g.hours_per_week, 'class_overrides', COALESCE(( SELECT json_agg(jsonb_build_object('id', c.id, 'class_id', c.class_id, 'class_name', sc.name, 'hours_per_week', c.hours_per_week) ORDER BY sc.name) AS json_agg
           FROM (public.subject_class_hours c
             LEFT JOIN public.structure_classes sc ON ((sc.id = c.class_id)))
          WHERE ((c.subject_id = s.id) AND ((sc.grade_level)::text = g.grade_level))), '[]'::json)) ORDER BY g.grade_level) FILTER (WHERE (g.id IS NOT NULL)), '[]'::json) AS grade_hours
   FROM (public.subjects s
     LEFT JOIN public.subject_grade_hours g ON ((g.subject_id = s.id)))
  GROUP BY s.id;


--
-- Name: vw_lesson_view_enriched _RETURN; Type: RULE; Schema: public; Owner: supabase_admin
--

CREATE OR REPLACE VIEW public.vw_lesson_view_enriched WITH (security_invoker='true') AS
 SELECT l.id AS lesson_id,
    l.course_id,
    c.name AS course_name,
    s.id AS subject_id,
    s.name AS subject_name,
    sc.id AS class_id,
    sc.name AS class_name,
    l.start_datetime,
    l.end_datetime,
    l.teacher_ids,
    array_agg(DISTINCT concat_ws(' '::text, t.first_name, t.last_name)) AS teacher_names,
        CASE
            WHEN ((cs.teacher_ids IS NOT NULL) AND (l.teacher_ids <> cs.teacher_ids)) THEN true
            ELSE false
        END AS substitute_detected,
    r.name AS room_name,
    array_agg(DISTINCT sp.label) AS period_names,
    count(DISTINCT COALESCE(e.student_id, pis_class.profile_id)) AS student_count,
    array_agg(DISTINCT concat_ws(' '::text, COALESCE(up_course.first_name, up_class.first_name), COALESCE(up_course.last_name, up_class.last_name), '(', COALESCE(sc2.name, sc.name), ')')) AS student_names_with_class,
    count(DISTINCT al.id) FILTER (WHERE (al.status = 'present'::public.attendance_status)) AS attendance_present_count,
        CASE
            WHEN (count(DISTINCT COALESCE(e.student_id, pis_class.profile_id)) = 0) THEN (0)::numeric
            ELSE round(((100.0 * (count(DISTINCT al.id) FILTER (WHERE (al.status = 'present'::public.attendance_status)))::numeric) / (count(DISTINCT COALESCE(e.student_id, pis_class.profile_id)))::numeric), 1)
        END AS attendance_percent,
    array_remove(ARRAY[
        CASE
            WHEN (l.room_id IS NULL) THEN 'no_room_assigned'::text
            ELSE NULL::text
        END,
        CASE
            WHEN (array_length(l.teacher_ids, 1) = 0) THEN 'no_teacher_assigned'::text
            ELSE NULL::text
        END,
        CASE
            WHEN (count(DISTINCT COALESCE(e.student_id, pis_class.profile_id)) = 0) THEN 'no_students_enrolled'::text
            ELSE NULL::text
        END], NULL::text) AS warnings,
        CASE
            WHEN (l.course_id IS NULL) THEN 'lesson'::text
            ELSE 'course'::text
        END AS is_type
   FROM (((((((((((((((public.course_lessons l
     LEFT JOIN public.course_list c ON ((c.id = l.course_id)))
     LEFT JOIN public.subjects s ON ((s.id = COALESCE(l.subject_id, c.subject_id))))
     LEFT JOIN public.structure_classes sc ON ((sc.id = l.class_id)))
     LEFT JOIN public.profile_info_staff pis ON ((pis.profile_id = ANY (l.teacher_ids))))
     LEFT JOIN public.user_profiles t ON ((t.id = pis.profile_id)))
     LEFT JOIN public.course_schedules cs ON ((cs.id = l.schedule_id)))
     LEFT JOIN public.structure_rooms r ON ((r.id = l.room_id)))
     LEFT JOIN public.schedule_periods sp ON ((sp.id = ANY (l.period_ids))))
     LEFT JOIN public.course_enrollments e ON ((e.course_id = l.course_id)))
     LEFT JOIN public.profile_info_student pis2 ON ((pis2.profile_id = e.student_id)))
     LEFT JOIN public.structure_classes sc2 ON ((sc2.id = pis2.class_id)))
     LEFT JOIN public.user_profiles up_course ON ((up_course.id = e.student_id)))
     LEFT JOIN public.profile_info_student pis_class ON (((pis_class.class_id = l.class_id) AND (l.course_id IS NULL))))
     LEFT JOIN public.user_profiles up_class ON ((up_class.id = pis_class.profile_id)))
     LEFT JOIN public.student_attendance_logs al ON (((al.lesson_id = l.id) AND ((al.student_id = e.student_id) OR (al.student_id = pis_class.profile_id)) AND (al.status = 'present'::public.attendance_status))))
  GROUP BY l.id, c.name, s.id, s.name, sc.id, sc.name, l.start_datetime, l.end_datetime, l.teacher_ids, cs.teacher_ids, r.name;


--
-- Name: vw_lesson_attendance_badges _RETURN; Type: RULE; Schema: public; Owner: authenticated
--

CREATE OR REPLACE VIEW public.vw_lesson_attendance_badges WITH (security_invoker='true') AS
 SELECT cl.id AS lesson_id,
    count(DISTINCT COALESCE(ce.student_id, pis_class.profile_id)) AS total_students,
    ( SELECT count(*) AS count
           FROM public.student_attendance_logs sal
          WHERE ((sal.lesson_id = cl.id) AND (sal.status = 'present'::public.attendance_status))) AS present_count,
    ( SELECT count(*) AS count
           FROM public.student_attendance_logs sal
          WHERE ((sal.lesson_id = cl.id) AND (sal.status = 'late'::public.attendance_status))) AS late_count,
    ( SELECT count(*) AS count
           FROM public.student_attendance_logs sal
          WHERE ((sal.lesson_id = cl.id) AND ((sal.status = 'absent_excused'::public.attendance_status) OR (sal.status = 'absent_unexcused'::public.attendance_status)))) AS absent_count,
        CASE
            WHEN (( SELECT count(*) AS count
               FROM public.student_attendance_logs sal
              WHERE (sal.lesson_id = cl.id)) = 0) THEN 'none'::text
            WHEN (( SELECT count(*) AS count
               FROM public.student_attendance_logs sal
              WHERE (sal.lesson_id = cl.id)) = count(DISTINCT COALESCE(ce.student_id, pis_class.profile_id))) THEN 'complete'::text
            ELSE 'incomplete'::text
        END AS attendance_status
   FROM ((public.course_lessons cl
     LEFT JOIN public.course_enrollments ce ON (((ce.course_id = cl.course_id) AND ((cl.start_datetime)::date >= ce.start_date) AND ((cl.start_datetime)::date <= ce.end_date))))
     LEFT JOIN public.profile_info_student pis_class ON (((pis_class.class_id = cl.class_id) AND (cl.course_id IS NULL))))
  WHERE (cl.is_archived = false)
  GROUP BY cl.id
  ORDER BY cl.start_datetime DESC;


--
-- Name: course_possible_times set_school_id; Type: TRIGGER; Schema: public; Owner: supabase_admin
--

CREATE TRIGGER set_school_id BEFORE INSERT OR UPDATE ON public.course_possible_times FOR EACH ROW EXECUTE FUNCTION public.trg_set_school_on_possible_times();


--
-- Name: course_allocation_drafts trg_cad_set_updated_at; Type: TRIGGER; Schema: public; Owner: supabase_admin
--

CREATE TRIGGER trg_cad_set_updated_at BEFORE UPDATE ON public.course_allocation_drafts FOR EACH ROW EXECUTE FUNCTION public.cad_set_updated_at();


--
-- Name: course_schedules trg_course_schedules_updated_at; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_course_schedules_updated_at BEFORE UPDATE ON public.course_schedules FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- Name: bulletin_posts trg_log_bulletin_posts; Type: TRIGGER; Schema: public; Owner: supabase_admin
--

CREATE TRIGGER trg_log_bulletin_posts AFTER INSERT OR DELETE OR UPDATE ON public.bulletin_posts FOR EACH ROW EXECUTE FUNCTION public.log_change_generic();

ALTER TABLE public.bulletin_posts DISABLE TRIGGER trg_log_bulletin_posts;


--
-- Name: course_applications trg_log_course_applications; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_log_course_applications AFTER INSERT OR DELETE OR UPDATE ON public.course_applications FOR EACH ROW EXECUTE FUNCTION public.log_change_generic();

ALTER TABLE public.course_applications DISABLE TRIGGER trg_log_course_applications;


--
-- Name: course_enrollments trg_log_course_enrollments; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_log_course_enrollments AFTER INSERT OR DELETE OR UPDATE ON public.course_enrollments FOR EACH ROW EXECUTE FUNCTION public.log_change_generic();

ALTER TABLE public.course_enrollments DISABLE TRIGGER trg_log_course_enrollments;


--
-- Name: course_list trg_log_course_list; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_log_course_list AFTER INSERT OR DELETE OR UPDATE ON public.course_list FOR EACH ROW EXECUTE FUNCTION public.log_change_generic();

ALTER TABLE public.course_list DISABLE TRIGGER trg_log_course_list;


--
-- Name: course_possible_times trg_log_course_possible_times; Type: TRIGGER; Schema: public; Owner: supabase_admin
--

CREATE TRIGGER trg_log_course_possible_times AFTER INSERT OR DELETE OR UPDATE ON public.course_possible_times FOR EACH ROW EXECUTE FUNCTION public.log_change_generic();

ALTER TABLE public.course_possible_times DISABLE TRIGGER trg_log_course_possible_times;


--
-- Name: course_registration_windows trg_log_course_registration_windows; Type: TRIGGER; Schema: public; Owner: supabase_admin
--

CREATE TRIGGER trg_log_course_registration_windows AFTER INSERT OR DELETE OR UPDATE ON public.course_registration_windows FOR EACH ROW EXECUTE FUNCTION public.log_change_generic();

ALTER TABLE public.course_registration_windows DISABLE TRIGGER trg_log_course_registration_windows;


--
-- Name: registration_periods trg_log_registration_periods; Type: TRIGGER; Schema: public; Owner: supabase_admin
--

CREATE TRIGGER trg_log_registration_periods AFTER INSERT OR DELETE OR UPDATE ON public.registration_periods FOR EACH ROW EXECUTE FUNCTION public.log_change_generic();

ALTER TABLE public.registration_periods DISABLE TRIGGER trg_log_registration_periods;


--
-- Name: schedule_periods trg_log_schedule_periods; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_log_schedule_periods AFTER INSERT OR DELETE OR UPDATE ON public.schedule_periods FOR EACH ROW EXECUTE FUNCTION public.log_change_generic();

ALTER TABLE public.schedule_periods DISABLE TRIGGER trg_log_schedule_periods;


--
-- Name: staff_absences trg_log_staff_absences; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_log_staff_absences AFTER INSERT OR DELETE OR UPDATE ON public.staff_absences FOR EACH ROW EXECUTE FUNCTION public.log_change_generic();

ALTER TABLE public.staff_absences DISABLE TRIGGER trg_log_staff_absences;


--
-- Name: roles trg_protect_role_deletion; Type: TRIGGER; Schema: public; Owner: supabase_admin
--

CREATE TRIGGER trg_protect_role_deletion BEFORE DELETE ON public.roles FOR EACH ROW EXECUTE FUNCTION public.protect_role_deletion();


--
-- Name: roles trg_protect_role_modification; Type: TRIGGER; Schema: public; Owner: supabase_admin
--

CREATE TRIGGER trg_protect_role_modification BEFORE UPDATE ON public.roles FOR EACH ROW EXECUTE FUNCTION public.protect_role_modification();


--
-- Name: course_list trg_set_updated_at_course_list; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trg_set_updated_at_course_list BEFORE UPDATE ON public.course_list FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();

ALTER TABLE public.course_list DISABLE TRIGGER trg_set_updated_at_course_list;


--
-- Name: registration_periods trg_set_updated_at_registration_periods; Type: TRIGGER; Schema: public; Owner: supabase_admin
--

CREATE TRIGGER trg_set_updated_at_registration_periods BEFORE UPDATE ON public.registration_periods FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();


--
-- Name: registration_periods trg_update_registration_periods_updated_at; Type: TRIGGER; Schema: public; Owner: supabase_admin
--

CREATE TRIGGER trg_update_registration_periods_updated_at BEFORE UPDATE ON public.registration_periods FOR EACH ROW EXECUTE FUNCTION public.update_registration_periods_updated_at();


--
-- Name: user_roles trigger_add_user_to_group; Type: TRIGGER; Schema: public; Owner: supabase_admin
--

CREATE TRIGGER trigger_add_user_to_group AFTER INSERT ON public.user_roles FOR EACH ROW EXECUTE FUNCTION public.add_user_to_group_alt();


--
-- Name: user_roles trigger_refresh_user_login_profiles_delete; Type: TRIGGER; Schema: public; Owner: supabase_admin
--

CREATE TRIGGER trigger_refresh_user_login_profiles_delete AFTER DELETE ON public.user_roles FOR EACH STATEMENT EXECUTE FUNCTION public.refresh_user_login_profiles();


--
-- Name: user_profiles trigger_refresh_user_login_profiles_profiles_update; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER trigger_refresh_user_login_profiles_profiles_update AFTER UPDATE OF role_id ON public.user_profiles FOR EACH STATEMENT EXECUTE FUNCTION public.refresh_user_login_profiles();


--
-- Name: roles trigger_refresh_user_login_profiles_roles_update; Type: TRIGGER; Schema: public; Owner: supabase_admin
--

CREATE TRIGGER trigger_refresh_user_login_profiles_roles_update AFTER UPDATE OF name, is_subrole ON public.roles FOR EACH STATEMENT EXECUTE FUNCTION public.refresh_user_login_profiles();


--
-- Name: user_roles trigger_refresh_user_login_profiles_update; Type: TRIGGER; Schema: public; Owner: supabase_admin
--

CREATE TRIGGER trigger_refresh_user_login_profiles_update AFTER UPDATE ON public.user_roles FOR EACH STATEMENT EXECUTE FUNCTION public.refresh_user_login_profiles();


--
-- Name: user_roles trigger_remove_user_from_group; Type: TRIGGER; Schema: public; Owner: supabase_admin
--

CREATE TRIGGER trigger_remove_user_from_group AFTER DELETE ON public.user_roles FOR EACH ROW EXECUTE FUNCTION public.remove_user_from_group();


--
-- Name: subscription tr_check_filters; Type: TRIGGER; Schema: realtime; Owner: supabase_admin
--

CREATE TRIGGER tr_check_filters BEFORE INSERT OR UPDATE ON realtime.subscription FOR EACH ROW EXECUTE FUNCTION realtime.subscription_check_filters();


--
-- Name: objects objects_delete_delete_prefix; Type: TRIGGER; Schema: storage; Owner: supabase_storage_admin
--

CREATE TRIGGER objects_delete_delete_prefix AFTER DELETE ON storage.objects FOR EACH ROW EXECUTE FUNCTION storage.delete_prefix_hierarchy_trigger();


--
-- Name: objects objects_insert_create_prefix; Type: TRIGGER; Schema: storage; Owner: supabase_storage_admin
--

CREATE TRIGGER objects_insert_create_prefix BEFORE INSERT ON storage.objects FOR EACH ROW EXECUTE FUNCTION storage.objects_insert_prefix_trigger();


--
-- Name: objects objects_update_create_prefix; Type: TRIGGER; Schema: storage; Owner: supabase_storage_admin
--

CREATE TRIGGER objects_update_create_prefix BEFORE UPDATE ON storage.objects FOR EACH ROW WHEN (((new.name <> old.name) OR (new.bucket_id <> old.bucket_id))) EXECUTE FUNCTION storage.objects_update_prefix_trigger();


--
-- Name: prefixes prefixes_create_hierarchy; Type: TRIGGER; Schema: storage; Owner: supabase_storage_admin
--

CREATE TRIGGER prefixes_create_hierarchy BEFORE INSERT ON storage.prefixes FOR EACH ROW WHEN ((pg_trigger_depth() < 1)) EXECUTE FUNCTION storage.prefixes_insert_trigger();


--
-- Name: prefixes prefixes_delete_hierarchy; Type: TRIGGER; Schema: storage; Owner: supabase_storage_admin
--

CREATE TRIGGER prefixes_delete_hierarchy AFTER DELETE ON storage.prefixes FOR EACH ROW EXECUTE FUNCTION storage.delete_prefix_hierarchy_trigger();


--
-- Name: objects update_objects_updated_at; Type: TRIGGER; Schema: storage; Owner: supabase_storage_admin
--

CREATE TRIGGER update_objects_updated_at BEFORE UPDATE ON storage.objects FOR EACH ROW EXECUTE FUNCTION storage.update_updated_at_column();


--
-- Name: extensions extensions_tenant_external_id_fkey; Type: FK CONSTRAINT; Schema: _realtime; Owner: supabase_admin
--

ALTER TABLE ONLY _realtime.extensions
    ADD CONSTRAINT extensions_tenant_external_id_fkey FOREIGN KEY (tenant_external_id) REFERENCES _realtime.tenants(external_id) ON DELETE CASCADE;


--
-- Name: identities identities_user_id_fkey; Type: FK CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.identities
    ADD CONSTRAINT identities_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;


--
-- Name: mfa_amr_claims mfa_amr_claims_session_id_fkey; Type: FK CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.mfa_amr_claims
    ADD CONSTRAINT mfa_amr_claims_session_id_fkey FOREIGN KEY (session_id) REFERENCES auth.sessions(id) ON DELETE CASCADE;


--
-- Name: mfa_challenges mfa_challenges_auth_factor_id_fkey; Type: FK CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.mfa_challenges
    ADD CONSTRAINT mfa_challenges_auth_factor_id_fkey FOREIGN KEY (factor_id) REFERENCES auth.mfa_factors(id) ON DELETE CASCADE;


--
-- Name: mfa_factors mfa_factors_user_id_fkey; Type: FK CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.mfa_factors
    ADD CONSTRAINT mfa_factors_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;


--
-- Name: one_time_tokens one_time_tokens_user_id_fkey; Type: FK CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.one_time_tokens
    ADD CONSTRAINT one_time_tokens_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;


--
-- Name: refresh_tokens refresh_tokens_session_id_fkey; Type: FK CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.refresh_tokens
    ADD CONSTRAINT refresh_tokens_session_id_fkey FOREIGN KEY (session_id) REFERENCES auth.sessions(id) ON DELETE CASCADE;


--
-- Name: saml_providers saml_providers_sso_provider_id_fkey; Type: FK CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.saml_providers
    ADD CONSTRAINT saml_providers_sso_provider_id_fkey FOREIGN KEY (sso_provider_id) REFERENCES auth.sso_providers(id) ON DELETE CASCADE;


--
-- Name: saml_relay_states saml_relay_states_flow_state_id_fkey; Type: FK CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.saml_relay_states
    ADD CONSTRAINT saml_relay_states_flow_state_id_fkey FOREIGN KEY (flow_state_id) REFERENCES auth.flow_state(id) ON DELETE CASCADE;


--
-- Name: saml_relay_states saml_relay_states_sso_provider_id_fkey; Type: FK CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.saml_relay_states
    ADD CONSTRAINT saml_relay_states_sso_provider_id_fkey FOREIGN KEY (sso_provider_id) REFERENCES auth.sso_providers(id) ON DELETE CASCADE;


--
-- Name: sessions sessions_user_id_fkey; Type: FK CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.sessions
    ADD CONSTRAINT sessions_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;


--
-- Name: sso_domains sso_domains_sso_provider_id_fkey; Type: FK CONSTRAINT; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE ONLY auth.sso_domains
    ADD CONSTRAINT sso_domains_sso_provider_id_fkey FOREIGN KEY (sso_provider_id) REFERENCES auth.sso_providers(id) ON DELETE CASCADE;


--
-- Name: course_applications applications_course_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.course_applications
    ADD CONSTRAINT applications_course_id_fkey FOREIGN KEY (course_id) REFERENCES public.course_list(id) ON DELETE CASCADE;


--
-- Name: course_applications applications_student_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.course_applications
    ADD CONSTRAINT applications_student_id_fkey FOREIGN KEY (student_id) REFERENCES public.user_profiles(id) ON DELETE CASCADE;


--
-- Name: course_enrollments assignments_course_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.course_enrollments
    ADD CONSTRAINT assignments_course_id_fkey FOREIGN KEY (course_id) REFERENCES public.course_list(id) ON DELETE CASCADE;


--
-- Name: course_enrollments assignments_student_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.course_enrollments
    ADD CONSTRAINT assignments_student_id_fkey FOREIGN KEY (student_id) REFERENCES public.user_profiles(id) ON DELETE CASCADE;


--
-- Name: bulletin_post_users bulletin_post_users_post_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.bulletin_post_users
    ADD CONSTRAINT bulletin_post_users_post_id_fkey FOREIGN KEY (post_id) REFERENCES public.bulletin_posts(id) ON DELETE CASCADE;


--
-- Name: bulletin_post_users bulletin_post_users_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.bulletin_post_users
    ADD CONSTRAINT bulletin_post_users_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.user_profiles(id) ON DELETE CASCADE;


--
-- Name: bulletin_posts bulletin_posts_created_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.bulletin_posts
    ADD CONSTRAINT bulletin_posts_created_by_fkey FOREIGN KEY (created_by) REFERENCES public.user_profiles(id) ON DELETE SET NULL;


--
-- Name: bulletin_posts bulletin_posts_school_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.bulletin_posts
    ADD CONSTRAINT bulletin_posts_school_id_fkey FOREIGN KEY (school_id) REFERENCES public.structure_schools(id) ON DELETE CASCADE;


--
-- Name: bulletin_recurrences bulletin_recurrences_original_post_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.bulletin_recurrences
    ADD CONSTRAINT bulletin_recurrences_original_post_id_fkey FOREIGN KEY (original_post_id) REFERENCES public.bulletin_posts(id) ON DELETE CASCADE;


--
-- Name: schedule_calendar_exceptions calendar_exceptions_school_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.schedule_calendar_exceptions
    ADD CONSTRAINT calendar_exceptions_school_id_fkey FOREIGN KEY (school_id) REFERENCES public.structure_schools(id) ON DELETE CASCADE;


--
-- Name: change_log change_log_school_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.change_log
    ADD CONSTRAINT change_log_school_id_fkey FOREIGN KEY (school_id) REFERENCES public.structure_schools(id) ON DELETE SET NULL;


--
-- Name: change_log change_log_undone_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.change_log
    ADD CONSTRAINT change_log_undone_by_fkey FOREIGN KEY (undone_by) REFERENCES auth.users(id);


--
-- Name: change_log change_log_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.change_log
    ADD CONSTRAINT change_log_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;


--
-- Name: structure_classes classes_room_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.structure_classes
    ADD CONSTRAINT classes_room_id_fkey FOREIGN KEY (room_id) REFERENCES public.structure_rooms(id) ON DELETE SET NULL;


--
-- Name: structure_classes classes_school_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.structure_classes
    ADD CONSTRAINT classes_school_id_fkey FOREIGN KEY (school_id) REFERENCES public.structure_schools(id) ON DELETE CASCADE;


--
-- Name: structure_classes classes_teacher_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.structure_classes
    ADD CONSTRAINT classes_teacher_id_fkey FOREIGN KEY (teacher_id) REFERENCES public.user_profiles(id);


--
-- Name: contacts contacts_profile_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.contacts
    ADD CONSTRAINT contacts_profile_id_fkey FOREIGN KEY (profile_id) REFERENCES public.user_profiles(id) ON DELETE CASCADE;


--
-- Name: course_applications course_applications_registration_period_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.course_applications
    ADD CONSTRAINT course_applications_registration_period_id_fkey FOREIGN KEY (registration_period_id) REFERENCES public.registration_periods(id) ON DELETE CASCADE;


--
-- Name: course_applications course_applications_school_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.course_applications
    ADD CONSTRAINT course_applications_school_id_fkey FOREIGN KEY (school_id) REFERENCES public.structure_schools(id);


--
-- Name: course_applications course_applications_semester_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.course_applications
    ADD CONSTRAINT course_applications_semester_id_fkey FOREIGN KEY (semester_id) REFERENCES public.structure_school_semesters(id) ON DELETE CASCADE;


--
-- Name: course_applications course_applications_window_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.course_applications
    ADD CONSTRAINT course_applications_window_id_fkey FOREIGN KEY (window_id) REFERENCES public.course_registration_windows(id) ON DELETE CASCADE;


--
-- Name: course_enrollments course_enrollments_school_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.course_enrollments
    ADD CONSTRAINT course_enrollments_school_id_fkey FOREIGN KEY (school_id) REFERENCES public.structure_schools(id);


--
-- Name: course_lessons course_lessons_class_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.course_lessons
    ADD CONSTRAINT course_lessons_class_id_fkey FOREIGN KEY (class_id) REFERENCES public.structure_classes(id);


--
-- Name: course_lessons course_lessons_primary_teacher_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.course_lessons
    ADD CONSTRAINT course_lessons_primary_teacher_id_fkey FOREIGN KEY (primary_teacher_id) REFERENCES public.user_profiles(id) ON DELETE SET NULL;


--
-- Name: course_lessons course_lessons_replaced_by_lesson_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.course_lessons
    ADD CONSTRAINT course_lessons_replaced_by_lesson_id_fkey FOREIGN KEY (replaced_by_lesson_id) REFERENCES public.course_lessons(id);


--
-- Name: course_lessons course_lessons_replacing_lesson_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.course_lessons
    ADD CONSTRAINT course_lessons_replacing_lesson_id_fkey FOREIGN KEY (replacing_lesson_id) REFERENCES public.course_lessons(id);


--
-- Name: course_lessons course_lessons_room_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.course_lessons
    ADD CONSTRAINT course_lessons_room_id_fkey FOREIGN KEY (room_id) REFERENCES public.structure_rooms(id);


--
-- Name: course_lessons course_lessons_schedule_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.course_lessons
    ADD CONSTRAINT course_lessons_schedule_id_fkey FOREIGN KEY (schedule_id) REFERENCES public.course_schedules(id) ON DELETE CASCADE;


--
-- Name: course_lessons course_lessons_subject_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.course_lessons
    ADD CONSTRAINT course_lessons_subject_id_fkey FOREIGN KEY (subject_id) REFERENCES public.subjects(id);


--
-- Name: course_list course_list_possible_room_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.course_list
    ADD CONSTRAINT course_list_possible_room_id_fkey FOREIGN KEY (possible_room_id) REFERENCES public.structure_rooms(id) ON DELETE SET NULL;


--
-- Name: course_list course_list_subject_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.course_list
    ADD CONSTRAINT course_list_subject_id_fkey FOREIGN KEY (subject_id) REFERENCES public.subjects(id) ON DELETE SET NULL;


--
-- Name: course_possible_times course_possible_times_course_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.course_possible_times
    ADD CONSTRAINT course_possible_times_course_id_fkey FOREIGN KEY (course_id) REFERENCES public.course_list(id) ON DELETE CASCADE;


--
-- Name: course_possible_times course_possible_times_created_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.course_possible_times
    ADD CONSTRAINT course_possible_times_created_by_fkey FOREIGN KEY (created_by) REFERENCES public.user_profiles(id);


--
-- Name: course_possible_times course_possible_times_schedule_period_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.course_possible_times
    ADD CONSTRAINT course_possible_times_schedule_period_id_fkey FOREIGN KEY (schedule_period_id) REFERENCES public.schedule_periods(id) ON DELETE CASCADE;


--
-- Name: course_registration_windows course_registration_windows_course_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.course_registration_windows
    ADD CONSTRAINT course_registration_windows_course_id_fkey FOREIGN KEY (course_id) REFERENCES public.course_list(id) ON DELETE CASCADE;


--
-- Name: course_registration_windows course_registration_windows_created_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.course_registration_windows
    ADD CONSTRAINT course_registration_windows_created_by_fkey FOREIGN KEY (created_by) REFERENCES public.user_profiles(id) ON DELETE RESTRICT;


--
-- Name: course_registration_windows course_registration_windows_registration_period_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.course_registration_windows
    ADD CONSTRAINT course_registration_windows_registration_period_id_fkey FOREIGN KEY (registration_period_id) REFERENCES public.registration_periods(id) ON DELETE CASCADE;


--
-- Name: course_registration_windows course_registration_windows_school_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.course_registration_windows
    ADD CONSTRAINT course_registration_windows_school_id_fkey FOREIGN KEY (school_id) REFERENCES public.structure_schools(id) ON DELETE CASCADE;


--
-- Name: course_registration_windows course_registration_windows_semester_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.course_registration_windows
    ADD CONSTRAINT course_registration_windows_semester_id_fkey FOREIGN KEY (semester_id) REFERENCES public.structure_school_semesters(id) ON DELETE CASCADE;


--
-- Name: course_schedules course_schedules_class_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.course_schedules
    ADD CONSTRAINT course_schedules_class_id_fkey FOREIGN KEY (class_id) REFERENCES public.structure_classes(id);


--
-- Name: course_schedules course_schedules_course_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.course_schedules
    ADD CONSTRAINT course_schedules_course_id_fkey FOREIGN KEY (course_id) REFERENCES public.course_list(id) ON DELETE CASCADE;


--
-- Name: course_schedules course_schedules_day_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.course_schedules
    ADD CONSTRAINT course_schedules_day_id_fkey FOREIGN KEY (day_id) REFERENCES public.structure_days(id) ON DELETE RESTRICT;


--
-- Name: course_schedules course_schedules_primary_teacher_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.course_schedules
    ADD CONSTRAINT course_schedules_primary_teacher_id_fkey FOREIGN KEY (primary_teacher_id) REFERENCES public.user_profiles(id) ON DELETE SET NULL;


--
-- Name: course_schedules course_schedules_room_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.course_schedules
    ADD CONSTRAINT course_schedules_room_id_fkey FOREIGN KEY (room_id) REFERENCES public.structure_rooms(id);


--
-- Name: course_schedules course_schedules_school_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.course_schedules
    ADD CONSTRAINT course_schedules_school_id_fkey FOREIGN KEY (school_id) REFERENCES public.structure_schools(id);


--
-- Name: course_schedules course_schedules_subject_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.course_schedules
    ADD CONSTRAINT course_schedules_subject_id_fkey FOREIGN KEY (subject_id) REFERENCES public.subjects(id);


--
-- Name: course_lessons course_sessions_course_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.course_lessons
    ADD CONSTRAINT course_sessions_course_id_fkey FOREIGN KEY (course_id) REFERENCES public.course_list(id) ON DELETE CASCADE;


--
-- Name: course_lessons course_sessions_school_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.course_lessons
    ADD CONSTRAINT course_sessions_school_id_fkey FOREIGN KEY (school_id) REFERENCES public.structure_schools(id);


--
-- Name: course_list courses_school_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.course_list
    ADD CONSTRAINT courses_school_id_fkey FOREIGN KEY (school_id) REFERENCES public.structure_schools(id) ON DELETE CASCADE;


--
-- Name: schedule_daily_rostering daily_assignments_course_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.schedule_daily_rostering
    ADD CONSTRAINT daily_assignments_course_id_fkey FOREIGN KEY (course_id) REFERENCES public.course_list(id) ON DELETE SET NULL;


--
-- Name: schedule_daily_rostering daily_assignments_room_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.schedule_daily_rostering
    ADD CONSTRAINT daily_assignments_room_id_fkey FOREIGN KEY (room_id) REFERENCES public.structure_rooms(id);


--
-- Name: schedule_daily_rostering daily_assignments_school_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.schedule_daily_rostering
    ADD CONSTRAINT daily_assignments_school_id_fkey FOREIGN KEY (school_id) REFERENCES public.structure_schools(id) ON DELETE CASCADE;


--
-- Name: schedule_daily_rostering daily_assignments_staff_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.schedule_daily_rostering
    ADD CONSTRAINT daily_assignments_staff_id_fkey FOREIGN KEY (staff_id) REFERENCES public.user_profiles(id) ON DELETE CASCADE;


--
-- Name: schedule_daily_rostering daily_assignments_substitute_for_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.schedule_daily_rostering
    ADD CONSTRAINT daily_assignments_substitute_for_fkey FOREIGN KEY (substitute_for) REFERENCES public.user_profiles(id);


--
-- Name: schedule_daily_rostering daily_assignments_time_block_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.schedule_daily_rostering
    ADD CONSTRAINT daily_assignments_time_block_id_fkey FOREIGN KEY (time_block_id) REFERENCES public.schedule_periods(id);


--
-- Name: families families_created_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.families
    ADD CONSTRAINT families_created_by_fkey FOREIGN KEY (created_by) REFERENCES public.user_profiles(id) ON DELETE SET NULL;


--
-- Name: families families_school_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.families
    ADD CONSTRAINT families_school_id_fkey FOREIGN KEY (school_id) REFERENCES public.structure_schools(id) ON DELETE CASCADE;


--
-- Name: families families_updated_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.families
    ADD CONSTRAINT families_updated_by_fkey FOREIGN KEY (updated_by) REFERENCES public.user_profiles(id) ON DELETE SET NULL;


--
-- Name: family_member_child_links family_member_child_links_adult_profile_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.family_member_child_links
    ADD CONSTRAINT family_member_child_links_adult_profile_id_fkey FOREIGN KEY (adult_profile_id) REFERENCES public.user_profiles(id) ON DELETE CASCADE;


--
-- Name: family_member_child_links family_member_child_links_child_profile_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.family_member_child_links
    ADD CONSTRAINT family_member_child_links_child_profile_id_fkey FOREIGN KEY (child_profile_id) REFERENCES public.user_profiles(id) ON DELETE CASCADE;


--
-- Name: family_member_child_links family_member_child_links_family_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.family_member_child_links
    ADD CONSTRAINT family_member_child_links_family_id_fkey FOREIGN KEY (family_id) REFERENCES public.families(id) ON DELETE CASCADE;


--
-- Name: family_members family_members_added_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.family_members
    ADD CONSTRAINT family_members_added_by_fkey FOREIGN KEY (added_by) REFERENCES public.user_profiles(id) ON DELETE SET NULL;


--
-- Name: family_members family_members_family_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.family_members
    ADD CONSTRAINT family_members_family_id_fkey FOREIGN KEY (family_id) REFERENCES public.families(id) ON DELETE CASCADE;


--
-- Name: family_members family_members_profile_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.family_members
    ADD CONSTRAINT family_members_profile_id_fkey FOREIGN KEY (profile_id) REFERENCES public.user_profiles(id) ON DELETE CASCADE;


--
-- Name: family_members family_members_removed_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.family_members
    ADD CONSTRAINT family_members_removed_by_fkey FOREIGN KEY (removed_by) REFERENCES public.user_profiles(id);


--
-- Name: course_lessons fk_course_lessons_period; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.course_lessons
    ADD CONSTRAINT fk_course_lessons_period FOREIGN KEY (period_id) REFERENCES public.schedule_periods(id) ON DELETE SET NULL;


--
-- Name: course_offers fk_course_offers_approved_by; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.course_offers
    ADD CONSTRAINT fk_course_offers_approved_by FOREIGN KEY (approved_by) REFERENCES public.user_profiles(id) ON DELETE SET NULL;


--
-- Name: course_offers fk_course_offers_converted_course; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.course_offers
    ADD CONSTRAINT fk_course_offers_converted_course FOREIGN KEY (converted_to_course_id) REFERENCES public.course_list(id) ON DELETE SET NULL;


--
-- Name: course_offers fk_course_offers_proposed_by; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.course_offers
    ADD CONSTRAINT fk_course_offers_proposed_by FOREIGN KEY (proposed_by) REFERENCES public.user_profiles(id) ON DELETE CASCADE;


--
-- Name: course_offers fk_course_offers_school; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.course_offers
    ADD CONSTRAINT fk_course_offers_school FOREIGN KEY (school_id) REFERENCES public.structure_schools(id) ON DELETE CASCADE;


--
-- Name: course_possible_times fk_course_possible_times_school; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.course_possible_times
    ADD CONSTRAINT fk_course_possible_times_school FOREIGN KEY (school_id) REFERENCES public.structure_schools(id) ON DELETE CASCADE;


--
-- Name: course_schedules fk_course_schedules_period; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.course_schedules
    ADD CONSTRAINT fk_course_schedules_period FOREIGN KEY (period_id) REFERENCES public.schedule_periods(id) ON DELETE SET NULL;


--
-- Name: lesson_diary_entries fk_lesson_diary_entries_created_by; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.lesson_diary_entries
    ADD CONSTRAINT fk_lesson_diary_entries_created_by FOREIGN KEY (created_by) REFERENCES public.user_profiles(id) ON DELETE CASCADE;


--
-- Name: lesson_diary_entries fk_lesson_diary_entries_lesson; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.lesson_diary_entries
    ADD CONSTRAINT fk_lesson_diary_entries_lesson FOREIGN KEY (lesson_id) REFERENCES public.course_lessons(id) ON DELETE CASCADE;


--
-- Name: lesson_diary_entries fk_lesson_diary_entries_school; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.lesson_diary_entries
    ADD CONSTRAINT fk_lesson_diary_entries_school FOREIGN KEY (school_id) REFERENCES public.structure_schools(id) ON DELETE CASCADE;


--
-- Name: lesson_diary_entries fk_lesson_diary_entries_updated_by; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.lesson_diary_entries
    ADD CONSTRAINT fk_lesson_diary_entries_updated_by FOREIGN KEY (updated_by) REFERENCES public.user_profiles(id) ON DELETE SET NULL;


--
-- Name: student_attendance_logs fk_student_attendance_logs_absence_note; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.student_attendance_logs
    ADD CONSTRAINT fk_student_attendance_logs_absence_note FOREIGN KEY (absence_note_id) REFERENCES public.student_absence_notes(id);


--
-- Name: student_daily_log fk_student_daily_log_absence_note; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.student_daily_log
    ADD CONSTRAINT fk_student_daily_log_absence_note FOREIGN KEY (absence_note_id) REFERENCES public.student_absence_notes(id);


--
-- Name: student_emergency_information fk_student_emergency_info_created_by; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.student_emergency_information
    ADD CONSTRAINT fk_student_emergency_info_created_by FOREIGN KEY (created_by) REFERENCES public.user_profiles(id) ON DELETE SET NULL;


--
-- Name: student_emergency_information fk_student_emergency_info_school; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.student_emergency_information
    ADD CONSTRAINT fk_student_emergency_info_school FOREIGN KEY (school_id) REFERENCES public.structure_schools(id) ON DELETE CASCADE;


--
-- Name: student_emergency_information fk_student_emergency_info_student; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.student_emergency_information
    ADD CONSTRAINT fk_student_emergency_info_student FOREIGN KEY (student_id) REFERENCES public.user_profiles(id) ON DELETE CASCADE;


--
-- Name: student_emergency_information fk_student_emergency_info_updated_by; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.student_emergency_information
    ADD CONSTRAINT fk_student_emergency_info_updated_by FOREIGN KEY (updated_by) REFERENCES public.user_profiles(id) ON DELETE SET NULL;


--
-- Name: user_codes fk_user_profile; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.user_codes
    ADD CONSTRAINT fk_user_profile FOREIGN KEY (profile_id) REFERENCES public.user_profiles(id) ON DELETE CASCADE;


--
-- Name: profile_info_family_member parent_info_profile_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.profile_info_family_member
    ADD CONSTRAINT parent_info_profile_id_fkey FOREIGN KEY (profile_id) REFERENCES public.user_profiles(id) ON DELETE CASCADE;


--
-- Name: profile_info_family_member profile_info_family_contact_created_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.profile_info_family_member
    ADD CONSTRAINT profile_info_family_contact_created_by_fkey FOREIGN KEY (created_by) REFERENCES auth.users(id) ON DELETE SET NULL;


--
-- Name: profile_info_family_member profile_info_family_contact_updated_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.profile_info_family_member
    ADD CONSTRAINT profile_info_family_contact_updated_by_fkey FOREIGN KEY (updated_by) REFERENCES auth.users(id) ON DELETE SET NULL;


--
-- Name: user_profiles profiles_school_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.user_profiles
    ADD CONSTRAINT profiles_school_id_fkey FOREIGN KEY (school_id) REFERENCES public.structure_schools(id) ON DELETE CASCADE;


--
-- Name: protected_roles protected_roles_protected_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.protected_roles
    ADD CONSTRAINT protected_roles_protected_by_fkey FOREIGN KEY (protected_by) REFERENCES public.user_profiles(id);


--
-- Name: protected_roles protected_roles_role_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.protected_roles
    ADD CONSTRAINT protected_roles_role_id_fkey FOREIGN KEY (role_id) REFERENCES public.roles(id) ON DELETE CASCADE;


--
-- Name: published_drafts published_drafts_draft_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.published_drafts
    ADD CONSTRAINT published_drafts_draft_id_fkey FOREIGN KEY (draft_id) REFERENCES public.schedule_drafts(id) ON DELETE CASCADE;


--
-- Name: published_drafts published_drafts_published_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.published_drafts
    ADD CONSTRAINT published_drafts_published_by_fkey FOREIGN KEY (published_by) REFERENCES public.user_profiles(id) ON DELETE CASCADE;


--
-- Name: published_drafts published_drafts_school_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.published_drafts
    ADD CONSTRAINT published_drafts_school_id_fkey FOREIGN KEY (school_id) REFERENCES public.structure_schools(id) ON DELETE CASCADE;


--
-- Name: published_drafts published_drafts_semester_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.published_drafts
    ADD CONSTRAINT published_drafts_semester_id_fkey FOREIGN KEY (semester_id) REFERENCES public.structure_school_semesters(id) ON DELETE CASCADE;


--
-- Name: registration_periods registration_periods_created_by_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.registration_periods
    ADD CONSTRAINT registration_periods_created_by_id_fkey FOREIGN KEY (created_by_id) REFERENCES public.user_profiles(id) ON DELETE RESTRICT;


--
-- Name: registration_periods registration_periods_school_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.registration_periods
    ADD CONSTRAINT registration_periods_school_id_fkey FOREIGN KEY (school_id) REFERENCES public.structure_schools(id) ON DELETE CASCADE;


--
-- Name: registration_periods registration_periods_semester_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.registration_periods
    ADD CONSTRAINT registration_periods_semester_id_fkey FOREIGN KEY (semester_id) REFERENCES public.structure_school_semesters(id) ON DELETE CASCADE;


--
-- Name: registration_periods registration_periods_updated_by_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.registration_periods
    ADD CONSTRAINT registration_periods_updated_by_id_fkey FOREIGN KEY (updated_by_id) REFERENCES public.user_profiles(id) ON DELETE RESTRICT;


--
-- Name: structure_rooms rooms_school_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.structure_rooms
    ADD CONSTRAINT rooms_school_id_fkey FOREIGN KEY (school_id) REFERENCES public.structure_schools(id) ON DELETE CASCADE;


--
-- Name: schedule_drafts schedule_drafts_created_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.schedule_drafts
    ADD CONSTRAINT schedule_drafts_created_by_fkey FOREIGN KEY (created_by) REFERENCES auth.users(id);


--
-- Name: schedule_drafts schedule_drafts_school_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.schedule_drafts
    ADD CONSTRAINT schedule_drafts_school_id_fkey FOREIGN KEY (school_id) REFERENCES public.structure_schools(id) ON DELETE CASCADE;


--
-- Name: schedule_drafts schedule_drafts_semester_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.schedule_drafts
    ADD CONSTRAINT schedule_drafts_semester_id_fkey FOREIGN KEY (semester_id) REFERENCES public.structure_school_semesters(id) ON DELETE CASCADE;


--
-- Name: structure_school_semesters school_periods_school_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.structure_school_semesters
    ADD CONSTRAINT school_periods_school_id_fkey FOREIGN KEY (school_id) REFERENCES public.structure_schools(id) ON DELETE CASCADE;


--
-- Name: structure_school_semesters school_periods_school_year_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.structure_school_semesters
    ADD CONSTRAINT school_periods_school_year_id_fkey FOREIGN KEY (school_year_id) REFERENCES public.structure_school_years(id) ON DELETE CASCADE;


--
-- Name: structure_school_years school_years_school_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.structure_school_years
    ADD CONSTRAINT school_years_school_id_fkey FOREIGN KEY (school_id) REFERENCES public.structure_schools(id) ON DELETE CASCADE;


--
-- Name: staff_absence_comments staff_absence_comments_absence_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.staff_absence_comments
    ADD CONSTRAINT staff_absence_comments_absence_id_fkey FOREIGN KEY (absence_id) REFERENCES public.staff_absences(id) ON DELETE CASCADE;


--
-- Name: staff_absence_comments staff_absence_comments_author_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.staff_absence_comments
    ADD CONSTRAINT staff_absence_comments_author_id_fkey FOREIGN KEY (author_id) REFERENCES auth.users(id);


--
-- Name: staff_absences staff_absences_approved_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.staff_absences
    ADD CONSTRAINT staff_absences_approved_by_fkey FOREIGN KEY (approved_by) REFERENCES public.user_profiles(id) ON DELETE SET NULL;


--
-- Name: staff_absences staff_absences_created_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.staff_absences
    ADD CONSTRAINT staff_absences_created_by_fkey FOREIGN KEY (created_by) REFERENCES public.user_profiles(id);


--
-- Name: staff_absences staff_absences_school_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.staff_absences
    ADD CONSTRAINT staff_absences_school_id_fkey FOREIGN KEY (school_id) REFERENCES public.structure_schools(id);


--
-- Name: staff_absences staff_absences_staff_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.staff_absences
    ADD CONSTRAINT staff_absences_staff_id_fkey FOREIGN KEY (staff_id) REFERENCES public.user_profiles(id) ON DELETE CASCADE;


--
-- Name: staff_class_links staff_class_links_class_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.staff_class_links
    ADD CONSTRAINT staff_class_links_class_id_fkey FOREIGN KEY (class_id) REFERENCES public.structure_classes(id) ON DELETE CASCADE;


--
-- Name: staff_class_links staff_class_links_staff_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.staff_class_links
    ADD CONSTRAINT staff_class_links_staff_id_fkey FOREIGN KEY (staff_id) REFERENCES public.user_profiles(id) ON DELETE CASCADE;


--
-- Name: staff_contracts staff_contracts_school_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.staff_contracts
    ADD CONSTRAINT staff_contracts_school_id_fkey FOREIGN KEY (school_id) REFERENCES public.structure_schools(id) ON DELETE CASCADE;


--
-- Name: staff_contracts staff_contracts_staff_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.staff_contracts
    ADD CONSTRAINT staff_contracts_staff_id_fkey FOREIGN KEY (staff_id) REFERENCES public.user_profiles(id) ON DELETE CASCADE;


--
-- Name: staff_documents staff_documents_school_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.staff_documents
    ADD CONSTRAINT staff_documents_school_id_fkey FOREIGN KEY (school_id) REFERENCES public.structure_schools(id) ON DELETE CASCADE;


--
-- Name: staff_documents staff_documents_staff_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.staff_documents
    ADD CONSTRAINT staff_documents_staff_id_fkey FOREIGN KEY (staff_id) REFERENCES public.user_profiles(id) ON DELETE CASCADE;


--
-- Name: staff_documents staff_documents_type_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.staff_documents
    ADD CONSTRAINT staff_documents_type_id_fkey FOREIGN KEY (type_id) REFERENCES public.document_types(id);


--
-- Name: staff_duty_plan staff_duty_plan_school_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.staff_duty_plan
    ADD CONSTRAINT staff_duty_plan_school_id_fkey FOREIGN KEY (school_id) REFERENCES public.structure_schools(id) ON DELETE CASCADE;


--
-- Name: staff_duty_plan staff_duty_plan_staff_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.staff_duty_plan
    ADD CONSTRAINT staff_duty_plan_staff_id_fkey FOREIGN KEY (staff_id) REFERENCES public.user_profiles(id) ON DELETE CASCADE;


--
-- Name: profile_info_staff staff_info_profile_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.profile_info_staff
    ADD CONSTRAINT staff_info_profile_id_fkey FOREIGN KEY (profile_id) REFERENCES public.user_profiles(id) ON DELETE CASCADE;


--
-- Name: staff_subjects staff_subjects_staff_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.staff_subjects
    ADD CONSTRAINT staff_subjects_staff_id_fkey FOREIGN KEY (staff_id) REFERENCES public.user_profiles(id) ON DELETE CASCADE;


--
-- Name: staff_subjects staff_subjects_subject_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.staff_subjects
    ADD CONSTRAINT staff_subjects_subject_id_fkey FOREIGN KEY (subject_id) REFERENCES public.subjects(id) ON DELETE CASCADE;


--
-- Name: staff_work_contracts staff_work_contracts_school_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.staff_work_contracts
    ADD CONSTRAINT staff_work_contracts_school_id_fkey FOREIGN KEY (school_id) REFERENCES public.structure_schools(id) ON DELETE CASCADE;


--
-- Name: staff_work_contracts staff_work_contracts_staff_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.staff_work_contracts
    ADD CONSTRAINT staff_work_contracts_staff_id_fkey FOREIGN KEY (staff_id) REFERENCES public.user_profiles(id) ON DELETE CASCADE;


--
-- Name: staff_yearly_preferences staff_yearly_preferences_staff_profile_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.staff_yearly_preferences
    ADD CONSTRAINT staff_yearly_preferences_staff_profile_id_fkey FOREIGN KEY (staff_profile_id) REFERENCES public.profile_info_staff(profile_id) ON DELETE CASCADE;


--
-- Name: structure_school_days structure_school_days_day_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.structure_school_days
    ADD CONSTRAINT structure_school_days_day_id_fkey FOREIGN KEY (day_id) REFERENCES public.structure_days(id) ON DELETE CASCADE;


--
-- Name: structure_school_days structure_school_days_school_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.structure_school_days
    ADD CONSTRAINT structure_school_days_school_id_fkey FOREIGN KEY (school_id) REFERENCES public.structure_schools(id) ON DELETE CASCADE;


--
-- Name: structure_schools structure_schools_principal_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.structure_schools
    ADD CONSTRAINT structure_schools_principal_id_fkey FOREIGN KEY (principal_id) REFERENCES public.user_profiles(id);


--
-- Name: student_attendance_logs student_attendance_logs_daily_log_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.student_attendance_logs
    ADD CONSTRAINT student_attendance_logs_daily_log_id_fkey FOREIGN KEY (daily_log_id) REFERENCES public.student_daily_log(id) ON DELETE SET NULL;


--
-- Name: student_attendance_logs student_attendance_logs_lesson_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.student_attendance_logs
    ADD CONSTRAINT student_attendance_logs_lesson_id_fkey FOREIGN KEY (lesson_id) REFERENCES public.course_lessons(id) ON DELETE RESTRICT;


--
-- Name: student_attendance_logs student_attendance_logs_recorded_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.student_attendance_logs
    ADD CONSTRAINT student_attendance_logs_recorded_by_fkey FOREIGN KEY (recorded_by) REFERENCES public.user_profiles(id);


--
-- Name: student_attendance_logs student_attendance_logs_student_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.student_attendance_logs
    ADD CONSTRAINT student_attendance_logs_student_id_fkey FOREIGN KEY (student_id) REFERENCES public.user_profiles(id);


--
-- Name: student_course_wish_choices student_course_wish_choices_submission_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.student_course_wish_choices
    ADD CONSTRAINT student_course_wish_choices_submission_id_fkey FOREIGN KEY (submission_id) REFERENCES public.student_course_wish_submissions(id) ON DELETE CASCADE;


--
-- Name: student_course_wish_choices student_course_wish_choices_window_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.student_course_wish_choices
    ADD CONSTRAINT student_course_wish_choices_window_id_fkey FOREIGN KEY (window_id) REFERENCES public.course_registration_windows(id) ON DELETE CASCADE;


--
-- Name: student_course_wish_submissions student_course_wish_submissions_registration_period_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.student_course_wish_submissions
    ADD CONSTRAINT student_course_wish_submissions_registration_period_id_fkey FOREIGN KEY (registration_period_id) REFERENCES public.registration_periods(id) ON DELETE CASCADE;


--
-- Name: student_course_wish_submissions student_course_wish_submissions_school_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.student_course_wish_submissions
    ADD CONSTRAINT student_course_wish_submissions_school_id_fkey FOREIGN KEY (school_id) REFERENCES public.structure_schools(id) ON DELETE CASCADE;


--
-- Name: student_course_wish_submissions student_course_wish_submissions_semester_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.student_course_wish_submissions
    ADD CONSTRAINT student_course_wish_submissions_semester_id_fkey FOREIGN KEY (semester_id) REFERENCES public.structure_school_semesters(id) ON DELETE CASCADE;


--
-- Name: student_course_wish_submissions student_course_wish_submissions_student_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.student_course_wish_submissions
    ADD CONSTRAINT student_course_wish_submissions_student_id_fkey FOREIGN KEY (student_id) REFERENCES public.user_profiles(id) ON DELETE CASCADE;


--
-- Name: student_course_wish_submissions student_course_wish_submissions_submitted_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.student_course_wish_submissions
    ADD CONSTRAINT student_course_wish_submissions_submitted_by_fkey FOREIGN KEY (submitted_by) REFERENCES public.user_profiles(id);


--
-- Name: student_daily_log student_daily_log_check_in_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.student_daily_log
    ADD CONSTRAINT student_daily_log_check_in_by_fkey FOREIGN KEY (check_in_by) REFERENCES public.user_profiles(id);


--
-- Name: student_daily_log student_daily_log_check_out_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.student_daily_log
    ADD CONSTRAINT student_daily_log_check_out_by_fkey FOREIGN KEY (check_out_by) REFERENCES public.user_profiles(id);


--
-- Name: student_daily_log student_daily_log_last_updated_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.student_daily_log
    ADD CONSTRAINT student_daily_log_last_updated_by_fkey FOREIGN KEY (last_updated_by) REFERENCES public.user_profiles(id);


--
-- Name: student_daily_log student_daily_log_school_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.student_daily_log
    ADD CONSTRAINT student_daily_log_school_id_fkey FOREIGN KEY (school_id) REFERENCES public.structure_schools(id);


--
-- Name: student_daily_log student_daily_log_student_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.student_daily_log
    ADD CONSTRAINT student_daily_log_student_id_fkey FOREIGN KEY (student_id) REFERENCES public.user_profiles(id);


--
-- Name: profile_info_student student_info_class_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.profile_info_student
    ADD CONSTRAINT student_info_class_id_fkey FOREIGN KEY (class_id) REFERENCES public.structure_classes(id) ON DELETE SET NULL;


--
-- Name: profile_info_student student_info_profile_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.profile_info_student
    ADD CONSTRAINT student_info_profile_id_fkey FOREIGN KEY (profile_id) REFERENCES public.user_profiles(id) ON DELETE CASCADE;


--
-- Name: student_presence_events student_presence_events_daily_log_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.student_presence_events
    ADD CONSTRAINT student_presence_events_daily_log_id_fkey FOREIGN KEY (daily_log_id) REFERENCES public.student_daily_log(id) ON DELETE CASCADE;


--
-- Name: student_presence_events student_presence_events_performed_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.student_presence_events
    ADD CONSTRAINT student_presence_events_performed_by_fkey FOREIGN KEY (performed_by) REFERENCES public.user_profiles(id);


--
-- Name: student_presence_events student_presence_events_student_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.student_presence_events
    ADD CONSTRAINT student_presence_events_student_id_fkey FOREIGN KEY (student_id) REFERENCES public.user_profiles(id);


--
-- Name: subject_class_hours subject_class_hours_class_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.subject_class_hours
    ADD CONSTRAINT subject_class_hours_class_id_fkey FOREIGN KEY (class_id) REFERENCES public.structure_classes(id);


--
-- Name: subject_class_hours subject_class_hours_school_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.subject_class_hours
    ADD CONSTRAINT subject_class_hours_school_id_fkey FOREIGN KEY (school_id) REFERENCES public.structure_schools(id);


--
-- Name: subject_class_hours subject_class_hours_subject_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.subject_class_hours
    ADD CONSTRAINT subject_class_hours_subject_id_fkey FOREIGN KEY (subject_id) REFERENCES public.subjects(id);


--
-- Name: subject_grade_hours subject_grade_hours_school_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.subject_grade_hours
    ADD CONSTRAINT subject_grade_hours_school_id_fkey FOREIGN KEY (school_id) REFERENCES public.structure_schools(id);


--
-- Name: subject_grade_hours subject_grade_hours_subject_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.subject_grade_hours
    ADD CONSTRAINT subject_grade_hours_subject_id_fkey FOREIGN KEY (subject_id) REFERENCES public.subjects(id);


--
-- Name: subjects subjects_icon_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.subjects
    ADD CONSTRAINT subjects_icon_id_fkey FOREIGN KEY (icon_id) REFERENCES public.subject_icons(id) ON DELETE SET NULL;


--
-- Name: subjects subjects_school_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.subjects
    ADD CONSTRAINT subjects_school_id_fkey FOREIGN KEY (school_id) REFERENCES public.structure_schools(id) ON DELETE CASCADE;


--
-- Name: substitutions substitutions_created_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.substitutions
    ADD CONSTRAINT substitutions_created_by_fkey FOREIGN KEY (created_by) REFERENCES auth.users(id);


--
-- Name: substitutions substitutions_original_lesson_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.substitutions
    ADD CONSTRAINT substitutions_original_lesson_id_fkey FOREIGN KEY (original_lesson_id) REFERENCES public.course_lessons(id) ON DELETE CASCADE;


--
-- Name: schedule_periods time_blocks_school_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.schedule_periods
    ADD CONSTRAINT time_blocks_school_id_fkey FOREIGN KEY (school_id) REFERENCES public.structure_schools(id) ON DELETE CASCADE;


--
-- Name: user_codes user_codes_created_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.user_codes
    ADD CONSTRAINT user_codes_created_by_fkey FOREIGN KEY (created_by) REFERENCES auth.users(id);


--
-- Name: user_group_members user_group_members_group_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.user_group_members
    ADD CONSTRAINT user_group_members_group_id_fkey FOREIGN KEY (group_id) REFERENCES public.user_groups(id) ON DELETE CASCADE;


--
-- Name: user_group_members user_group_members_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.user_group_members
    ADD CONSTRAINT user_group_members_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.user_profiles(id) ON DELETE CASCADE;


--
-- Name: user_groups user_groups_created_by_fkey; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.user_groups
    ADD CONSTRAINT user_groups_created_by_fkey FOREIGN KEY (created_by) REFERENCES public.user_profiles(id);


--
-- Name: user_groups user_groups_school_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.user_groups
    ADD CONSTRAINT user_groups_school_id_fkey FOREIGN KEY (school_id) REFERENCES public.structure_schools(id);


--
-- Name: user_profiles user_profiles_role_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.user_profiles
    ADD CONSTRAINT user_profiles_role_id_fkey FOREIGN KEY (role_id) REFERENCES public.roles(id) ON DELETE SET NULL;


--
-- Name: user_roles user_roles_role_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.user_roles
    ADD CONSTRAINT user_roles_role_id_fkey FOREIGN KEY (role_id) REFERENCES public.roles(id);


--
-- Name: user_roles user_roles_user_profile_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: supabase_admin
--

ALTER TABLE ONLY public.user_roles
    ADD CONSTRAINT user_roles_user_profile_id_fkey FOREIGN KEY (user_profile_id) REFERENCES public.user_profiles(id);


--
-- Name: objects objects_bucketId_fkey; Type: FK CONSTRAINT; Schema: storage; Owner: supabase_storage_admin
--

ALTER TABLE ONLY storage.objects
    ADD CONSTRAINT "objects_bucketId_fkey" FOREIGN KEY (bucket_id) REFERENCES storage.buckets(id);


--
-- Name: prefixes prefixes_bucketId_fkey; Type: FK CONSTRAINT; Schema: storage; Owner: supabase_storage_admin
--

ALTER TABLE ONLY storage.prefixes
    ADD CONSTRAINT "prefixes_bucketId_fkey" FOREIGN KEY (bucket_id) REFERENCES storage.buckets(id);


--
-- Name: s3_multipart_uploads s3_multipart_uploads_bucket_id_fkey; Type: FK CONSTRAINT; Schema: storage; Owner: supabase_storage_admin
--

ALTER TABLE ONLY storage.s3_multipart_uploads
    ADD CONSTRAINT s3_multipart_uploads_bucket_id_fkey FOREIGN KEY (bucket_id) REFERENCES storage.buckets(id);


--
-- Name: s3_multipart_uploads_parts s3_multipart_uploads_parts_bucket_id_fkey; Type: FK CONSTRAINT; Schema: storage; Owner: supabase_storage_admin
--

ALTER TABLE ONLY storage.s3_multipart_uploads_parts
    ADD CONSTRAINT s3_multipart_uploads_parts_bucket_id_fkey FOREIGN KEY (bucket_id) REFERENCES storage.buckets(id);


--
-- Name: s3_multipart_uploads_parts s3_multipart_uploads_parts_upload_id_fkey; Type: FK CONSTRAINT; Schema: storage; Owner: supabase_storage_admin
--

ALTER TABLE ONLY storage.s3_multipart_uploads_parts
    ADD CONSTRAINT s3_multipart_uploads_parts_upload_id_fkey FOREIGN KEY (upload_id) REFERENCES storage.s3_multipart_uploads(id) ON DELETE CASCADE;


--
-- Name: audit_log_entries; Type: ROW SECURITY; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE auth.audit_log_entries ENABLE ROW LEVEL SECURITY;

--
-- Name: flow_state; Type: ROW SECURITY; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE auth.flow_state ENABLE ROW LEVEL SECURITY;

--
-- Name: identities; Type: ROW SECURITY; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE auth.identities ENABLE ROW LEVEL SECURITY;

--
-- Name: instances; Type: ROW SECURITY; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE auth.instances ENABLE ROW LEVEL SECURITY;

--
-- Name: mfa_amr_claims; Type: ROW SECURITY; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE auth.mfa_amr_claims ENABLE ROW LEVEL SECURITY;

--
-- Name: mfa_challenges; Type: ROW SECURITY; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE auth.mfa_challenges ENABLE ROW LEVEL SECURITY;

--
-- Name: mfa_factors; Type: ROW SECURITY; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE auth.mfa_factors ENABLE ROW LEVEL SECURITY;

--
-- Name: one_time_tokens; Type: ROW SECURITY; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE auth.one_time_tokens ENABLE ROW LEVEL SECURITY;

--
-- Name: refresh_tokens; Type: ROW SECURITY; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE auth.refresh_tokens ENABLE ROW LEVEL SECURITY;

--
-- Name: saml_providers; Type: ROW SECURITY; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE auth.saml_providers ENABLE ROW LEVEL SECURITY;

--
-- Name: saml_relay_states; Type: ROW SECURITY; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE auth.saml_relay_states ENABLE ROW LEVEL SECURITY;

--
-- Name: schema_migrations; Type: ROW SECURITY; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE auth.schema_migrations ENABLE ROW LEVEL SECURITY;

--
-- Name: sessions; Type: ROW SECURITY; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE auth.sessions ENABLE ROW LEVEL SECURITY;

--
-- Name: sso_domains; Type: ROW SECURITY; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE auth.sso_domains ENABLE ROW LEVEL SECURITY;

--
-- Name: sso_providers; Type: ROW SECURITY; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE auth.sso_providers ENABLE ROW LEVEL SECURITY;

--
-- Name: users; Type: ROW SECURITY; Schema: auth; Owner: supabase_auth_admin
--

ALTER TABLE auth.users ENABLE ROW LEVEL SECURITY;

--
-- Name: protected_roles admin_only_protected_roles_modify; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY admin_only_protected_roles_modify ON public.protected_roles TO authenticated USING ((EXISTS ( SELECT 1
   FROM ((public.user_profiles up
     JOIN public.user_roles ur ON ((up.id = ur.user_profile_id)))
     JOIN public.roles r ON ((ur.role_id = r.id)))
  WHERE ((up.id = auth.uid()) AND (r.name = 'Admin'::text) AND (up.school_id = auth.get_current_user_school_id()))))) WITH CHECK ((EXISTS ( SELECT 1
   FROM ((public.user_profiles up
     JOIN public.user_roles ur ON ((up.id = ur.user_profile_id)))
     JOIN public.roles r ON ((ur.role_id = r.id)))
  WHERE ((up.id = auth.uid()) AND (r.name = 'Admin'::text) AND (up.school_id = auth.get_current_user_school_id())))));


--
-- Name: bulletin_post_users; Type: ROW SECURITY; Schema: public; Owner: supabase_admin
--

ALTER TABLE public.bulletin_post_users ENABLE ROW LEVEL SECURITY;

--
-- Name: bulletin_posts; Type: ROW SECURITY; Schema: public; Owner: supabase_admin
--

ALTER TABLE public.bulletin_posts ENABLE ROW LEVEL SECURITY;

--
-- Name: bulletin_recurrences; Type: ROW SECURITY; Schema: public; Owner: supabase_admin
--

ALTER TABLE public.bulletin_recurrences ENABLE ROW LEVEL SECURITY;

--
-- Name: change_log; Type: ROW SECURITY; Schema: public; Owner: supabase_admin
--

ALTER TABLE public.change_log ENABLE ROW LEVEL SECURITY;

--
-- Name: contacts; Type: ROW SECURITY; Schema: public; Owner: supabase_admin
--

ALTER TABLE public.contacts ENABLE ROW LEVEL SECURITY;

--
-- Name: course_allocation_drafts; Type: ROW SECURITY; Schema: public; Owner: supabase_admin
--

ALTER TABLE public.course_allocation_drafts ENABLE ROW LEVEL SECURITY;

--
-- Name: course_applications; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.course_applications ENABLE ROW LEVEL SECURITY;

--
-- Name: course_enrollments; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.course_enrollments ENABLE ROW LEVEL SECURITY;

--
-- Name: course_lessons; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.course_lessons ENABLE ROW LEVEL SECURITY;

--
-- Name: course_list; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.course_list ENABLE ROW LEVEL SECURITY;

--
-- Name: course_notes; Type: ROW SECURITY; Schema: public; Owner: supabase_admin
--

ALTER TABLE public.course_notes ENABLE ROW LEVEL SECURITY;

--
-- Name: course_possible_times; Type: ROW SECURITY; Schema: public; Owner: supabase_admin
--

ALTER TABLE public.course_possible_times ENABLE ROW LEVEL SECURITY;

--
-- Name: course_registration_windows; Type: ROW SECURITY; Schema: public; Owner: supabase_admin
--

ALTER TABLE public.course_registration_windows ENABLE ROW LEVEL SECURITY;

--
-- Name: course_schedules; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.course_schedules ENABLE ROW LEVEL SECURITY;

--
-- Name: document_types; Type: ROW SECURITY; Schema: public; Owner: supabase_admin
--

ALTER TABLE public.document_types ENABLE ROW LEVEL SECURITY;

--
-- Name: families; Type: ROW SECURITY; Schema: public; Owner: supabase_admin
--

ALTER TABLE public.families ENABLE ROW LEVEL SECURITY;

--
-- Name: family_member_child_links; Type: ROW SECURITY; Schema: public; Owner: supabase_admin
--

ALTER TABLE public.family_member_child_links ENABLE ROW LEVEL SECURITY;

--
-- Name: family_members; Type: ROW SECURITY; Schema: public; Owner: supabase_admin
--

ALTER TABLE public.family_members ENABLE ROW LEVEL SECURITY;

--
-- Name: profile_info_family_member; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.profile_info_family_member ENABLE ROW LEVEL SECURITY;

--
-- Name: profile_info_staff; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.profile_info_staff ENABLE ROW LEVEL SECURITY;

--
-- Name: profile_info_student; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.profile_info_student ENABLE ROW LEVEL SECURITY;

--
-- Name: protected_roles; Type: ROW SECURITY; Schema: public; Owner: supabase_admin
--

ALTER TABLE public.protected_roles ENABLE ROW LEVEL SECURITY;

--
-- Name: protected_roles public_read_protected_roles; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY public_read_protected_roles ON public.protected_roles FOR SELECT TO authenticated USING (true);


--
-- Name: published_drafts; Type: ROW SECURITY; Schema: public; Owner: supabase_admin
--

ALTER TABLE public.published_drafts ENABLE ROW LEVEL SECURITY;

--
-- Name: registration_periods; Type: ROW SECURITY; Schema: public; Owner: supabase_admin
--

ALTER TABLE public.registration_periods ENABLE ROW LEVEL SECURITY;

--
-- Name: schedule_calendar_exceptions; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.schedule_calendar_exceptions ENABLE ROW LEVEL SECURITY;

--
-- Name: schedule_daily_rostering; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.schedule_daily_rostering ENABLE ROW LEVEL SECURITY;

--
-- Name: schedule_drafts; Type: ROW SECURITY; Schema: public; Owner: supabase_admin
--

ALTER TABLE public.schedule_drafts ENABLE ROW LEVEL SECURITY;

--
-- Name: schedule_periods; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.schedule_periods ENABLE ROW LEVEL SECURITY;

--
-- Name: bulletin_post_users school_isolation_bulletin_post_users_delete; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_bulletin_post_users_delete ON public.bulletin_post_users TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: bulletin_post_users school_isolation_bulletin_post_users_insert; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_bulletin_post_users_insert ON public.bulletin_post_users FOR INSERT TO authenticated WITH CHECK ((school_id = auth.get_user_school_id()));


--
-- Name: bulletin_post_users school_isolation_bulletin_post_users_select; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_bulletin_post_users_select ON public.bulletin_post_users TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: bulletin_post_users school_isolation_bulletin_post_users_update; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_bulletin_post_users_update ON public.bulletin_post_users TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: bulletin_posts school_isolation_bulletin_posts_delete; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_bulletin_posts_delete ON public.bulletin_posts TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: bulletin_posts school_isolation_bulletin_posts_insert; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_bulletin_posts_insert ON public.bulletin_posts FOR INSERT TO authenticated WITH CHECK ((school_id = auth.get_user_school_id()));


--
-- Name: bulletin_posts school_isolation_bulletin_posts_select; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_bulletin_posts_select ON public.bulletin_posts FOR SELECT TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: bulletin_posts school_isolation_bulletin_posts_update; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_bulletin_posts_update ON public.bulletin_posts TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: bulletin_recurrences school_isolation_bulletin_recurrences_delete; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_bulletin_recurrences_delete ON public.bulletin_recurrences TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: bulletin_recurrences school_isolation_bulletin_recurrences_insert; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_bulletin_recurrences_insert ON public.bulletin_recurrences FOR INSERT TO authenticated WITH CHECK ((school_id = auth.get_user_school_id()));


--
-- Name: bulletin_recurrences school_isolation_bulletin_recurrences_select; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_bulletin_recurrences_select ON public.bulletin_recurrences TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: bulletin_recurrences school_isolation_bulletin_recurrences_update; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_bulletin_recurrences_update ON public.bulletin_recurrences TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: change_log school_isolation_change_log_delete; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_change_log_delete ON public.change_log TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: change_log school_isolation_change_log_insert; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_change_log_insert ON public.change_log FOR INSERT TO authenticated WITH CHECK ((school_id = auth.get_user_school_id()));


--
-- Name: change_log school_isolation_change_log_select; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_change_log_select ON public.change_log TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: change_log school_isolation_change_log_update; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_change_log_update ON public.change_log TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: contacts school_isolation_contacts_delete; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_contacts_delete ON public.contacts TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: contacts school_isolation_contacts_insert; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_contacts_insert ON public.contacts FOR INSERT TO authenticated WITH CHECK ((school_id = auth.get_user_school_id()));


--
-- Name: contacts school_isolation_contacts_select; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_contacts_select ON public.contacts TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: contacts school_isolation_contacts_update; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_contacts_update ON public.contacts TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: course_allocation_drafts school_isolation_course_allocation_drafts_delete; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_course_allocation_drafts_delete ON public.course_allocation_drafts TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: course_allocation_drafts school_isolation_course_allocation_drafts_insert; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_course_allocation_drafts_insert ON public.course_allocation_drafts FOR INSERT TO authenticated WITH CHECK ((school_id = auth.get_user_school_id()));


--
-- Name: course_allocation_drafts school_isolation_course_allocation_drafts_select; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_course_allocation_drafts_select ON public.course_allocation_drafts TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: course_allocation_drafts school_isolation_course_allocation_drafts_update; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_course_allocation_drafts_update ON public.course_allocation_drafts TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: course_applications school_isolation_course_applications_delete; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY school_isolation_course_applications_delete ON public.course_applications TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: course_applications school_isolation_course_applications_insert; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY school_isolation_course_applications_insert ON public.course_applications FOR INSERT TO authenticated WITH CHECK ((school_id = auth.get_user_school_id()));


--
-- Name: course_applications school_isolation_course_applications_select; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY school_isolation_course_applications_select ON public.course_applications TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: course_applications school_isolation_course_applications_update; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY school_isolation_course_applications_update ON public.course_applications TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: course_enrollments school_isolation_course_enrollments_delete; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY school_isolation_course_enrollments_delete ON public.course_enrollments TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: course_enrollments school_isolation_course_enrollments_insert; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY school_isolation_course_enrollments_insert ON public.course_enrollments FOR INSERT TO authenticated WITH CHECK ((school_id = auth.get_user_school_id()));


--
-- Name: course_enrollments school_isolation_course_enrollments_select; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY school_isolation_course_enrollments_select ON public.course_enrollments TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: course_enrollments school_isolation_course_enrollments_update; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY school_isolation_course_enrollments_update ON public.course_enrollments TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: course_lessons school_isolation_course_lessons_delete; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY school_isolation_course_lessons_delete ON public.course_lessons TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: course_lessons school_isolation_course_lessons_insert; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY school_isolation_course_lessons_insert ON public.course_lessons FOR INSERT TO authenticated WITH CHECK ((school_id = auth.get_user_school_id()));


--
-- Name: course_lessons school_isolation_course_lessons_select; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY school_isolation_course_lessons_select ON public.course_lessons TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: course_lessons school_isolation_course_lessons_update; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY school_isolation_course_lessons_update ON public.course_lessons TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: course_list school_isolation_course_list_delete; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY school_isolation_course_list_delete ON public.course_list TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: course_list school_isolation_course_list_insert; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY school_isolation_course_list_insert ON public.course_list FOR INSERT TO authenticated WITH CHECK ((school_id = auth.get_user_school_id()));


--
-- Name: course_list school_isolation_course_list_select; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY school_isolation_course_list_select ON public.course_list TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: course_list school_isolation_course_list_update; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY school_isolation_course_list_update ON public.course_list TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: course_notes school_isolation_course_notes_delete; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_course_notes_delete ON public.course_notes FOR DELETE TO authenticated USING ((school_id = (auth.get_user_school_id())::text));


--
-- Name: course_notes school_isolation_course_notes_insert; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_course_notes_insert ON public.course_notes FOR INSERT TO authenticated WITH CHECK ((school_id = (auth.get_user_school_id())::text));


--
-- Name: course_notes school_isolation_course_notes_select; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_course_notes_select ON public.course_notes FOR SELECT TO authenticated USING ((school_id = (auth.get_user_school_id())::text));


--
-- Name: course_notes school_isolation_course_notes_update; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_course_notes_update ON public.course_notes FOR UPDATE TO authenticated USING ((school_id = (auth.get_user_school_id())::text)) WITH CHECK ((school_id = (auth.get_user_school_id())::text));


--
-- Name: course_possible_times school_isolation_course_possible_times_delete; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_course_possible_times_delete ON public.course_possible_times TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: course_possible_times school_isolation_course_possible_times_insert; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_course_possible_times_insert ON public.course_possible_times FOR INSERT TO authenticated WITH CHECK ((school_id = auth.get_user_school_id()));


--
-- Name: course_possible_times school_isolation_course_possible_times_select; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_course_possible_times_select ON public.course_possible_times TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: course_possible_times school_isolation_course_possible_times_update; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_course_possible_times_update ON public.course_possible_times TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: course_registration_windows school_isolation_course_registration_windows_delete; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_course_registration_windows_delete ON public.course_registration_windows TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: course_registration_windows school_isolation_course_registration_windows_insert; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_course_registration_windows_insert ON public.course_registration_windows FOR INSERT TO authenticated WITH CHECK ((school_id = auth.get_user_school_id()));


--
-- Name: course_registration_windows school_isolation_course_registration_windows_select; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_course_registration_windows_select ON public.course_registration_windows TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: course_registration_windows school_isolation_course_registration_windows_update; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_course_registration_windows_update ON public.course_registration_windows TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: course_schedules school_isolation_course_schedules_delete; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY school_isolation_course_schedules_delete ON public.course_schedules TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: course_schedules school_isolation_course_schedules_insert; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY school_isolation_course_schedules_insert ON public.course_schedules FOR INSERT TO authenticated WITH CHECK ((school_id = auth.get_user_school_id()));


--
-- Name: course_schedules school_isolation_course_schedules_select; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY school_isolation_course_schedules_select ON public.course_schedules TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: course_schedules school_isolation_course_schedules_update; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY school_isolation_course_schedules_update ON public.course_schedules TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: structure_schools school_isolation_delete; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY school_isolation_delete ON public.structure_schools FOR DELETE TO authenticated USING ((id = auth.get_user_school_id()));


--
-- Name: document_types school_isolation_document_types_delete; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_document_types_delete ON public.document_types TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: document_types school_isolation_document_types_insert; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_document_types_insert ON public.document_types FOR INSERT TO authenticated WITH CHECK ((school_id = auth.get_user_school_id()));


--
-- Name: document_types school_isolation_document_types_select; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_document_types_select ON public.document_types TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: document_types school_isolation_document_types_update; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_document_types_update ON public.document_types TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: families school_isolation_families_delete; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_families_delete ON public.families TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: families school_isolation_families_insert; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_families_insert ON public.families FOR INSERT TO authenticated WITH CHECK ((school_id = auth.get_user_school_id()));


--
-- Name: families school_isolation_families_select; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_families_select ON public.families TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: families school_isolation_families_update; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_families_update ON public.families TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: family_member_child_links school_isolation_family_member_child_links_delete; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_family_member_child_links_delete ON public.family_member_child_links TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: family_member_child_links school_isolation_family_member_child_links_insert; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_family_member_child_links_insert ON public.family_member_child_links FOR INSERT TO authenticated WITH CHECK ((school_id = auth.get_user_school_id()));


--
-- Name: family_member_child_links school_isolation_family_member_child_links_select; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_family_member_child_links_select ON public.family_member_child_links TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: family_member_child_links school_isolation_family_member_child_links_update; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_family_member_child_links_update ON public.family_member_child_links TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: family_members school_isolation_family_members_delete; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_family_members_delete ON public.family_members TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: family_members school_isolation_family_members_insert; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_family_members_insert ON public.family_members FOR INSERT TO authenticated WITH CHECK ((school_id = auth.get_user_school_id()));


--
-- Name: family_members school_isolation_family_members_select; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_family_members_select ON public.family_members TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: family_members school_isolation_family_members_update; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_family_members_update ON public.family_members TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: structure_schools school_isolation_insert; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY school_isolation_insert ON public.structure_schools FOR INSERT TO authenticated WITH CHECK ((id = auth.get_user_school_id()));


--
-- Name: profile_info_family_member school_isolation_profile_info_family_member_delete; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY school_isolation_profile_info_family_member_delete ON public.profile_info_family_member TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: profile_info_family_member school_isolation_profile_info_family_member_insert; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY school_isolation_profile_info_family_member_insert ON public.profile_info_family_member FOR INSERT TO authenticated WITH CHECK ((school_id = auth.get_user_school_id()));


--
-- Name: profile_info_family_member school_isolation_profile_info_family_member_select; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY school_isolation_profile_info_family_member_select ON public.profile_info_family_member TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: profile_info_family_member school_isolation_profile_info_family_member_update; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY school_isolation_profile_info_family_member_update ON public.profile_info_family_member TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: profile_info_staff school_isolation_profile_info_staff_delete; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY school_isolation_profile_info_staff_delete ON public.profile_info_staff TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: profile_info_staff school_isolation_profile_info_staff_insert; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY school_isolation_profile_info_staff_insert ON public.profile_info_staff FOR INSERT TO authenticated WITH CHECK ((school_id = auth.get_user_school_id()));


--
-- Name: profile_info_staff school_isolation_profile_info_staff_select; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY school_isolation_profile_info_staff_select ON public.profile_info_staff TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: profile_info_staff school_isolation_profile_info_staff_update; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY school_isolation_profile_info_staff_update ON public.profile_info_staff TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: profile_info_student school_isolation_profile_info_student_delete; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY school_isolation_profile_info_student_delete ON public.profile_info_student TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: profile_info_student school_isolation_profile_info_student_insert; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY school_isolation_profile_info_student_insert ON public.profile_info_student FOR INSERT TO authenticated WITH CHECK ((school_id = auth.get_user_school_id()));


--
-- Name: profile_info_student school_isolation_profile_info_student_select; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY school_isolation_profile_info_student_select ON public.profile_info_student TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: profile_info_student school_isolation_profile_info_student_update; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY school_isolation_profile_info_student_update ON public.profile_info_student TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: published_drafts school_isolation_published_drafts_delete; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_published_drafts_delete ON public.published_drafts TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: published_drafts school_isolation_published_drafts_insert; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_published_drafts_insert ON public.published_drafts FOR INSERT TO authenticated WITH CHECK ((school_id = auth.get_user_school_id()));


--
-- Name: published_drafts school_isolation_published_drafts_select; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_published_drafts_select ON public.published_drafts TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: published_drafts school_isolation_published_drafts_update; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_published_drafts_update ON public.published_drafts TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: registration_periods school_isolation_registration_periods_delete; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_registration_periods_delete ON public.registration_periods TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: registration_periods school_isolation_registration_periods_insert; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_registration_periods_insert ON public.registration_periods FOR INSERT TO authenticated WITH CHECK ((school_id = auth.get_user_school_id()));


--
-- Name: registration_periods school_isolation_registration_periods_select; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_registration_periods_select ON public.registration_periods TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: registration_periods school_isolation_registration_periods_update; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_registration_periods_update ON public.registration_periods TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: schedule_calendar_exceptions school_isolation_schedule_calendar_exceptions_delete; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY school_isolation_schedule_calendar_exceptions_delete ON public.schedule_calendar_exceptions TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: schedule_calendar_exceptions school_isolation_schedule_calendar_exceptions_insert; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY school_isolation_schedule_calendar_exceptions_insert ON public.schedule_calendar_exceptions FOR INSERT TO authenticated WITH CHECK ((school_id = auth.get_user_school_id()));


--
-- Name: schedule_calendar_exceptions school_isolation_schedule_calendar_exceptions_select; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY school_isolation_schedule_calendar_exceptions_select ON public.schedule_calendar_exceptions TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: schedule_calendar_exceptions school_isolation_schedule_calendar_exceptions_update; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY school_isolation_schedule_calendar_exceptions_update ON public.schedule_calendar_exceptions TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: schedule_daily_rostering school_isolation_schedule_daily_rostering_delete; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY school_isolation_schedule_daily_rostering_delete ON public.schedule_daily_rostering TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: schedule_daily_rostering school_isolation_schedule_daily_rostering_insert; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY school_isolation_schedule_daily_rostering_insert ON public.schedule_daily_rostering FOR INSERT TO authenticated WITH CHECK ((school_id = auth.get_user_school_id()));


--
-- Name: schedule_daily_rostering school_isolation_schedule_daily_rostering_select; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY school_isolation_schedule_daily_rostering_select ON public.schedule_daily_rostering TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: schedule_daily_rostering school_isolation_schedule_daily_rostering_update; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY school_isolation_schedule_daily_rostering_update ON public.schedule_daily_rostering TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: schedule_drafts school_isolation_schedule_drafts_delete; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_schedule_drafts_delete ON public.schedule_drafts TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: schedule_drafts school_isolation_schedule_drafts_insert; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_schedule_drafts_insert ON public.schedule_drafts FOR INSERT TO authenticated WITH CHECK ((school_id = auth.get_user_school_id()));


--
-- Name: schedule_drafts school_isolation_schedule_drafts_select; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_schedule_drafts_select ON public.schedule_drafts TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: schedule_drafts school_isolation_schedule_drafts_update; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_schedule_drafts_update ON public.schedule_drafts TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: schedule_periods school_isolation_schedule_periods_delete; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY school_isolation_schedule_periods_delete ON public.schedule_periods TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: schedule_periods school_isolation_schedule_periods_insert; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY school_isolation_schedule_periods_insert ON public.schedule_periods FOR INSERT TO authenticated WITH CHECK ((school_id = auth.get_user_school_id()));


--
-- Name: schedule_periods school_isolation_schedule_periods_select; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY school_isolation_schedule_periods_select ON public.schedule_periods FOR SELECT TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: schedule_periods school_isolation_schedule_periods_update; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY school_isolation_schedule_periods_update ON public.schedule_periods TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: structure_schools school_isolation_select; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY school_isolation_select ON public.structure_schools FOR SELECT TO authenticated USING ((id = auth.get_user_school_id()));


--
-- Name: staff_absence_comments school_isolation_staff_absence_comments_delete; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_staff_absence_comments_delete ON public.staff_absence_comments TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: staff_absence_comments school_isolation_staff_absence_comments_insert; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_staff_absence_comments_insert ON public.staff_absence_comments FOR INSERT TO authenticated WITH CHECK ((school_id = auth.get_user_school_id()));


--
-- Name: staff_absence_comments school_isolation_staff_absence_comments_select; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_staff_absence_comments_select ON public.staff_absence_comments TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: staff_absence_comments school_isolation_staff_absence_comments_update; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_staff_absence_comments_update ON public.staff_absence_comments TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: staff_absences school_isolation_staff_absences_delete; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY school_isolation_staff_absences_delete ON public.staff_absences TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: staff_absences school_isolation_staff_absences_insert; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY school_isolation_staff_absences_insert ON public.staff_absences FOR INSERT TO authenticated WITH CHECK ((school_id = auth.get_user_school_id()));


--
-- Name: staff_absences school_isolation_staff_absences_select; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY school_isolation_staff_absences_select ON public.staff_absences TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: staff_absences school_isolation_staff_absences_update; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY school_isolation_staff_absences_update ON public.staff_absences TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: staff_class_links school_isolation_staff_class_links_delete; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_staff_class_links_delete ON public.staff_class_links TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: staff_class_links school_isolation_staff_class_links_insert; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_staff_class_links_insert ON public.staff_class_links FOR INSERT TO authenticated WITH CHECK ((school_id = auth.get_user_school_id()));


--
-- Name: staff_class_links school_isolation_staff_class_links_select; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_staff_class_links_select ON public.staff_class_links TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: staff_class_links school_isolation_staff_class_links_update; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_staff_class_links_update ON public.staff_class_links TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: staff_contracts school_isolation_staff_contracts_delete; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_staff_contracts_delete ON public.staff_contracts TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: staff_contracts school_isolation_staff_contracts_insert; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_staff_contracts_insert ON public.staff_contracts FOR INSERT TO authenticated WITH CHECK ((school_id = auth.get_user_school_id()));


--
-- Name: staff_contracts school_isolation_staff_contracts_select; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_staff_contracts_select ON public.staff_contracts TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: staff_contracts school_isolation_staff_contracts_update; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_staff_contracts_update ON public.staff_contracts TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: staff_documents school_isolation_staff_documents_delete; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_staff_documents_delete ON public.staff_documents TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: staff_documents school_isolation_staff_documents_insert; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_staff_documents_insert ON public.staff_documents FOR INSERT TO authenticated WITH CHECK ((school_id = auth.get_user_school_id()));


--
-- Name: staff_documents school_isolation_staff_documents_select; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_staff_documents_select ON public.staff_documents TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: staff_documents school_isolation_staff_documents_update; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_staff_documents_update ON public.staff_documents TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: staff_duty_plan school_isolation_staff_duty_plan_delete; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_staff_duty_plan_delete ON public.staff_duty_plan TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: staff_duty_plan school_isolation_staff_duty_plan_insert; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_staff_duty_plan_insert ON public.staff_duty_plan FOR INSERT TO authenticated WITH CHECK ((school_id = auth.get_user_school_id()));


--
-- Name: staff_duty_plan school_isolation_staff_duty_plan_select; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_staff_duty_plan_select ON public.staff_duty_plan TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: staff_duty_plan school_isolation_staff_duty_plan_update; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_staff_duty_plan_update ON public.staff_duty_plan TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: staff_subjects school_isolation_staff_subjects_delete; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_staff_subjects_delete ON public.staff_subjects TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: staff_subjects school_isolation_staff_subjects_insert; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_staff_subjects_insert ON public.staff_subjects FOR INSERT TO authenticated WITH CHECK ((school_id = auth.get_user_school_id()));


--
-- Name: staff_subjects school_isolation_staff_subjects_select; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_staff_subjects_select ON public.staff_subjects TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: staff_subjects school_isolation_staff_subjects_update; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_staff_subjects_update ON public.staff_subjects TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: staff_work_contracts school_isolation_staff_work_contracts_delete; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY school_isolation_staff_work_contracts_delete ON public.staff_work_contracts TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: staff_work_contracts school_isolation_staff_work_contracts_insert; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY school_isolation_staff_work_contracts_insert ON public.staff_work_contracts FOR INSERT TO authenticated WITH CHECK ((school_id = auth.get_user_school_id()));


--
-- Name: staff_work_contracts school_isolation_staff_work_contracts_select; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY school_isolation_staff_work_contracts_select ON public.staff_work_contracts TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: staff_work_contracts school_isolation_staff_work_contracts_update; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY school_isolation_staff_work_contracts_update ON public.staff_work_contracts TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: staff_yearly_preferences school_isolation_staff_yearly_preferences_delete; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_staff_yearly_preferences_delete ON public.staff_yearly_preferences TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: staff_yearly_preferences school_isolation_staff_yearly_preferences_insert; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_staff_yearly_preferences_insert ON public.staff_yearly_preferences FOR INSERT TO authenticated WITH CHECK ((school_id = auth.get_user_school_id()));


--
-- Name: staff_yearly_preferences school_isolation_staff_yearly_preferences_select; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_staff_yearly_preferences_select ON public.staff_yearly_preferences TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: staff_yearly_preferences school_isolation_staff_yearly_preferences_update; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_staff_yearly_preferences_update ON public.staff_yearly_preferences TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: structure_classes school_isolation_structure_classes_delete; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY school_isolation_structure_classes_delete ON public.structure_classes TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: structure_classes school_isolation_structure_classes_insert; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY school_isolation_structure_classes_insert ON public.structure_classes FOR INSERT TO authenticated WITH CHECK ((school_id = auth.get_user_school_id()));


--
-- Name: structure_classes school_isolation_structure_classes_select; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY school_isolation_structure_classes_select ON public.structure_classes TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: structure_classes school_isolation_structure_classes_update; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY school_isolation_structure_classes_update ON public.structure_classes TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: structure_rooms school_isolation_structure_rooms_delete; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY school_isolation_structure_rooms_delete ON public.structure_rooms TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: structure_rooms school_isolation_structure_rooms_insert; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY school_isolation_structure_rooms_insert ON public.structure_rooms FOR INSERT TO authenticated WITH CHECK ((school_id = auth.get_user_school_id()));


--
-- Name: structure_rooms school_isolation_structure_rooms_select; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY school_isolation_structure_rooms_select ON public.structure_rooms TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: structure_rooms school_isolation_structure_rooms_update; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY school_isolation_structure_rooms_update ON public.structure_rooms TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: structure_school_days school_isolation_structure_school_days_delete; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_structure_school_days_delete ON public.structure_school_days TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: structure_school_days school_isolation_structure_school_days_insert; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_structure_school_days_insert ON public.structure_school_days FOR INSERT TO authenticated WITH CHECK ((school_id = auth.get_user_school_id()));


--
-- Name: structure_school_days school_isolation_structure_school_days_select; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_structure_school_days_select ON public.structure_school_days TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: structure_school_days school_isolation_structure_school_days_update; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_structure_school_days_update ON public.structure_school_days TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: structure_school_semesters school_isolation_structure_school_semesters_delete; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_structure_school_semesters_delete ON public.structure_school_semesters TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: structure_school_semesters school_isolation_structure_school_semesters_insert; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_structure_school_semesters_insert ON public.structure_school_semesters FOR INSERT TO authenticated WITH CHECK ((school_id = auth.get_user_school_id()));


--
-- Name: structure_school_semesters school_isolation_structure_school_semesters_select; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_structure_school_semesters_select ON public.structure_school_semesters TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: structure_school_semesters school_isolation_structure_school_semesters_update; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_structure_school_semesters_update ON public.structure_school_semesters TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: structure_school_years school_isolation_structure_school_years_delete; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_structure_school_years_delete ON public.structure_school_years TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: structure_school_years school_isolation_structure_school_years_insert; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_structure_school_years_insert ON public.structure_school_years FOR INSERT TO authenticated WITH CHECK ((school_id = auth.get_user_school_id()));


--
-- Name: structure_school_years school_isolation_structure_school_years_select; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_structure_school_years_select ON public.structure_school_years TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: structure_school_years school_isolation_structure_school_years_update; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_structure_school_years_update ON public.structure_school_years TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: student_absence_notes school_isolation_student_absence_notes_delete; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_student_absence_notes_delete ON public.student_absence_notes TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: student_absence_notes school_isolation_student_absence_notes_insert; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_student_absence_notes_insert ON public.student_absence_notes FOR INSERT TO authenticated WITH CHECK ((school_id = auth.get_user_school_id()));


--
-- Name: student_absence_notes school_isolation_student_absence_notes_select; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_student_absence_notes_select ON public.student_absence_notes TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: student_absence_notes school_isolation_student_absence_notes_update; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_student_absence_notes_update ON public.student_absence_notes TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: student_absence_recurrences school_isolation_student_absence_recurrences_delete; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_student_absence_recurrences_delete ON public.student_absence_recurrences TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: student_absence_recurrences school_isolation_student_absence_recurrences_insert; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_student_absence_recurrences_insert ON public.student_absence_recurrences FOR INSERT TO authenticated WITH CHECK ((school_id = auth.get_user_school_id()));


--
-- Name: student_absence_recurrences school_isolation_student_absence_recurrences_select; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_student_absence_recurrences_select ON public.student_absence_recurrences TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: student_absence_recurrences school_isolation_student_absence_recurrences_update; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_student_absence_recurrences_update ON public.student_absence_recurrences TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: student_attendance_logs school_isolation_student_attendance_logs_delete; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_student_attendance_logs_delete ON public.student_attendance_logs TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: student_attendance_logs school_isolation_student_attendance_logs_insert; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_student_attendance_logs_insert ON public.student_attendance_logs FOR INSERT TO authenticated WITH CHECK ((school_id = auth.get_user_school_id()));


--
-- Name: student_attendance_logs school_isolation_student_attendance_logs_select; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_student_attendance_logs_select ON public.student_attendance_logs TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: student_attendance_logs school_isolation_student_attendance_logs_update; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_student_attendance_logs_update ON public.student_attendance_logs TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: student_course_wish_choices school_isolation_student_course_wish_choices_delete; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_student_course_wish_choices_delete ON public.student_course_wish_choices TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: student_course_wish_choices school_isolation_student_course_wish_choices_insert; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_student_course_wish_choices_insert ON public.student_course_wish_choices FOR INSERT TO authenticated WITH CHECK ((school_id = auth.get_user_school_id()));


--
-- Name: student_course_wish_choices school_isolation_student_course_wish_choices_select; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_student_course_wish_choices_select ON public.student_course_wish_choices TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: student_course_wish_choices school_isolation_student_course_wish_choices_update; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_student_course_wish_choices_update ON public.student_course_wish_choices TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: student_course_wish_submissions school_isolation_student_course_wish_submissions_delete; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_student_course_wish_submissions_delete ON public.student_course_wish_submissions TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: student_course_wish_submissions school_isolation_student_course_wish_submissions_insert; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_student_course_wish_submissions_insert ON public.student_course_wish_submissions FOR INSERT TO authenticated WITH CHECK ((school_id = auth.get_user_school_id()));


--
-- Name: student_course_wish_submissions school_isolation_student_course_wish_submissions_select; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_student_course_wish_submissions_select ON public.student_course_wish_submissions TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: student_course_wish_submissions school_isolation_student_course_wish_submissions_update; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_student_course_wish_submissions_update ON public.student_course_wish_submissions TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: student_daily_log school_isolation_student_daily_log_delete; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_student_daily_log_delete ON public.student_daily_log TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: student_daily_log school_isolation_student_daily_log_insert; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_student_daily_log_insert ON public.student_daily_log FOR INSERT TO authenticated WITH CHECK ((school_id = auth.get_user_school_id()));


--
-- Name: student_daily_log school_isolation_student_daily_log_select; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_student_daily_log_select ON public.student_daily_log TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: student_daily_log school_isolation_student_daily_log_update; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_student_daily_log_update ON public.student_daily_log TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: student_pickup_arrangement_overrides school_isolation_student_pickup_arrangement_overrides_delete; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_student_pickup_arrangement_overrides_delete ON public.student_pickup_arrangement_overrides TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: student_pickup_arrangement_overrides school_isolation_student_pickup_arrangement_overrides_insert; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_student_pickup_arrangement_overrides_insert ON public.student_pickup_arrangement_overrides FOR INSERT TO authenticated WITH CHECK ((school_id = auth.get_user_school_id()));


--
-- Name: student_pickup_arrangement_overrides school_isolation_student_pickup_arrangement_overrides_select; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_student_pickup_arrangement_overrides_select ON public.student_pickup_arrangement_overrides TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: student_pickup_arrangement_overrides school_isolation_student_pickup_arrangement_overrides_update; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_student_pickup_arrangement_overrides_update ON public.student_pickup_arrangement_overrides TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: student_presence_events school_isolation_student_presence_events_delete; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_student_presence_events_delete ON public.student_presence_events TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: student_presence_events school_isolation_student_presence_events_insert; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_student_presence_events_insert ON public.student_presence_events FOR INSERT TO authenticated WITH CHECK ((school_id = auth.get_user_school_id()));


--
-- Name: student_presence_events school_isolation_student_presence_events_select; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_student_presence_events_select ON public.student_presence_events TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: student_presence_events school_isolation_student_presence_events_update; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_student_presence_events_update ON public.student_presence_events TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: student_weekly_pickup_arrangements school_isolation_student_weekly_pickup_arrangements_delete; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_student_weekly_pickup_arrangements_delete ON public.student_weekly_pickup_arrangements TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: student_weekly_pickup_arrangements school_isolation_student_weekly_pickup_arrangements_insert; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_student_weekly_pickup_arrangements_insert ON public.student_weekly_pickup_arrangements FOR INSERT TO authenticated WITH CHECK ((school_id = auth.get_user_school_id()));


--
-- Name: student_weekly_pickup_arrangements school_isolation_student_weekly_pickup_arrangements_select; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_student_weekly_pickup_arrangements_select ON public.student_weekly_pickup_arrangements TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: student_weekly_pickup_arrangements school_isolation_student_weekly_pickup_arrangements_update; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_student_weekly_pickup_arrangements_update ON public.student_weekly_pickup_arrangements TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: subject_class_hours school_isolation_subject_class_hours_delete; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_subject_class_hours_delete ON public.subject_class_hours TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: subject_class_hours school_isolation_subject_class_hours_insert; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_subject_class_hours_insert ON public.subject_class_hours FOR INSERT TO authenticated WITH CHECK ((school_id = auth.get_user_school_id()));


--
-- Name: subject_class_hours school_isolation_subject_class_hours_select; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_subject_class_hours_select ON public.subject_class_hours TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: subject_class_hours school_isolation_subject_class_hours_update; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_subject_class_hours_update ON public.subject_class_hours TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: subject_grade_hours school_isolation_subject_grade_hours_delete; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_subject_grade_hours_delete ON public.subject_grade_hours TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: subject_grade_hours school_isolation_subject_grade_hours_insert; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_subject_grade_hours_insert ON public.subject_grade_hours FOR INSERT TO authenticated WITH CHECK ((school_id = auth.get_user_school_id()));


--
-- Name: subject_grade_hours school_isolation_subject_grade_hours_select; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_subject_grade_hours_select ON public.subject_grade_hours TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: subject_grade_hours school_isolation_subject_grade_hours_update; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_subject_grade_hours_update ON public.subject_grade_hours TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: subjects school_isolation_subjects_delete; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_subjects_delete ON public.subjects TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: subjects school_isolation_subjects_insert; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_subjects_insert ON public.subjects FOR INSERT TO authenticated WITH CHECK ((school_id = auth.get_user_school_id()));


--
-- Name: subjects school_isolation_subjects_select; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_subjects_select ON public.subjects FOR SELECT TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: subjects school_isolation_subjects_update; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_subjects_update ON public.subjects TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: substitutions school_isolation_substitutions_delete; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_substitutions_delete ON public.substitutions TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: substitutions school_isolation_substitutions_insert; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_substitutions_insert ON public.substitutions FOR INSERT TO authenticated WITH CHECK ((school_id = auth.get_user_school_id()));


--
-- Name: substitutions school_isolation_substitutions_select; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_substitutions_select ON public.substitutions TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: substitutions school_isolation_substitutions_update; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_substitutions_update ON public.substitutions TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: structure_schools school_isolation_update; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY school_isolation_update ON public.structure_schools FOR UPDATE TO authenticated USING ((id = auth.get_user_school_id())) WITH CHECK ((id = auth.get_user_school_id()));


--
-- Name: user_codes school_isolation_user_codes_delete; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_user_codes_delete ON public.user_codes TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: user_codes school_isolation_user_codes_insert; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_user_codes_insert ON public.user_codes FOR INSERT TO authenticated WITH CHECK ((school_id = auth.get_user_school_id()));


--
-- Name: user_codes school_isolation_user_codes_select; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_user_codes_select ON public.user_codes TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: user_codes school_isolation_user_codes_update; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_user_codes_update ON public.user_codes TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: user_group_members school_isolation_user_group_members_delete; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_user_group_members_delete ON public.user_group_members TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: user_group_members school_isolation_user_group_members_insert; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_user_group_members_insert ON public.user_group_members FOR INSERT TO authenticated WITH CHECK ((school_id = auth.get_user_school_id()));


--
-- Name: user_group_members school_isolation_user_group_members_select; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_user_group_members_select ON public.user_group_members TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: user_group_members school_isolation_user_group_members_update; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_user_group_members_update ON public.user_group_members TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: user_groups school_isolation_user_groups_delete; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_user_groups_delete ON public.user_groups TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: user_groups school_isolation_user_groups_insert; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_user_groups_insert ON public.user_groups FOR INSERT TO authenticated WITH CHECK ((school_id = auth.get_user_school_id()));


--
-- Name: user_groups school_isolation_user_groups_select; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_user_groups_select ON public.user_groups TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: user_groups school_isolation_user_groups_update; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_user_groups_update ON public.user_groups TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: user_roles school_isolation_user_roles_delete; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_user_roles_delete ON public.user_roles TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: user_roles school_isolation_user_roles_insert; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_user_roles_insert ON public.user_roles FOR INSERT TO authenticated WITH CHECK ((school_id = auth.get_user_school_id()));


--
-- Name: user_roles school_isolation_user_roles_select; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_user_roles_select ON public.user_roles TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: user_roles school_isolation_user_roles_update; Type: POLICY; Schema: public; Owner: supabase_admin
--

CREATE POLICY school_isolation_user_roles_update ON public.user_roles TO authenticated USING ((school_id = auth.get_user_school_id()));


--
-- Name: staff_absence_comments; Type: ROW SECURITY; Schema: public; Owner: supabase_admin
--

ALTER TABLE public.staff_absence_comments ENABLE ROW LEVEL SECURITY;

--
-- Name: staff_absences; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.staff_absences ENABLE ROW LEVEL SECURITY;

--
-- Name: staff_class_links; Type: ROW SECURITY; Schema: public; Owner: supabase_admin
--

ALTER TABLE public.staff_class_links ENABLE ROW LEVEL SECURITY;

--
-- Name: staff_contracts; Type: ROW SECURITY; Schema: public; Owner: supabase_admin
--

ALTER TABLE public.staff_contracts ENABLE ROW LEVEL SECURITY;

--
-- Name: staff_documents; Type: ROW SECURITY; Schema: public; Owner: supabase_admin
--

ALTER TABLE public.staff_documents ENABLE ROW LEVEL SECURITY;

--
-- Name: staff_duty_plan; Type: ROW SECURITY; Schema: public; Owner: supabase_admin
--

ALTER TABLE public.staff_duty_plan ENABLE ROW LEVEL SECURITY;

--
-- Name: staff_subjects; Type: ROW SECURITY; Schema: public; Owner: supabase_admin
--

ALTER TABLE public.staff_subjects ENABLE ROW LEVEL SECURITY;

--
-- Name: staff_work_contracts; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.staff_work_contracts ENABLE ROW LEVEL SECURITY;

--
-- Name: staff_yearly_preferences; Type: ROW SECURITY; Schema: public; Owner: supabase_admin
--

ALTER TABLE public.staff_yearly_preferences ENABLE ROW LEVEL SECURITY;

--
-- Name: structure_classes; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.structure_classes ENABLE ROW LEVEL SECURITY;

--
-- Name: structure_rooms; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.structure_rooms ENABLE ROW LEVEL SECURITY;

--
-- Name: structure_school_days; Type: ROW SECURITY; Schema: public; Owner: supabase_admin
--

ALTER TABLE public.structure_school_days ENABLE ROW LEVEL SECURITY;

--
-- Name: structure_school_semesters; Type: ROW SECURITY; Schema: public; Owner: supabase_admin
--

ALTER TABLE public.structure_school_semesters ENABLE ROW LEVEL SECURITY;

--
-- Name: structure_school_years; Type: ROW SECURITY; Schema: public; Owner: supabase_admin
--

ALTER TABLE public.structure_school_years ENABLE ROW LEVEL SECURITY;

--
-- Name: structure_schools; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.structure_schools ENABLE ROW LEVEL SECURITY;

--
-- Name: student_absence_notes; Type: ROW SECURITY; Schema: public; Owner: supabase_admin
--

ALTER TABLE public.student_absence_notes ENABLE ROW LEVEL SECURITY;

--
-- Name: student_absence_recurrences; Type: ROW SECURITY; Schema: public; Owner: supabase_admin
--

ALTER TABLE public.student_absence_recurrences ENABLE ROW LEVEL SECURITY;

--
-- Name: student_attendance_logs; Type: ROW SECURITY; Schema: public; Owner: supabase_admin
--

ALTER TABLE public.student_attendance_logs ENABLE ROW LEVEL SECURITY;

--
-- Name: student_course_wish_choices; Type: ROW SECURITY; Schema: public; Owner: supabase_admin
--

ALTER TABLE public.student_course_wish_choices ENABLE ROW LEVEL SECURITY;

--
-- Name: student_course_wish_submissions; Type: ROW SECURITY; Schema: public; Owner: supabase_admin
--

ALTER TABLE public.student_course_wish_submissions ENABLE ROW LEVEL SECURITY;

--
-- Name: student_daily_log; Type: ROW SECURITY; Schema: public; Owner: supabase_admin
--

ALTER TABLE public.student_daily_log ENABLE ROW LEVEL SECURITY;

--
-- Name: student_pickup_arrangement_overrides; Type: ROW SECURITY; Schema: public; Owner: supabase_admin
--

ALTER TABLE public.student_pickup_arrangement_overrides ENABLE ROW LEVEL SECURITY;

--
-- Name: student_presence_events; Type: ROW SECURITY; Schema: public; Owner: supabase_admin
--

ALTER TABLE public.student_presence_events ENABLE ROW LEVEL SECURITY;

--
-- Name: student_weekly_pickup_arrangements; Type: ROW SECURITY; Schema: public; Owner: supabase_admin
--

ALTER TABLE public.student_weekly_pickup_arrangements ENABLE ROW LEVEL SECURITY;

--
-- Name: subject_class_hours; Type: ROW SECURITY; Schema: public; Owner: supabase_admin
--

ALTER TABLE public.subject_class_hours ENABLE ROW LEVEL SECURITY;

--
-- Name: subject_grade_hours; Type: ROW SECURITY; Schema: public; Owner: supabase_admin
--

ALTER TABLE public.subject_grade_hours ENABLE ROW LEVEL SECURITY;

--
-- Name: subjects; Type: ROW SECURITY; Schema: public; Owner: supabase_admin
--

ALTER TABLE public.subjects ENABLE ROW LEVEL SECURITY;

--
-- Name: substitutions; Type: ROW SECURITY; Schema: public; Owner: supabase_admin
--

ALTER TABLE public.substitutions ENABLE ROW LEVEL SECURITY;

--
-- Name: user_codes; Type: ROW SECURITY; Schema: public; Owner: supabase_admin
--

ALTER TABLE public.user_codes ENABLE ROW LEVEL SECURITY;

--
-- Name: user_group_members; Type: ROW SECURITY; Schema: public; Owner: supabase_admin
--

ALTER TABLE public.user_group_members ENABLE ROW LEVEL SECURITY;

--
-- Name: user_groups; Type: ROW SECURITY; Schema: public; Owner: supabase_admin
--

ALTER TABLE public.user_groups ENABLE ROW LEVEL SECURITY;

--
-- Name: user_profiles; Type: ROW SECURITY; Schema: public; Owner: postgres
--

ALTER TABLE public.user_profiles ENABLE ROW LEVEL SECURITY;

--
-- Name: user_profiles user_profiles_school_isolation; Type: POLICY; Schema: public; Owner: postgres
--

CREATE POLICY user_profiles_school_isolation ON public.user_profiles TO authenticated USING ((school_id = auth.get_user_school_id())) WITH CHECK ((school_id = auth.get_user_school_id()));


--
-- Name: user_roles; Type: ROW SECURITY; Schema: public; Owner: supabase_admin
--

ALTER TABLE public.user_roles ENABLE ROW LEVEL SECURITY;

--
-- Name: messages Allow listening for broadcasts for authenticated users only; Type: POLICY; Schema: realtime; Owner: supabase_realtime_admin
--

CREATE POLICY "Allow listening for broadcasts for authenticated users only" ON realtime.messages FOR SELECT TO authenticated USING ((extension = 'broadcast'::text));


--
-- Name: messages; Type: ROW SECURITY; Schema: realtime; Owner: supabase_realtime_admin
--

ALTER TABLE realtime.messages ENABLE ROW LEVEL SECURITY;

--
-- Name: objects Allow updates; Type: POLICY; Schema: storage; Owner: supabase_storage_admin
--

CREATE POLICY "Allow updates" ON storage.objects FOR UPDATE USING (true);


--
-- Name: buckets; Type: ROW SECURITY; Schema: storage; Owner: supabase_storage_admin
--

ALTER TABLE storage.buckets ENABLE ROW LEVEL SECURITY;

--
-- Name: objects enforce_school_id_metadata_on_insert; Type: POLICY; Schema: storage; Owner: supabase_storage_admin
--

CREATE POLICY enforce_school_id_metadata_on_insert ON storage.objects FOR INSERT TO authenticated WITH CHECK ((((metadata ->> 'school_id'::text) IS NOT NULL) AND (((metadata ->> 'school_id'::text))::uuid = public.get_user_school_id()) AND (public.get_user_school_id() IS NOT NULL)));


--
-- Name: migrations; Type: ROW SECURITY; Schema: storage; Owner: supabase_storage_admin
--

ALTER TABLE storage.migrations ENABLE ROW LEVEL SECURITY;

--
-- Name: objects; Type: ROW SECURITY; Schema: storage; Owner: supabase_storage_admin
--

ALTER TABLE storage.objects ENABLE ROW LEVEL SECURITY;

--
-- Name: prefixes; Type: ROW SECURITY; Schema: storage; Owner: supabase_storage_admin
--

ALTER TABLE storage.prefixes ENABLE ROW LEVEL SECURITY;

--
-- Name: s3_multipart_uploads; Type: ROW SECURITY; Schema: storage; Owner: supabase_storage_admin
--

ALTER TABLE storage.s3_multipart_uploads ENABLE ROW LEVEL SECURITY;

--
-- Name: s3_multipart_uploads_parts; Type: ROW SECURITY; Schema: storage; Owner: supabase_storage_admin
--

ALTER TABLE storage.s3_multipart_uploads_parts ENABLE ROW LEVEL SECURITY;

--
-- Name: buckets school_isolation_buckets_delete; Type: POLICY; Schema: storage; Owner: supabase_storage_admin
--

CREATE POLICY school_isolation_buckets_delete ON storage.buckets FOR DELETE TO authenticated USING ((auth.get_current_user_school_id() IS NOT NULL));


--
-- Name: buckets school_isolation_buckets_insert; Type: POLICY; Schema: storage; Owner: supabase_storage_admin
--

CREATE POLICY school_isolation_buckets_insert ON storage.buckets FOR INSERT TO authenticated WITH CHECK ((auth.get_current_user_school_id() IS NOT NULL));


--
-- Name: buckets school_isolation_buckets_select; Type: POLICY; Schema: storage; Owner: supabase_storage_admin
--

CREATE POLICY school_isolation_buckets_select ON storage.buckets FOR SELECT TO authenticated USING (true);


--
-- Name: buckets school_isolation_buckets_update; Type: POLICY; Schema: storage; Owner: supabase_storage_admin
--

CREATE POLICY school_isolation_buckets_update ON storage.buckets FOR UPDATE TO authenticated USING ((auth.get_current_user_school_id() IS NOT NULL)) WITH CHECK ((auth.get_current_user_school_id() IS NOT NULL));


--
-- Name: objects school_isolation_objects_delete; Type: POLICY; Schema: storage; Owner: supabase_storage_admin
--

CREATE POLICY school_isolation_objects_delete ON storage.objects FOR DELETE TO authenticated USING ((((metadata ->> 'school_id'::text))::uuid = public.get_user_school_id()));


--
-- Name: objects school_isolation_objects_select; Type: POLICY; Schema: storage; Owner: supabase_storage_admin
--

CREATE POLICY school_isolation_objects_select ON storage.objects FOR SELECT TO authenticated USING (((((metadata ->> 'school_id'::text))::uuid = public.get_user_school_id()) OR ((metadata ->> 'school_id'::text) IS NULL)));


--
-- Name: objects school_isolation_objects_update; Type: POLICY; Schema: storage; Owner: supabase_storage_admin
--

CREATE POLICY school_isolation_objects_update ON storage.objects FOR UPDATE TO authenticated USING (((((metadata ->> 'school_id'::text))::uuid = public.get_user_school_id()) OR ((metadata ->> 'school_id'::text) IS NULL))) WITH CHECK (((((metadata ->> 'school_id'::text))::uuid = public.get_user_school_id()) AND (public.get_user_school_id() IS NOT NULL)));


--
-- Name: supabase_realtime; Type: PUBLICATION; Schema: -; Owner: postgres
--

CREATE PUBLICATION supabase_realtime WITH (publish = 'insert, update, delete, truncate');


ALTER PUBLICATION supabase_realtime OWNER TO postgres;

--
-- Name: supabase_realtime_messages_publication; Type: PUBLICATION; Schema: -; Owner: supabase_admin
--

CREATE PUBLICATION supabase_realtime_messages_publication WITH (publish = 'insert, update, delete, truncate');


ALTER PUBLICATION supabase_realtime_messages_publication OWNER TO supabase_admin;

--
-- Name: supabase_realtime student_attendance_logs; Type: PUBLICATION TABLE; Schema: public; Owner: postgres
--

ALTER PUBLICATION supabase_realtime ADD TABLE ONLY public.student_attendance_logs;


--
-- Name: supabase_realtime student_daily_log; Type: PUBLICATION TABLE; Schema: public; Owner: postgres
--

ALTER PUBLICATION supabase_realtime ADD TABLE ONLY public.student_daily_log;


--
-- Name: supabase_realtime student_presence_events; Type: PUBLICATION TABLE; Schema: public; Owner: postgres
--

ALTER PUBLICATION supabase_realtime ADD TABLE ONLY public.student_presence_events;


--
-- Name: supabase_realtime_messages_publication messages; Type: PUBLICATION TABLE; Schema: realtime; Owner: supabase_admin
--

ALTER PUBLICATION supabase_realtime_messages_publication ADD TABLE ONLY realtime.messages;


--
-- Name: SCHEMA auth; Type: ACL; Schema: -; Owner: supabase_admin
--

GRANT USAGE ON SCHEMA auth TO anon;
GRANT USAGE ON SCHEMA auth TO authenticated;
GRANT USAGE ON SCHEMA auth TO service_role;
GRANT ALL ON SCHEMA auth TO supabase_auth_admin;
GRANT ALL ON SCHEMA auth TO dashboard_user;
GRANT ALL ON SCHEMA auth TO postgres;
GRANT USAGE ON SCHEMA auth TO test_user;


--
-- Name: SCHEMA extensions; Type: ACL; Schema: -; Owner: postgres
--

GRANT USAGE ON SCHEMA extensions TO anon;
GRANT USAGE ON SCHEMA extensions TO authenticated;
GRANT USAGE ON SCHEMA extensions TO service_role;
GRANT ALL ON SCHEMA extensions TO dashboard_user;


--
-- Name: SCHEMA net; Type: ACL; Schema: -; Owner: supabase_admin
--

GRANT USAGE ON SCHEMA net TO supabase_functions_admin;
GRANT USAGE ON SCHEMA net TO postgres;
GRANT USAGE ON SCHEMA net TO anon;
GRANT USAGE ON SCHEMA net TO authenticated;
GRANT USAGE ON SCHEMA net TO service_role;


--
-- Name: SCHEMA public; Type: ACL; Schema: -; Owner: pg_database_owner
--

GRANT USAGE ON SCHEMA public TO postgres;
GRANT USAGE ON SCHEMA public TO anon;
GRANT USAGE ON SCHEMA public TO authenticated;
GRANT USAGE ON SCHEMA public TO service_role;
GRANT USAGE ON SCHEMA public TO test_user;


--
-- Name: SCHEMA realtime; Type: ACL; Schema: -; Owner: supabase_admin
--

GRANT USAGE ON SCHEMA realtime TO postgres;
GRANT USAGE ON SCHEMA realtime TO anon;
GRANT USAGE ON SCHEMA realtime TO authenticated;
GRANT USAGE ON SCHEMA realtime TO service_role;
GRANT ALL ON SCHEMA realtime TO supabase_realtime_admin;


--
-- Name: SCHEMA storage; Type: ACL; Schema: -; Owner: supabase_admin
--

GRANT ALL ON SCHEMA storage TO postgres;
GRANT USAGE ON SCHEMA storage TO anon;
GRANT USAGE ON SCHEMA storage TO authenticated;
GRANT USAGE ON SCHEMA storage TO service_role;
GRANT ALL ON SCHEMA storage TO supabase_storage_admin;
GRANT ALL ON SCHEMA storage TO dashboard_user;


--
-- Name: SCHEMA supabase_functions; Type: ACL; Schema: -; Owner: supabase_admin
--

GRANT USAGE ON SCHEMA supabase_functions TO postgres;
GRANT USAGE ON SCHEMA supabase_functions TO anon;
GRANT USAGE ON SCHEMA supabase_functions TO authenticated;
GRANT USAGE ON SCHEMA supabase_functions TO service_role;
GRANT ALL ON SCHEMA supabase_functions TO supabase_functions_admin;


--
-- Name: SCHEMA vault; Type: ACL; Schema: -; Owner: supabase_admin
--

GRANT USAGE ON SCHEMA vault TO postgres WITH GRANT OPTION;


--
-- Name: FUNCTION email(); Type: ACL; Schema: auth; Owner: supabase_auth_admin
--

GRANT ALL ON FUNCTION auth.email() TO dashboard_user;
GRANT ALL ON FUNCTION auth.email() TO test_user;
GRANT ALL ON FUNCTION auth.email() TO authenticated;


--
-- Name: FUNCTION get_accessible_children(); Type: ACL; Schema: auth; Owner: supabase_admin
--

GRANT ALL ON FUNCTION auth.get_accessible_children() TO authenticated;
GRANT ALL ON FUNCTION auth.get_accessible_children() TO test_user;


--
-- Name: FUNCTION get_accessible_class_ids(); Type: ACL; Schema: auth; Owner: supabase_admin
--

GRANT ALL ON FUNCTION auth.get_accessible_class_ids() TO authenticated;
GRANT ALL ON FUNCTION auth.get_accessible_class_ids() TO test_user;


--
-- Name: FUNCTION get_current_user_school_id(); Type: ACL; Schema: auth; Owner: supabase_admin
--

GRANT ALL ON FUNCTION auth.get_current_user_school_id() TO authenticated;


--
-- Name: FUNCTION get_profile_id(); Type: ACL; Schema: auth; Owner: supabase_admin
--

GRANT ALL ON FUNCTION auth.get_profile_id() TO authenticated;


--
-- Name: FUNCTION get_user_family_ids(); Type: ACL; Schema: auth; Owner: supabase_admin
--

GRANT ALL ON FUNCTION auth.get_user_family_ids() TO authenticated;
GRANT ALL ON FUNCTION auth.get_user_family_ids() TO test_user;


--
-- Name: FUNCTION get_user_role(); Type: ACL; Schema: auth; Owner: supabase_admin
--

GRANT ALL ON FUNCTION auth.get_user_role() TO authenticated;


--
-- Name: FUNCTION get_user_school_id(); Type: ACL; Schema: auth; Owner: supabase_admin
--

GRANT ALL ON FUNCTION auth.get_user_school_id() TO authenticated;
GRANT ALL ON FUNCTION auth.get_user_school_id() TO test_user;
GRANT ALL ON FUNCTION auth.get_user_school_id() TO anon;
GRANT ALL ON FUNCTION auth.get_user_school_id() TO service_role;


--
-- Name: FUNCTION get_user_school_id_safe(); Type: ACL; Schema: auth; Owner: supabase_admin
--

GRANT ALL ON FUNCTION auth.get_user_school_id_safe() TO authenticated;


--
-- Name: FUNCTION jwt(); Type: ACL; Schema: auth; Owner: supabase_auth_admin
--

GRANT ALL ON FUNCTION auth.jwt() TO postgres;
GRANT ALL ON FUNCTION auth.jwt() TO dashboard_user;
GRANT ALL ON FUNCTION auth.jwt() TO test_user;
GRANT ALL ON FUNCTION auth.jwt() TO authenticated;


--
-- Name: FUNCTION role(); Type: ACL; Schema: auth; Owner: supabase_auth_admin
--

GRANT ALL ON FUNCTION auth.role() TO dashboard_user;
GRANT ALL ON FUNCTION auth.role() TO test_user;
GRANT ALL ON FUNCTION auth.role() TO authenticated;


--
-- Name: FUNCTION uid(); Type: ACL; Schema: auth; Owner: supabase_auth_admin
--

GRANT ALL ON FUNCTION auth.uid() TO dashboard_user;
GRANT ALL ON FUNCTION auth.uid() TO test_user;
GRANT ALL ON FUNCTION auth.uid() TO authenticated;


--
-- Name: FUNCTION algorithm_sign(signables text, secret text, algorithm text); Type: ACL; Schema: extensions; Owner: supabase_admin
--

GRANT ALL ON FUNCTION extensions.algorithm_sign(signables text, secret text, algorithm text) TO dashboard_user;
GRANT ALL ON FUNCTION extensions.algorithm_sign(signables text, secret text, algorithm text) TO postgres WITH GRANT OPTION;


--
-- Name: FUNCTION armor(bytea); Type: ACL; Schema: extensions; Owner: supabase_admin
--

GRANT ALL ON FUNCTION extensions.armor(bytea) TO dashboard_user;
GRANT ALL ON FUNCTION extensions.armor(bytea) TO postgres WITH GRANT OPTION;


--
-- Name: FUNCTION armor(bytea, text[], text[]); Type: ACL; Schema: extensions; Owner: supabase_admin
--

GRANT ALL ON FUNCTION extensions.armor(bytea, text[], text[]) TO dashboard_user;
GRANT ALL ON FUNCTION extensions.armor(bytea, text[], text[]) TO postgres WITH GRANT OPTION;


--
-- Name: FUNCTION crypt(text, text); Type: ACL; Schema: extensions; Owner: supabase_admin
--

GRANT ALL ON FUNCTION extensions.crypt(text, text) TO dashboard_user;
GRANT ALL ON FUNCTION extensions.crypt(text, text) TO postgres WITH GRANT OPTION;


--
-- Name: FUNCTION dearmor(text); Type: ACL; Schema: extensions; Owner: supabase_admin
--

GRANT ALL ON FUNCTION extensions.dearmor(text) TO dashboard_user;
GRANT ALL ON FUNCTION extensions.dearmor(text) TO postgres WITH GRANT OPTION;


--
-- Name: FUNCTION decrypt(bytea, bytea, text); Type: ACL; Schema: extensions; Owner: supabase_admin
--

GRANT ALL ON FUNCTION extensions.decrypt(bytea, bytea, text) TO dashboard_user;
GRANT ALL ON FUNCTION extensions.decrypt(bytea, bytea, text) TO postgres WITH GRANT OPTION;


--
-- Name: FUNCTION decrypt_iv(bytea, bytea, bytea, text); Type: ACL; Schema: extensions; Owner: supabase_admin
--

GRANT ALL ON FUNCTION extensions.decrypt_iv(bytea, bytea, bytea, text) TO dashboard_user;
GRANT ALL ON FUNCTION extensions.decrypt_iv(bytea, bytea, bytea, text) TO postgres WITH GRANT OPTION;


--
-- Name: FUNCTION digest(bytea, text); Type: ACL; Schema: extensions; Owner: supabase_admin
--

GRANT ALL ON FUNCTION extensions.digest(bytea, text) TO dashboard_user;
GRANT ALL ON FUNCTION extensions.digest(bytea, text) TO postgres WITH GRANT OPTION;


--
-- Name: FUNCTION digest(text, text); Type: ACL; Schema: extensions; Owner: supabase_admin
--

GRANT ALL ON FUNCTION extensions.digest(text, text) TO dashboard_user;
GRANT ALL ON FUNCTION extensions.digest(text, text) TO postgres WITH GRANT OPTION;


--
-- Name: FUNCTION encrypt(bytea, bytea, text); Type: ACL; Schema: extensions; Owner: supabase_admin
--

GRANT ALL ON FUNCTION extensions.encrypt(bytea, bytea, text) TO dashboard_user;
GRANT ALL ON FUNCTION extensions.encrypt(bytea, bytea, text) TO postgres WITH GRANT OPTION;


--
-- Name: FUNCTION encrypt_iv(bytea, bytea, bytea, text); Type: ACL; Schema: extensions; Owner: supabase_admin
--

GRANT ALL ON FUNCTION extensions.encrypt_iv(bytea, bytea, bytea, text) TO dashboard_user;
GRANT ALL ON FUNCTION extensions.encrypt_iv(bytea, bytea, bytea, text) TO postgres WITH GRANT OPTION;


--
-- Name: FUNCTION gen_random_bytes(integer); Type: ACL; Schema: extensions; Owner: supabase_admin
--

GRANT ALL ON FUNCTION extensions.gen_random_bytes(integer) TO dashboard_user;
GRANT ALL ON FUNCTION extensions.gen_random_bytes(integer) TO postgres WITH GRANT OPTION;


--
-- Name: FUNCTION gen_random_uuid(); Type: ACL; Schema: extensions; Owner: supabase_admin
--

GRANT ALL ON FUNCTION extensions.gen_random_uuid() TO dashboard_user;
GRANT ALL ON FUNCTION extensions.gen_random_uuid() TO postgres WITH GRANT OPTION;


--
-- Name: FUNCTION gen_salt(text); Type: ACL; Schema: extensions; Owner: supabase_admin
--

GRANT ALL ON FUNCTION extensions.gen_salt(text) TO dashboard_user;
GRANT ALL ON FUNCTION extensions.gen_salt(text) TO postgres WITH GRANT OPTION;


--
-- Name: FUNCTION gen_salt(text, integer); Type: ACL; Schema: extensions; Owner: supabase_admin
--

GRANT ALL ON FUNCTION extensions.gen_salt(text, integer) TO dashboard_user;
GRANT ALL ON FUNCTION extensions.gen_salt(text, integer) TO postgres WITH GRANT OPTION;


--
-- Name: FUNCTION grant_pg_cron_access(); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.grant_pg_cron_access() FROM postgres;
GRANT ALL ON FUNCTION extensions.grant_pg_cron_access() TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.grant_pg_cron_access() TO dashboard_user;


--
-- Name: FUNCTION grant_pg_graphql_access(); Type: ACL; Schema: extensions; Owner: supabase_admin
--

GRANT ALL ON FUNCTION extensions.grant_pg_graphql_access() TO postgres WITH GRANT OPTION;


--
-- Name: FUNCTION grant_pg_net_access(); Type: ACL; Schema: extensions; Owner: postgres
--

REVOKE ALL ON FUNCTION extensions.grant_pg_net_access() FROM postgres;
GRANT ALL ON FUNCTION extensions.grant_pg_net_access() TO postgres WITH GRANT OPTION;
GRANT ALL ON FUNCTION extensions.grant_pg_net_access() TO dashboard_user;


--
-- Name: FUNCTION hmac(bytea, bytea, text); Type: ACL; Schema: extensions; Owner: supabase_admin
--

GRANT ALL ON FUNCTION extensions.hmac(bytea, bytea, text) TO dashboard_user;
GRANT ALL ON FUNCTION extensions.hmac(bytea, bytea, text) TO postgres WITH GRANT OPTION;


--
-- Name: FUNCTION hmac(text, text, text); Type: ACL; Schema: extensions; Owner: supabase_admin
--

GRANT ALL ON FUNCTION extensions.hmac(text, text, text) TO dashboard_user;
GRANT ALL ON FUNCTION extensions.hmac(text, text, text) TO postgres WITH GRANT OPTION;


--
-- Name: FUNCTION pg_stat_statements(showtext boolean, OUT userid oid, OUT dbid oid, OUT toplevel boolean, OUT queryid bigint, OUT query text, OUT plans bigint, OUT total_plan_time double precision, OUT min_plan_time double precision, OUT max_plan_time double precision, OUT mean_plan_time double precision, OUT stddev_plan_time double precision, OUT calls bigint, OUT total_exec_time double precision, OUT min_exec_time double precision, OUT max_exec_time double precision, OUT mean_exec_time double precision, OUT stddev_exec_time double precision, OUT rows bigint, OUT shared_blks_hit bigint, OUT shared_blks_read bigint, OUT shared_blks_dirtied bigint, OUT shared_blks_written bigint, OUT local_blks_hit bigint, OUT local_blks_read bigint, OUT local_blks_dirtied bigint, OUT local_blks_written bigint, OUT temp_blks_read bigint, OUT temp_blks_written bigint, OUT blk_read_time double precision, OUT blk_write_time double precision, OUT temp_blk_read_time double precision, OUT temp_blk_write_time double precision, OUT wal_records bigint, OUT wal_fpi bigint, OUT wal_bytes numeric, OUT jit_functions bigint, OUT jit_generation_time double precision, OUT jit_inlining_count bigint, OUT jit_inlining_time double precision, OUT jit_optimization_count bigint, OUT jit_optimization_time double precision, OUT jit_emission_count bigint, OUT jit_emission_time double precision); Type: ACL; Schema: extensions; Owner: supabase_admin
--

GRANT ALL ON FUNCTION extensions.pg_stat_statements(showtext boolean, OUT userid oid, OUT dbid oid, OUT toplevel boolean, OUT queryid bigint, OUT query text, OUT plans bigint, OUT total_plan_time double precision, OUT min_plan_time double precision, OUT max_plan_time double precision, OUT mean_plan_time double precision, OUT stddev_plan_time double precision, OUT calls bigint, OUT total_exec_time double precision, OUT min_exec_time double precision, OUT max_exec_time double precision, OUT mean_exec_time double precision, OUT stddev_exec_time double precision, OUT rows bigint, OUT shared_blks_hit bigint, OUT shared_blks_read bigint, OUT shared_blks_dirtied bigint, OUT shared_blks_written bigint, OUT local_blks_hit bigint, OUT local_blks_read bigint, OUT local_blks_dirtied bigint, OUT local_blks_written bigint, OUT temp_blks_read bigint, OUT temp_blks_written bigint, OUT blk_read_time double precision, OUT blk_write_time double precision, OUT temp_blk_read_time double precision, OUT temp_blk_write_time double precision, OUT wal_records bigint, OUT wal_fpi bigint, OUT wal_bytes numeric, OUT jit_functions bigint, OUT jit_generation_time double precision, OUT jit_inlining_count bigint, OUT jit_inlining_time double precision, OUT jit_optimization_count bigint, OUT jit_optimization_time double precision, OUT jit_emission_count bigint, OUT jit_emission_time double precision) TO postgres WITH GRANT OPTION;


--
-- Name: FUNCTION pg_stat_statements_info(OUT dealloc bigint, OUT stats_reset timestamp with time zone); Type: ACL; Schema: extensions; Owner: supabase_admin
--

GRANT ALL ON FUNCTION extensions.pg_stat_statements_info(OUT dealloc bigint, OUT stats_reset timestamp with time zone) TO postgres WITH GRANT OPTION;


--
-- Name: FUNCTION pg_stat_statements_reset(userid oid, dbid oid, queryid bigint); Type: ACL; Schema: extensions; Owner: supabase_admin
--

GRANT ALL ON FUNCTION extensions.pg_stat_statements_reset(userid oid, dbid oid, queryid bigint) TO postgres WITH GRANT OPTION;


--
-- Name: FUNCTION pgp_armor_headers(text, OUT key text, OUT value text); Type: ACL; Schema: extensions; Owner: supabase_admin
--

GRANT ALL ON FUNCTION extensions.pgp_armor_headers(text, OUT key text, OUT value text) TO dashboard_user;
GRANT ALL ON FUNCTION extensions.pgp_armor_headers(text, OUT key text, OUT value text) TO postgres WITH GRANT OPTION;


--
-- Name: FUNCTION pgp_key_id(bytea); Type: ACL; Schema: extensions; Owner: supabase_admin
--

GRANT ALL ON FUNCTION extensions.pgp_key_id(bytea) TO dashboard_user;
GRANT ALL ON FUNCTION extensions.pgp_key_id(bytea) TO postgres WITH GRANT OPTION;


--
-- Name: FUNCTION pgp_pub_decrypt(bytea, bytea); Type: ACL; Schema: extensions; Owner: supabase_admin
--

GRANT ALL ON FUNCTION extensions.pgp_pub_decrypt(bytea, bytea) TO dashboard_user;
GRANT ALL ON FUNCTION extensions.pgp_pub_decrypt(bytea, bytea) TO postgres WITH GRANT OPTION;


--
-- Name: FUNCTION pgp_pub_decrypt(bytea, bytea, text); Type: ACL; Schema: extensions; Owner: supabase_admin
--

GRANT ALL ON FUNCTION extensions.pgp_pub_decrypt(bytea, bytea, text) TO dashboard_user;
GRANT ALL ON FUNCTION extensions.pgp_pub_decrypt(bytea, bytea, text) TO postgres WITH GRANT OPTION;


--
-- Name: FUNCTION pgp_pub_decrypt(bytea, bytea, text, text); Type: ACL; Schema: extensions; Owner: supabase_admin
--

GRANT ALL ON FUNCTION extensions.pgp_pub_decrypt(bytea, bytea, text, text) TO dashboard_user;
GRANT ALL ON FUNCTION extensions.pgp_pub_decrypt(bytea, bytea, text, text) TO postgres WITH GRANT OPTION;


--
-- Name: FUNCTION pgp_pub_decrypt_bytea(bytea, bytea); Type: ACL; Schema: extensions; Owner: supabase_admin
--

GRANT ALL ON FUNCTION extensions.pgp_pub_decrypt_bytea(bytea, bytea) TO dashboard_user;
GRANT ALL ON FUNCTION extensions.pgp_pub_decrypt_bytea(bytea, bytea) TO postgres WITH GRANT OPTION;


--
-- Name: FUNCTION pgp_pub_decrypt_bytea(bytea, bytea, text); Type: ACL; Schema: extensions; Owner: supabase_admin
--

GRANT ALL ON FUNCTION extensions.pgp_pub_decrypt_bytea(bytea, bytea, text) TO dashboard_user;
GRANT ALL ON FUNCTION extensions.pgp_pub_decrypt_bytea(bytea, bytea, text) TO postgres WITH GRANT OPTION;


--
-- Name: FUNCTION pgp_pub_decrypt_bytea(bytea, bytea, text, text); Type: ACL; Schema: extensions; Owner: supabase_admin
--

GRANT ALL ON FUNCTION extensions.pgp_pub_decrypt_bytea(bytea, bytea, text, text) TO dashboard_user;
GRANT ALL ON FUNCTION extensions.pgp_pub_decrypt_bytea(bytea, bytea, text, text) TO postgres WITH GRANT OPTION;


--
-- Name: FUNCTION pgp_pub_encrypt(text, bytea); Type: ACL; Schema: extensions; Owner: supabase_admin
--

GRANT ALL ON FUNCTION extensions.pgp_pub_encrypt(text, bytea) TO dashboard_user;
GRANT ALL ON FUNCTION extensions.pgp_pub_encrypt(text, bytea) TO postgres WITH GRANT OPTION;


--
-- Name: FUNCTION pgp_pub_encrypt(text, bytea, text); Type: ACL; Schema: extensions; Owner: supabase_admin
--

GRANT ALL ON FUNCTION extensions.pgp_pub_encrypt(text, bytea, text) TO dashboard_user;
GRANT ALL ON FUNCTION extensions.pgp_pub_encrypt(text, bytea, text) TO postgres WITH GRANT OPTION;


--
-- Name: FUNCTION pgp_pub_encrypt_bytea(bytea, bytea); Type: ACL; Schema: extensions; Owner: supabase_admin
--

GRANT ALL ON FUNCTION extensions.pgp_pub_encrypt_bytea(bytea, bytea) TO dashboard_user;
GRANT ALL ON FUNCTION extensions.pgp_pub_encrypt_bytea(bytea, bytea) TO postgres WITH GRANT OPTION;


--
-- Name: FUNCTION pgp_pub_encrypt_bytea(bytea, bytea, text); Type: ACL; Schema: extensions; Owner: supabase_admin
--

GRANT ALL ON FUNCTION extensions.pgp_pub_encrypt_bytea(bytea, bytea, text) TO dashboard_user;
GRANT ALL ON FUNCTION extensions.pgp_pub_encrypt_bytea(bytea, bytea, text) TO postgres WITH GRANT OPTION;


--
-- Name: FUNCTION pgp_sym_decrypt(bytea, text); Type: ACL; Schema: extensions; Owner: supabase_admin
--

GRANT ALL ON FUNCTION extensions.pgp_sym_decrypt(bytea, text) TO dashboard_user;
GRANT ALL ON FUNCTION extensions.pgp_sym_decrypt(bytea, text) TO postgres WITH GRANT OPTION;


--
-- Name: FUNCTION pgp_sym_decrypt(bytea, text, text); Type: ACL; Schema: extensions; Owner: supabase_admin
--

GRANT ALL ON FUNCTION extensions.pgp_sym_decrypt(bytea, text, text) TO dashboard_user;
GRANT ALL ON FUNCTION extensions.pgp_sym_decrypt(bytea, text, text) TO postgres WITH GRANT OPTION;


--
-- Name: FUNCTION pgp_sym_decrypt_bytea(bytea, text); Type: ACL; Schema: extensions; Owner: supabase_admin
--

GRANT ALL ON FUNCTION extensions.pgp_sym_decrypt_bytea(bytea, text) TO dashboard_user;
GRANT ALL ON FUNCTION extensions.pgp_sym_decrypt_bytea(bytea, text) TO postgres WITH GRANT OPTION;


--
-- Name: FUNCTION pgp_sym_decrypt_bytea(bytea, text, text); Type: ACL; Schema: extensions; Owner: supabase_admin
--

GRANT ALL ON FUNCTION extensions.pgp_sym_decrypt_bytea(bytea, text, text) TO dashboard_user;
GRANT ALL ON FUNCTION extensions.pgp_sym_decrypt_bytea(bytea, text, text) TO postgres WITH GRANT OPTION;


--
-- Name: FUNCTION pgp_sym_encrypt(text, text); Type: ACL; Schema: extensions; Owner: supabase_admin
--

GRANT ALL ON FUNCTION extensions.pgp_sym_encrypt(text, text) TO dashboard_user;
GRANT ALL ON FUNCTION extensions.pgp_sym_encrypt(text, text) TO postgres WITH GRANT OPTION;


--
-- Name: FUNCTION pgp_sym_encrypt(text, text, text); Type: ACL; Schema: extensions; Owner: supabase_admin
--

GRANT ALL ON FUNCTION extensions.pgp_sym_encrypt(text, text, text) TO dashboard_user;
GRANT ALL ON FUNCTION extensions.pgp_sym_encrypt(text, text, text) TO postgres WITH GRANT OPTION;


--
-- Name: FUNCTION pgp_sym_encrypt_bytea(bytea, text); Type: ACL; Schema: extensions; Owner: supabase_admin
--

GRANT ALL ON FUNCTION extensions.pgp_sym_encrypt_bytea(bytea, text) TO dashboard_user;
GRANT ALL ON FUNCTION extensions.pgp_sym_encrypt_bytea(bytea, text) TO postgres WITH GRANT OPTION;


--
-- Name: FUNCTION pgp_sym_encrypt_bytea(bytea, text, text); Type: ACL; Schema: extensions; Owner: supabase_admin
--

GRANT ALL ON FUNCTION extensions.pgp_sym_encrypt_bytea(bytea, text, text) TO dashboard_user;
GRANT ALL ON FUNCTION extensions.pgp_sym_encrypt_bytea(bytea, text, text) TO postgres WITH GRANT OPTION;


--
-- Name: FUNCTION pgrst_ddl_watch(); Type: ACL; Schema: extensions; Owner: supabase_admin
--

GRANT ALL ON FUNCTION extensions.pgrst_ddl_watch() TO postgres WITH GRANT OPTION;


--
-- Name: FUNCTION pgrst_drop_watch(); Type: ACL; Schema: extensions; Owner: supabase_admin
--

GRANT ALL ON FUNCTION extensions.pgrst_drop_watch() TO postgres WITH GRANT OPTION;


--
-- Name: FUNCTION set_graphql_placeholder(); Type: ACL; Schema: extensions; Owner: supabase_admin
--

GRANT ALL ON FUNCTION extensions.set_graphql_placeholder() TO postgres WITH GRANT OPTION;


--
-- Name: FUNCTION sign(payload json, secret text, algorithm text); Type: ACL; Schema: extensions; Owner: supabase_admin
--

GRANT ALL ON FUNCTION extensions.sign(payload json, secret text, algorithm text) TO dashboard_user;
GRANT ALL ON FUNCTION extensions.sign(payload json, secret text, algorithm text) TO postgres WITH GRANT OPTION;


--
-- Name: FUNCTION try_cast_double(inp text); Type: ACL; Schema: extensions; Owner: supabase_admin
--

GRANT ALL ON FUNCTION extensions.try_cast_double(inp text) TO dashboard_user;
GRANT ALL ON FUNCTION extensions.try_cast_double(inp text) TO postgres WITH GRANT OPTION;


--
-- Name: FUNCTION url_decode(data text); Type: ACL; Schema: extensions; Owner: supabase_admin
--

GRANT ALL ON FUNCTION extensions.url_decode(data text) TO dashboard_user;
GRANT ALL ON FUNCTION extensions.url_decode(data text) TO postgres WITH GRANT OPTION;


--
-- Name: FUNCTION url_encode(data bytea); Type: ACL; Schema: extensions; Owner: supabase_admin
--

GRANT ALL ON FUNCTION extensions.url_encode(data bytea) TO dashboard_user;
GRANT ALL ON FUNCTION extensions.url_encode(data bytea) TO postgres WITH GRANT OPTION;


--
-- Name: FUNCTION uuid_generate_v1(); Type: ACL; Schema: extensions; Owner: supabase_admin
--

GRANT ALL ON FUNCTION extensions.uuid_generate_v1() TO dashboard_user;
GRANT ALL ON FUNCTION extensions.uuid_generate_v1() TO postgres WITH GRANT OPTION;


--
-- Name: FUNCTION uuid_generate_v1mc(); Type: ACL; Schema: extensions; Owner: supabase_admin
--

GRANT ALL ON FUNCTION extensions.uuid_generate_v1mc() TO dashboard_user;
GRANT ALL ON FUNCTION extensions.uuid_generate_v1mc() TO postgres WITH GRANT OPTION;


--
-- Name: FUNCTION uuid_generate_v3(namespace uuid, name text); Type: ACL; Schema: extensions; Owner: supabase_admin
--

GRANT ALL ON FUNCTION extensions.uuid_generate_v3(namespace uuid, name text) TO dashboard_user;
GRANT ALL ON FUNCTION extensions.uuid_generate_v3(namespace uuid, name text) TO postgres WITH GRANT OPTION;


--
-- Name: FUNCTION uuid_generate_v4(); Type: ACL; Schema: extensions; Owner: supabase_admin
--

GRANT ALL ON FUNCTION extensions.uuid_generate_v4() TO dashboard_user;
GRANT ALL ON FUNCTION extensions.uuid_generate_v4() TO postgres WITH GRANT OPTION;


--
-- Name: FUNCTION uuid_generate_v5(namespace uuid, name text); Type: ACL; Schema: extensions; Owner: supabase_admin
--

GRANT ALL ON FUNCTION extensions.uuid_generate_v5(namespace uuid, name text) TO dashboard_user;
GRANT ALL ON FUNCTION extensions.uuid_generate_v5(namespace uuid, name text) TO postgres WITH GRANT OPTION;


--
-- Name: FUNCTION uuid_nil(); Type: ACL; Schema: extensions; Owner: supabase_admin
--

GRANT ALL ON FUNCTION extensions.uuid_nil() TO dashboard_user;
GRANT ALL ON FUNCTION extensions.uuid_nil() TO postgres WITH GRANT OPTION;


--
-- Name: FUNCTION uuid_ns_dns(); Type: ACL; Schema: extensions; Owner: supabase_admin
--

GRANT ALL ON FUNCTION extensions.uuid_ns_dns() TO dashboard_user;
GRANT ALL ON FUNCTION extensions.uuid_ns_dns() TO postgres WITH GRANT OPTION;


--
-- Name: FUNCTION uuid_ns_oid(); Type: ACL; Schema: extensions; Owner: supabase_admin
--

GRANT ALL ON FUNCTION extensions.uuid_ns_oid() TO dashboard_user;
GRANT ALL ON FUNCTION extensions.uuid_ns_oid() TO postgres WITH GRANT OPTION;


--
-- Name: FUNCTION uuid_ns_url(); Type: ACL; Schema: extensions; Owner: supabase_admin
--

GRANT ALL ON FUNCTION extensions.uuid_ns_url() TO dashboard_user;
GRANT ALL ON FUNCTION extensions.uuid_ns_url() TO postgres WITH GRANT OPTION;


--
-- Name: FUNCTION uuid_ns_x500(); Type: ACL; Schema: extensions; Owner: supabase_admin
--

GRANT ALL ON FUNCTION extensions.uuid_ns_x500() TO dashboard_user;
GRANT ALL ON FUNCTION extensions.uuid_ns_x500() TO postgres WITH GRANT OPTION;


--
-- Name: FUNCTION verify(token text, secret text, algorithm text); Type: ACL; Schema: extensions; Owner: supabase_admin
--

GRANT ALL ON FUNCTION extensions.verify(token text, secret text, algorithm text) TO dashboard_user;
GRANT ALL ON FUNCTION extensions.verify(token text, secret text, algorithm text) TO postgres WITH GRANT OPTION;


--
-- Name: FUNCTION graphql("operationName" text, query text, variables jsonb, extensions jsonb); Type: ACL; Schema: graphql_public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION graphql_public.graphql("operationName" text, query text, variables jsonb, extensions jsonb) TO postgres;
GRANT ALL ON FUNCTION graphql_public.graphql("operationName" text, query text, variables jsonb, extensions jsonb) TO anon;
GRANT ALL ON FUNCTION graphql_public.graphql("operationName" text, query text, variables jsonb, extensions jsonb) TO authenticated;
GRANT ALL ON FUNCTION graphql_public.graphql("operationName" text, query text, variables jsonb, extensions jsonb) TO service_role;


--
-- Name: FUNCTION get_auth(p_usename text); Type: ACL; Schema: pgbouncer; Owner: supabase_admin
--

REVOKE ALL ON FUNCTION pgbouncer.get_auth(p_usename text) FROM PUBLIC;
GRANT ALL ON FUNCTION pgbouncer.get_auth(p_usename text) TO pgbouncer;
GRANT ALL ON FUNCTION pgbouncer.get_auth(p_usename text) TO postgres;


--
-- Name: FUNCTION add_course_note(p_course_id text, p_school_id text, p_registration_period_id text, p_semester_id text, p_day_of_week integer, p_text text, p_author text, p_is_problem boolean); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.add_course_note(p_course_id text, p_school_id text, p_registration_period_id text, p_semester_id text, p_day_of_week integer, p_text text, p_author text, p_is_problem boolean) TO postgres;
GRANT ALL ON FUNCTION public.add_course_note(p_course_id text, p_school_id text, p_registration_period_id text, p_semester_id text, p_day_of_week integer, p_text text, p_author text, p_is_problem boolean) TO anon;
GRANT ALL ON FUNCTION public.add_course_note(p_course_id text, p_school_id text, p_registration_period_id text, p_semester_id text, p_day_of_week integer, p_text text, p_author text, p_is_problem boolean) TO authenticated;
GRANT ALL ON FUNCTION public.add_course_note(p_course_id text, p_school_id text, p_registration_period_id text, p_semester_id text, p_day_of_week integer, p_text text, p_author text, p_is_problem boolean) TO service_role;
GRANT ALL ON FUNCTION public.add_course_note(p_course_id text, p_school_id text, p_registration_period_id text, p_semester_id text, p_day_of_week integer, p_text text, p_author text, p_is_problem boolean) TO test_user;


--
-- Name: FUNCTION add_family_contact_for_all_children(in_family_id uuid, in_first_name text, in_last_name text, in_relationship text, in_authorized_for_pickup boolean, in_user_id uuid); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.add_family_contact_for_all_children(in_family_id uuid, in_first_name text, in_last_name text, in_relationship text, in_authorized_for_pickup boolean, in_user_id uuid) TO postgres;
GRANT ALL ON FUNCTION public.add_family_contact_for_all_children(in_family_id uuid, in_first_name text, in_last_name text, in_relationship text, in_authorized_for_pickup boolean, in_user_id uuid) TO anon;
GRANT ALL ON FUNCTION public.add_family_contact_for_all_children(in_family_id uuid, in_first_name text, in_last_name text, in_relationship text, in_authorized_for_pickup boolean, in_user_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.add_family_contact_for_all_children(in_family_id uuid, in_first_name text, in_last_name text, in_relationship text, in_authorized_for_pickup boolean, in_user_id uuid) TO service_role;
GRANT ALL ON FUNCTION public.add_family_contact_for_all_children(in_family_id uuid, in_first_name text, in_last_name text, in_relationship text, in_authorized_for_pickup boolean, in_user_id uuid) TO test_user;


--
-- Name: FUNCTION add_family_contact_for_all_children(_family_id uuid, _first_name text, _last_name text, _phone text, _relationship text, _authorized_for_pickup boolean); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.add_family_contact_for_all_children(_family_id uuid, _first_name text, _last_name text, _phone text, _relationship text, _authorized_for_pickup boolean) TO postgres;
GRANT ALL ON FUNCTION public.add_family_contact_for_all_children(_family_id uuid, _first_name text, _last_name text, _phone text, _relationship text, _authorized_for_pickup boolean) TO anon;
GRANT ALL ON FUNCTION public.add_family_contact_for_all_children(_family_id uuid, _first_name text, _last_name text, _phone text, _relationship text, _authorized_for_pickup boolean) TO authenticated;
GRANT ALL ON FUNCTION public.add_family_contact_for_all_children(_family_id uuid, _first_name text, _last_name text, _phone text, _relationship text, _authorized_for_pickup boolean) TO service_role;
GRANT ALL ON FUNCTION public.add_family_contact_for_all_children(_family_id uuid, _first_name text, _last_name text, _phone text, _relationship text, _authorized_for_pickup boolean) TO test_user;


--
-- Name: FUNCTION add_family_contact_for_all_children(_family_id uuid, _first_name text, _last_name text, _phone text, _relationship text, _authorized_for_pickup boolean, _child_settings jsonb); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.add_family_contact_for_all_children(_family_id uuid, _first_name text, _last_name text, _phone text, _relationship text, _authorized_for_pickup boolean, _child_settings jsonb) TO postgres;
GRANT ALL ON FUNCTION public.add_family_contact_for_all_children(_family_id uuid, _first_name text, _last_name text, _phone text, _relationship text, _authorized_for_pickup boolean, _child_settings jsonb) TO anon;
GRANT ALL ON FUNCTION public.add_family_contact_for_all_children(_family_id uuid, _first_name text, _last_name text, _phone text, _relationship text, _authorized_for_pickup boolean, _child_settings jsonb) TO authenticated;
GRANT ALL ON FUNCTION public.add_family_contact_for_all_children(_family_id uuid, _first_name text, _last_name text, _phone text, _relationship text, _authorized_for_pickup boolean, _child_settings jsonb) TO service_role;
GRANT ALL ON FUNCTION public.add_family_contact_for_all_children(_family_id uuid, _first_name text, _last_name text, _phone text, _relationship text, _authorized_for_pickup boolean, _child_settings jsonb) TO test_user;


--
-- Name: FUNCTION add_family_contact_for_student(in_student_id uuid, in_family_id uuid, in_first_name text, in_last_name text, in_relationship text, in_authorized_for_pickup boolean, in_user_id uuid); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.add_family_contact_for_student(in_student_id uuid, in_family_id uuid, in_first_name text, in_last_name text, in_relationship text, in_authorized_for_pickup boolean, in_user_id uuid) TO postgres;
GRANT ALL ON FUNCTION public.add_family_contact_for_student(in_student_id uuid, in_family_id uuid, in_first_name text, in_last_name text, in_relationship text, in_authorized_for_pickup boolean, in_user_id uuid) TO anon;
GRANT ALL ON FUNCTION public.add_family_contact_for_student(in_student_id uuid, in_family_id uuid, in_first_name text, in_last_name text, in_relationship text, in_authorized_for_pickup boolean, in_user_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.add_family_contact_for_student(in_student_id uuid, in_family_id uuid, in_first_name text, in_last_name text, in_relationship text, in_authorized_for_pickup boolean, in_user_id uuid) TO service_role;
GRANT ALL ON FUNCTION public.add_family_contact_for_student(in_student_id uuid, in_family_id uuid, in_first_name text, in_last_name text, in_relationship text, in_authorized_for_pickup boolean, in_user_id uuid) TO test_user;


--
-- Name: FUNCTION add_family_contact_for_student(_student_id uuid, _family_id uuid, _first_name text, _last_name text, _phone text, _relationship text, _authorized_for_pickup boolean); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.add_family_contact_for_student(_student_id uuid, _family_id uuid, _first_name text, _last_name text, _phone text, _relationship text, _authorized_for_pickup boolean) TO postgres;
GRANT ALL ON FUNCTION public.add_family_contact_for_student(_student_id uuid, _family_id uuid, _first_name text, _last_name text, _phone text, _relationship text, _authorized_for_pickup boolean) TO anon;
GRANT ALL ON FUNCTION public.add_family_contact_for_student(_student_id uuid, _family_id uuid, _first_name text, _last_name text, _phone text, _relationship text, _authorized_for_pickup boolean) TO authenticated;
GRANT ALL ON FUNCTION public.add_family_contact_for_student(_student_id uuid, _family_id uuid, _first_name text, _last_name text, _phone text, _relationship text, _authorized_for_pickup boolean) TO service_role;
GRANT ALL ON FUNCTION public.add_family_contact_for_student(_student_id uuid, _family_id uuid, _first_name text, _last_name text, _phone text, _relationship text, _authorized_for_pickup boolean) TO test_user;


--
-- Name: FUNCTION add_main_email_contact(p_profile_id uuid, p_email_value character varying); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.add_main_email_contact(p_profile_id uuid, p_email_value character varying) TO postgres;
GRANT ALL ON FUNCTION public.add_main_email_contact(p_profile_id uuid, p_email_value character varying) TO anon;
GRANT ALL ON FUNCTION public.add_main_email_contact(p_profile_id uuid, p_email_value character varying) TO authenticated;
GRANT ALL ON FUNCTION public.add_main_email_contact(p_profile_id uuid, p_email_value character varying) TO service_role;
GRANT ALL ON FUNCTION public.add_main_email_contact(p_profile_id uuid, p_email_value character varying) TO test_user;


--
-- Name: FUNCTION add_schedule_period(p_school_id uuid, p_label text, p_group_label text, p_start_time time without time zone, p_end_time time without time zone, p_block_number integer, p_attendance_requirement text, p_block_type text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.add_schedule_period(p_school_id uuid, p_label text, p_group_label text, p_start_time time without time zone, p_end_time time without time zone, p_block_number integer, p_attendance_requirement text, p_block_type text) TO postgres;
GRANT ALL ON FUNCTION public.add_schedule_period(p_school_id uuid, p_label text, p_group_label text, p_start_time time without time zone, p_end_time time without time zone, p_block_number integer, p_attendance_requirement text, p_block_type text) TO anon;
GRANT ALL ON FUNCTION public.add_schedule_period(p_school_id uuid, p_label text, p_group_label text, p_start_time time without time zone, p_end_time time without time zone, p_block_number integer, p_attendance_requirement text, p_block_type text) TO authenticated;
GRANT ALL ON FUNCTION public.add_schedule_period(p_school_id uuid, p_label text, p_group_label text, p_start_time time without time zone, p_end_time time without time zone, p_block_number integer, p_attendance_requirement text, p_block_type text) TO service_role;
GRANT ALL ON FUNCTION public.add_schedule_period(p_school_id uuid, p_label text, p_group_label text, p_start_time time without time zone, p_end_time time without time zone, p_block_number integer, p_attendance_requirement text, p_block_type text) TO test_user;


--
-- Name: FUNCTION add_student_absence(p_student_id uuid, p_school_id uuid, p_start_date date, p_end_date date, p_absence_type text, p_reason text, p_attachment_url text, p_time_range text, p_duration text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.add_student_absence(p_student_id uuid, p_school_id uuid, p_start_date date, p_end_date date, p_absence_type text, p_reason text, p_attachment_url text, p_time_range text, p_duration text) TO postgres;
GRANT ALL ON FUNCTION public.add_student_absence(p_student_id uuid, p_school_id uuid, p_start_date date, p_end_date date, p_absence_type text, p_reason text, p_attachment_url text, p_time_range text, p_duration text) TO anon;
GRANT ALL ON FUNCTION public.add_student_absence(p_student_id uuid, p_school_id uuid, p_start_date date, p_end_date date, p_absence_type text, p_reason text, p_attachment_url text, p_time_range text, p_duration text) TO authenticated;
GRANT ALL ON FUNCTION public.add_student_absence(p_student_id uuid, p_school_id uuid, p_start_date date, p_end_date date, p_absence_type text, p_reason text, p_attachment_url text, p_time_range text, p_duration text) TO service_role;
GRANT ALL ON FUNCTION public.add_student_absence(p_student_id uuid, p_school_id uuid, p_start_date date, p_end_date date, p_absence_type text, p_reason text, p_attachment_url text, p_time_range text, p_duration text) TO test_user;


--
-- Name: FUNCTION add_student_absence_with_times_and_recurrence(p_student_id uuid, p_school_id uuid, p_absence_date date, p_from_time time without time zone, p_to_time time without time zone, p_reason text, p_excused boolean, p_attachment_url text, p_created_by uuid, p_recurrence jsonb, p_absence_status text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.add_student_absence_with_times_and_recurrence(p_student_id uuid, p_school_id uuid, p_absence_date date, p_from_time time without time zone, p_to_time time without time zone, p_reason text, p_excused boolean, p_attachment_url text, p_created_by uuid, p_recurrence jsonb, p_absence_status text) TO postgres;
GRANT ALL ON FUNCTION public.add_student_absence_with_times_and_recurrence(p_student_id uuid, p_school_id uuid, p_absence_date date, p_from_time time without time zone, p_to_time time without time zone, p_reason text, p_excused boolean, p_attachment_url text, p_created_by uuid, p_recurrence jsonb, p_absence_status text) TO anon;
GRANT ALL ON FUNCTION public.add_student_absence_with_times_and_recurrence(p_student_id uuid, p_school_id uuid, p_absence_date date, p_from_time time without time zone, p_to_time time without time zone, p_reason text, p_excused boolean, p_attachment_url text, p_created_by uuid, p_recurrence jsonb, p_absence_status text) TO authenticated;
GRANT ALL ON FUNCTION public.add_student_absence_with_times_and_recurrence(p_student_id uuid, p_school_id uuid, p_absence_date date, p_from_time time without time zone, p_to_time time without time zone, p_reason text, p_excused boolean, p_attachment_url text, p_created_by uuid, p_recurrence jsonb, p_absence_status text) TO service_role;
GRANT ALL ON FUNCTION public.add_student_absence_with_times_and_recurrence(p_student_id uuid, p_school_id uuid, p_absence_date date, p_from_time time without time zone, p_to_time time without time zone, p_reason text, p_excused boolean, p_attachment_url text, p_created_by uuid, p_recurrence jsonb, p_absence_status text) TO test_user;


--
-- Name: FUNCTION "add_student_absence_with_times_and_recurrence_changed25.08.2025"(p_student_id uuid, p_school_id uuid, p_created_by uuid, p_reason text, p_from_time time without time zone, p_to_time time without time zone, p_absence_date date, p_recurrence jsonb, p_attachment_url text, p_excused boolean); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public."add_student_absence_with_times_and_recurrence_changed25.08.2025"(p_student_id uuid, p_school_id uuid, p_created_by uuid, p_reason text, p_from_time time without time zone, p_to_time time without time zone, p_absence_date date, p_recurrence jsonb, p_attachment_url text, p_excused boolean) TO postgres;
GRANT ALL ON FUNCTION public."add_student_absence_with_times_and_recurrence_changed25.08.2025"(p_student_id uuid, p_school_id uuid, p_created_by uuid, p_reason text, p_from_time time without time zone, p_to_time time without time zone, p_absence_date date, p_recurrence jsonb, p_attachment_url text, p_excused boolean) TO anon;
GRANT ALL ON FUNCTION public."add_student_absence_with_times_and_recurrence_changed25.08.2025"(p_student_id uuid, p_school_id uuid, p_created_by uuid, p_reason text, p_from_time time without time zone, p_to_time time without time zone, p_absence_date date, p_recurrence jsonb, p_attachment_url text, p_excused boolean) TO authenticated;
GRANT ALL ON FUNCTION public."add_student_absence_with_times_and_recurrence_changed25.08.2025"(p_student_id uuid, p_school_id uuid, p_created_by uuid, p_reason text, p_from_time time without time zone, p_to_time time without time zone, p_absence_date date, p_recurrence jsonb, p_attachment_url text, p_excused boolean) TO service_role;
GRANT ALL ON FUNCTION public."add_student_absence_with_times_and_recurrence_changed25.08.2025"(p_student_id uuid, p_school_id uuid, p_created_by uuid, p_reason text, p_from_time time without time zone, p_to_time time without time zone, p_absence_date date, p_recurrence jsonb, p_attachment_url text, p_excused boolean) TO test_user;


--
-- Name: FUNCTION add_student_partial_absence_with_lesson_marking(p_student_id uuid, p_school_id uuid, p_absence_date date, p_from_time time without time zone, p_to_time time without time zone, p_reason text, p_created_by uuid, p_excused boolean); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.add_student_partial_absence_with_lesson_marking(p_student_id uuid, p_school_id uuid, p_absence_date date, p_from_time time without time zone, p_to_time time without time zone, p_reason text, p_created_by uuid, p_excused boolean) TO postgres;
GRANT ALL ON FUNCTION public.add_student_partial_absence_with_lesson_marking(p_student_id uuid, p_school_id uuid, p_absence_date date, p_from_time time without time zone, p_to_time time without time zone, p_reason text, p_created_by uuid, p_excused boolean) TO anon;
GRANT ALL ON FUNCTION public.add_student_partial_absence_with_lesson_marking(p_student_id uuid, p_school_id uuid, p_absence_date date, p_from_time time without time zone, p_to_time time without time zone, p_reason text, p_created_by uuid, p_excused boolean) TO authenticated;
GRANT ALL ON FUNCTION public.add_student_partial_absence_with_lesson_marking(p_student_id uuid, p_school_id uuid, p_absence_date date, p_from_time time without time zone, p_to_time time without time zone, p_reason text, p_created_by uuid, p_excused boolean) TO service_role;
GRANT ALL ON FUNCTION public.add_student_partial_absence_with_lesson_marking(p_student_id uuid, p_school_id uuid, p_absence_date date, p_from_time time without time zone, p_to_time time without time zone, p_reason text, p_created_by uuid, p_excused boolean) TO test_user;


--
-- Name: FUNCTION add_student_partial_absence_with_lesson_marking(p_student_id uuid, p_school_id uuid, p_absence_date date, p_from_time time without time zone, p_to_time time without time zone, p_reason text, p_created_by uuid, p_excused boolean, p_attachment_url text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.add_student_partial_absence_with_lesson_marking(p_student_id uuid, p_school_id uuid, p_absence_date date, p_from_time time without time zone, p_to_time time without time zone, p_reason text, p_created_by uuid, p_excused boolean, p_attachment_url text) TO postgres;
GRANT ALL ON FUNCTION public.add_student_partial_absence_with_lesson_marking(p_student_id uuid, p_school_id uuid, p_absence_date date, p_from_time time without time zone, p_to_time time without time zone, p_reason text, p_created_by uuid, p_excused boolean, p_attachment_url text) TO anon;
GRANT ALL ON FUNCTION public.add_student_partial_absence_with_lesson_marking(p_student_id uuid, p_school_id uuid, p_absence_date date, p_from_time time without time zone, p_to_time time without time zone, p_reason text, p_created_by uuid, p_excused boolean, p_attachment_url text) TO authenticated;
GRANT ALL ON FUNCTION public.add_student_partial_absence_with_lesson_marking(p_student_id uuid, p_school_id uuid, p_absence_date date, p_from_time time without time zone, p_to_time time without time zone, p_reason text, p_created_by uuid, p_excused boolean, p_attachment_url text) TO service_role;
GRANT ALL ON FUNCTION public.add_student_partial_absence_with_lesson_marking(p_student_id uuid, p_school_id uuid, p_absence_date date, p_from_time time without time zone, p_to_time time without time zone, p_reason text, p_created_by uuid, p_excused boolean, p_attachment_url text) TO test_user;


--
-- Name: FUNCTION add_student_to_family(target_student_profile_id uuid, target_family_id uuid); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.add_student_to_family(target_student_profile_id uuid, target_family_id uuid) TO postgres;
GRANT ALL ON FUNCTION public.add_student_to_family(target_student_profile_id uuid, target_family_id uuid) TO anon;
GRANT ALL ON FUNCTION public.add_student_to_family(target_student_profile_id uuid, target_family_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.add_student_to_family(target_student_profile_id uuid, target_family_id uuid) TO service_role;
GRANT ALL ON FUNCTION public.add_student_to_family(target_student_profile_id uuid, target_family_id uuid) TO test_user;


--
-- Name: FUNCTION add_subject_icon(icon_name text, icon_path text, icon_description text, icon_tags text[]); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.add_subject_icon(icon_name text, icon_path text, icon_description text, icon_tags text[]) TO postgres;
GRANT ALL ON FUNCTION public.add_subject_icon(icon_name text, icon_path text, icon_description text, icon_tags text[]) TO anon;
GRANT ALL ON FUNCTION public.add_subject_icon(icon_name text, icon_path text, icon_description text, icon_tags text[]) TO authenticated;
GRANT ALL ON FUNCTION public.add_subject_icon(icon_name text, icon_path text, icon_description text, icon_tags text[]) TO service_role;
GRANT ALL ON FUNCTION public.add_subject_icon(icon_name text, icon_path text, icon_description text, icon_tags text[]) TO test_user;


--
-- Name: FUNCTION add_user_to_group(); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.add_user_to_group() TO postgres;
GRANT ALL ON FUNCTION public.add_user_to_group() TO anon;
GRANT ALL ON FUNCTION public.add_user_to_group() TO authenticated;
GRANT ALL ON FUNCTION public.add_user_to_group() TO service_role;


--
-- Name: FUNCTION add_user_to_group_alt(); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.add_user_to_group_alt() TO postgres;
GRANT ALL ON FUNCTION public.add_user_to_group_alt() TO anon;
GRANT ALL ON FUNCTION public.add_user_to_group_alt() TO authenticated;
GRANT ALL ON FUNCTION public.add_user_to_group_alt() TO service_role;
GRANT ALL ON FUNCTION public.add_user_to_group_alt() TO test_user;


--
-- Name: FUNCTION app_move_student_in_draft(p_registration_period_id uuid, p_semester_id uuid, p_school_id uuid, p_day_of_week smallint, p_student_id uuid, p_target text, p_updated_by uuid); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.app_move_student_in_draft(p_registration_period_id uuid, p_semester_id uuid, p_school_id uuid, p_day_of_week smallint, p_student_id uuid, p_target text, p_updated_by uuid) TO postgres;
GRANT ALL ON FUNCTION public.app_move_student_in_draft(p_registration_period_id uuid, p_semester_id uuid, p_school_id uuid, p_day_of_week smallint, p_student_id uuid, p_target text, p_updated_by uuid) TO anon;
GRANT ALL ON FUNCTION public.app_move_student_in_draft(p_registration_period_id uuid, p_semester_id uuid, p_school_id uuid, p_day_of_week smallint, p_student_id uuid, p_target text, p_updated_by uuid) TO authenticated;
GRANT ALL ON FUNCTION public.app_move_student_in_draft(p_registration_period_id uuid, p_semester_id uuid, p_school_id uuid, p_day_of_week smallint, p_student_id uuid, p_target text, p_updated_by uuid) TO service_role;
GRANT ALL ON FUNCTION public.app_move_student_in_draft(p_registration_period_id uuid, p_semester_id uuid, p_school_id uuid, p_day_of_week smallint, p_student_id uuid, p_target text, p_updated_by uuid) TO test_user;


--
-- Name: FUNCTION assign_main_role(p_user_profile_id uuid, p_role_id uuid); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.assign_main_role(p_user_profile_id uuid, p_role_id uuid) TO postgres;
GRANT ALL ON FUNCTION public.assign_main_role(p_user_profile_id uuid, p_role_id uuid) TO anon;
GRANT ALL ON FUNCTION public.assign_main_role(p_user_profile_id uuid, p_role_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.assign_main_role(p_user_profile_id uuid, p_role_id uuid) TO service_role;
GRANT ALL ON FUNCTION public.assign_main_role(p_user_profile_id uuid, p_role_id uuid) TO test_user;


--
-- Name: FUNCTION assign_substitute(p_lesson_id uuid, p_substitute_staff_ids uuid[], p_absent_teacher_ids uuid[], p_reason text, p_created_by uuid); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.assign_substitute(p_lesson_id uuid, p_substitute_staff_ids uuid[], p_absent_teacher_ids uuid[], p_reason text, p_created_by uuid) TO postgres;
GRANT ALL ON FUNCTION public.assign_substitute(p_lesson_id uuid, p_substitute_staff_ids uuid[], p_absent_teacher_ids uuid[], p_reason text, p_created_by uuid) TO anon;
GRANT ALL ON FUNCTION public.assign_substitute(p_lesson_id uuid, p_substitute_staff_ids uuid[], p_absent_teacher_ids uuid[], p_reason text, p_created_by uuid) TO authenticated;
GRANT ALL ON FUNCTION public.assign_substitute(p_lesson_id uuid, p_substitute_staff_ids uuid[], p_absent_teacher_ids uuid[], p_reason text, p_created_by uuid) TO service_role;
GRANT ALL ON FUNCTION public.assign_substitute(p_lesson_id uuid, p_substitute_staff_ids uuid[], p_absent_teacher_ids uuid[], p_reason text, p_created_by uuid) TO test_user;


--
-- Name: FUNCTION assign_unique_colors_to_classes(class_ids uuid[]); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.assign_unique_colors_to_classes(class_ids uuid[]) TO postgres;
GRANT ALL ON FUNCTION public.assign_unique_colors_to_classes(class_ids uuid[]) TO anon;
GRANT ALL ON FUNCTION public.assign_unique_colors_to_classes(class_ids uuid[]) TO authenticated;
GRANT ALL ON FUNCTION public.assign_unique_colors_to_classes(class_ids uuid[]) TO service_role;
GRANT ALL ON FUNCTION public.assign_unique_colors_to_classes(class_ids uuid[]) TO test_user;


--
-- Name: FUNCTION attempt_role_deletion(p_role_id uuid); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.attempt_role_deletion(p_role_id uuid) TO postgres;
GRANT ALL ON FUNCTION public.attempt_role_deletion(p_role_id uuid) TO anon;
GRANT ALL ON FUNCTION public.attempt_role_deletion(p_role_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.attempt_role_deletion(p_role_id uuid) TO service_role;


--
-- Name: FUNCTION bulk_generate_parent_student_codes(code_requests jsonb[]); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.bulk_generate_parent_student_codes(code_requests jsonb[]) TO postgres;
GRANT ALL ON FUNCTION public.bulk_generate_parent_student_codes(code_requests jsonb[]) TO anon;
GRANT ALL ON FUNCTION public.bulk_generate_parent_student_codes(code_requests jsonb[]) TO authenticated;
GRANT ALL ON FUNCTION public.bulk_generate_parent_student_codes(code_requests jsonb[]) TO service_role;
GRANT ALL ON FUNCTION public.bulk_generate_parent_student_codes(code_requests jsonb[]) TO test_user;


--
-- Name: FUNCTION bulk_get_or_generate_user_codes(profile_ids uuid[]); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.bulk_get_or_generate_user_codes(profile_ids uuid[]) TO postgres;
GRANT ALL ON FUNCTION public.bulk_get_or_generate_user_codes(profile_ids uuid[]) TO anon;
GRANT ALL ON FUNCTION public.bulk_get_or_generate_user_codes(profile_ids uuid[]) TO authenticated;
GRANT ALL ON FUNCTION public.bulk_get_or_generate_user_codes(profile_ids uuid[]) TO service_role;
GRANT ALL ON FUNCTION public.bulk_get_or_generate_user_codes(profile_ids uuid[]) TO test_user;


--
-- Name: FUNCTION bulk_upsert_enrollments_with_logging(p_enrollments jsonb, p_school_id uuid, p_user_id uuid, p_change_group_id uuid); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.bulk_upsert_enrollments_with_logging(p_enrollments jsonb, p_school_id uuid, p_user_id uuid, p_change_group_id uuid) TO postgres;
GRANT ALL ON FUNCTION public.bulk_upsert_enrollments_with_logging(p_enrollments jsonb, p_school_id uuid, p_user_id uuid, p_change_group_id uuid) TO anon;
GRANT ALL ON FUNCTION public.bulk_upsert_enrollments_with_logging(p_enrollments jsonb, p_school_id uuid, p_user_id uuid, p_change_group_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.bulk_upsert_enrollments_with_logging(p_enrollments jsonb, p_school_id uuid, p_user_id uuid, p_change_group_id uuid) TO service_role;
GRANT ALL ON FUNCTION public.bulk_upsert_enrollments_with_logging(p_enrollments jsonb, p_school_id uuid, p_user_id uuid, p_change_group_id uuid) TO test_user;


--
-- Name: FUNCTION bulletin_delete_series(_user_id uuid, _post_id uuid, _change_group_id uuid); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.bulletin_delete_series(_user_id uuid, _post_id uuid, _change_group_id uuid) TO postgres;
GRANT ALL ON FUNCTION public.bulletin_delete_series(_user_id uuid, _post_id uuid, _change_group_id uuid) TO anon;
GRANT ALL ON FUNCTION public.bulletin_delete_series(_user_id uuid, _post_id uuid, _change_group_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.bulletin_delete_series(_user_id uuid, _post_id uuid, _change_group_id uuid) TO service_role;
GRANT ALL ON FUNCTION public.bulletin_delete_series(_user_id uuid, _post_id uuid, _change_group_id uuid) TO test_user;


--
-- Name: FUNCTION bulletin_edit_series(_post_id uuid, _title text, _body text, _display_from timestamp without time zone, _edited_by uuid, _recurrence jsonb, _change_group_id uuid, _is_important boolean, _notify_on_post boolean, _read_required boolean, _visible_users uuid[], _visible_groups uuid[]); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.bulletin_edit_series(_post_id uuid, _title text, _body text, _display_from timestamp without time zone, _edited_by uuid, _recurrence jsonb, _change_group_id uuid, _is_important boolean, _notify_on_post boolean, _read_required boolean, _visible_users uuid[], _visible_groups uuid[]) TO postgres;
GRANT ALL ON FUNCTION public.bulletin_edit_series(_post_id uuid, _title text, _body text, _display_from timestamp without time zone, _edited_by uuid, _recurrence jsonb, _change_group_id uuid, _is_important boolean, _notify_on_post boolean, _read_required boolean, _visible_users uuid[], _visible_groups uuid[]) TO anon;
GRANT ALL ON FUNCTION public.bulletin_edit_series(_post_id uuid, _title text, _body text, _display_from timestamp without time zone, _edited_by uuid, _recurrence jsonb, _change_group_id uuid, _is_important boolean, _notify_on_post boolean, _read_required boolean, _visible_users uuid[], _visible_groups uuid[]) TO authenticated;
GRANT ALL ON FUNCTION public.bulletin_edit_series(_post_id uuid, _title text, _body text, _display_from timestamp without time zone, _edited_by uuid, _recurrence jsonb, _change_group_id uuid, _is_important boolean, _notify_on_post boolean, _read_required boolean, _visible_users uuid[], _visible_groups uuid[]) TO service_role;
GRANT ALL ON FUNCTION public.bulletin_edit_series(_post_id uuid, _title text, _body text, _display_from timestamp without time zone, _edited_by uuid, _recurrence jsonb, _change_group_id uuid, _is_important boolean, _notify_on_post boolean, _read_required boolean, _visible_users uuid[], _visible_groups uuid[]) TO test_user;


--
-- Name: FUNCTION bulletin_post_add(_title text, _body text, _school_id uuid, _created_by uuid, _display_from timestamp without time zone, _change_group_id uuid, _attachments text[], _is_important boolean, _notify_on_post boolean, _is_recurring boolean, _read_required boolean, _visible_users uuid[], _visible_groups uuid[], _add_recurrence jsonb); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.bulletin_post_add(_title text, _body text, _school_id uuid, _created_by uuid, _display_from timestamp without time zone, _change_group_id uuid, _attachments text[], _is_important boolean, _notify_on_post boolean, _is_recurring boolean, _read_required boolean, _visible_users uuid[], _visible_groups uuid[], _add_recurrence jsonb) TO postgres;
GRANT ALL ON FUNCTION public.bulletin_post_add(_title text, _body text, _school_id uuid, _created_by uuid, _display_from timestamp without time zone, _change_group_id uuid, _attachments text[], _is_important boolean, _notify_on_post boolean, _is_recurring boolean, _read_required boolean, _visible_users uuid[], _visible_groups uuid[], _add_recurrence jsonb) TO anon;
GRANT ALL ON FUNCTION public.bulletin_post_add(_title text, _body text, _school_id uuid, _created_by uuid, _display_from timestamp without time zone, _change_group_id uuid, _attachments text[], _is_important boolean, _notify_on_post boolean, _is_recurring boolean, _read_required boolean, _visible_users uuid[], _visible_groups uuid[], _add_recurrence jsonb) TO authenticated;
GRANT ALL ON FUNCTION public.bulletin_post_add(_title text, _body text, _school_id uuid, _created_by uuid, _display_from timestamp without time zone, _change_group_id uuid, _attachments text[], _is_important boolean, _notify_on_post boolean, _is_recurring boolean, _read_required boolean, _visible_users uuid[], _visible_groups uuid[], _add_recurrence jsonb) TO service_role;
GRANT ALL ON FUNCTION public.bulletin_post_add(_title text, _body text, _school_id uuid, _created_by uuid, _display_from timestamp without time zone, _change_group_id uuid, _attachments text[], _is_important boolean, _notify_on_post boolean, _is_recurring boolean, _read_required boolean, _visible_users uuid[], _visible_groups uuid[], _add_recurrence jsonb) TO test_user;


--
-- Name: FUNCTION bulletin_recurrences_generate(p_recurrence_id uuid); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.bulletin_recurrences_generate(p_recurrence_id uuid) TO postgres;
GRANT ALL ON FUNCTION public.bulletin_recurrences_generate(p_recurrence_id uuid) TO anon;
GRANT ALL ON FUNCTION public.bulletin_recurrences_generate(p_recurrence_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.bulletin_recurrences_generate(p_recurrence_id uuid) TO service_role;
GRANT ALL ON FUNCTION public.bulletin_recurrences_generate(p_recurrence_id uuid) TO test_user;


--
-- Name: FUNCTION bulletin_recurrences_generate_daily_consecutive(p_recurrence_id uuid); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.bulletin_recurrences_generate_daily_consecutive(p_recurrence_id uuid) TO postgres;
GRANT ALL ON FUNCTION public.bulletin_recurrences_generate_daily_consecutive(p_recurrence_id uuid) TO anon;
GRANT ALL ON FUNCTION public.bulletin_recurrences_generate_daily_consecutive(p_recurrence_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.bulletin_recurrences_generate_daily_consecutive(p_recurrence_id uuid) TO service_role;
GRANT ALL ON FUNCTION public.bulletin_recurrences_generate_daily_consecutive(p_recurrence_id uuid) TO test_user;


--
-- Name: FUNCTION bulletin_recurrences_generate_daily_on_weekdays(p_recurrence_id uuid); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.bulletin_recurrences_generate_daily_on_weekdays(p_recurrence_id uuid) TO postgres;
GRANT ALL ON FUNCTION public.bulletin_recurrences_generate_daily_on_weekdays(p_recurrence_id uuid) TO anon;
GRANT ALL ON FUNCTION public.bulletin_recurrences_generate_daily_on_weekdays(p_recurrence_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.bulletin_recurrences_generate_daily_on_weekdays(p_recurrence_id uuid) TO service_role;
GRANT ALL ON FUNCTION public.bulletin_recurrences_generate_daily_on_weekdays(p_recurrence_id uuid) TO test_user;


--
-- Name: FUNCTION bulletin_recurrences_generate_monthly(p_recurrence_id uuid); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.bulletin_recurrences_generate_monthly(p_recurrence_id uuid) TO postgres;
GRANT ALL ON FUNCTION public.bulletin_recurrences_generate_monthly(p_recurrence_id uuid) TO anon;
GRANT ALL ON FUNCTION public.bulletin_recurrences_generate_monthly(p_recurrence_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.bulletin_recurrences_generate_monthly(p_recurrence_id uuid) TO service_role;
GRANT ALL ON FUNCTION public.bulletin_recurrences_generate_monthly(p_recurrence_id uuid) TO test_user;


--
-- Name: FUNCTION bulletin_recurrences_generate_weekly(p_recurrence_id uuid); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.bulletin_recurrences_generate_weekly(p_recurrence_id uuid) TO postgres;
GRANT ALL ON FUNCTION public.bulletin_recurrences_generate_weekly(p_recurrence_id uuid) TO anon;
GRANT ALL ON FUNCTION public.bulletin_recurrences_generate_weekly(p_recurrence_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.bulletin_recurrences_generate_weekly(p_recurrence_id uuid) TO service_role;
GRANT ALL ON FUNCTION public.bulletin_recurrences_generate_weekly(p_recurrence_id uuid) TO test_user;


--
-- Name: FUNCTION cad_set_updated_at(); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.cad_set_updated_at() TO postgres;
GRANT ALL ON FUNCTION public.cad_set_updated_at() TO anon;
GRANT ALL ON FUNCTION public.cad_set_updated_at() TO authenticated;
GRANT ALL ON FUNCTION public.cad_set_updated_at() TO service_role;
GRANT ALL ON FUNCTION public.cad_set_updated_at() TO test_user;


--
-- Name: FUNCTION check_bucket_privacy_settings(); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.check_bucket_privacy_settings() TO postgres;
GRANT ALL ON FUNCTION public.check_bucket_privacy_settings() TO anon;
GRANT ALL ON FUNCTION public.check_bucket_privacy_settings() TO authenticated;
GRANT ALL ON FUNCTION public.check_bucket_privacy_settings() TO service_role;


--
-- Name: FUNCTION check_existing_auth_user(p_email text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.check_existing_auth_user(p_email text) TO postgres;
GRANT ALL ON FUNCTION public.check_existing_auth_user(p_email text) TO anon;
GRANT ALL ON FUNCTION public.check_existing_auth_user(p_email text) TO authenticated;
GRANT ALL ON FUNCTION public.check_existing_auth_user(p_email text) TO service_role;
GRANT ALL ON FUNCTION public.check_existing_auth_user(p_email text) TO test_user;


--
-- Name: FUNCTION check_in_student(data jsonb); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.check_in_student(data jsonb) TO postgres;
GRANT ALL ON FUNCTION public.check_in_student(data jsonb) TO anon;
GRANT ALL ON FUNCTION public.check_in_student(data jsonb) TO authenticated;
GRANT ALL ON FUNCTION public.check_in_student(data jsonb) TO service_role;
GRANT ALL ON FUNCTION public.check_in_student(data jsonb) TO test_user;


--
-- Name: FUNCTION cleanup_old_codes(expiry_days integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.cleanup_old_codes(expiry_days integer) TO postgres;
GRANT ALL ON FUNCTION public.cleanup_old_codes(expiry_days integer) TO anon;
GRANT ALL ON FUNCTION public.cleanup_old_codes(expiry_days integer) TO authenticated;
GRANT ALL ON FUNCTION public.cleanup_old_codes(expiry_days integer) TO service_role;
GRANT ALL ON FUNCTION public.cleanup_old_codes(expiry_days integer) TO test_user;


--
-- Name: FUNCTION create_course_secure(_name text, _start_date date, _end_date date, _is_for_year_g integer[], _course_code text, _subject_id uuid, _max_students integer, _description text, _wichtige_infos text, _pictures text[]); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.create_course_secure(_name text, _start_date date, _end_date date, _is_for_year_g integer[], _course_code text, _subject_id uuid, _max_students integer, _description text, _wichtige_infos text, _pictures text[]) TO postgres;
GRANT ALL ON FUNCTION public.create_course_secure(_name text, _start_date date, _end_date date, _is_for_year_g integer[], _course_code text, _subject_id uuid, _max_students integer, _description text, _wichtige_infos text, _pictures text[]) TO anon;
GRANT ALL ON FUNCTION public.create_course_secure(_name text, _start_date date, _end_date date, _is_for_year_g integer[], _course_code text, _subject_id uuid, _max_students integer, _description text, _wichtige_infos text, _pictures text[]) TO authenticated;
GRANT ALL ON FUNCTION public.create_course_secure(_name text, _start_date date, _end_date date, _is_for_year_g integer[], _course_code text, _subject_id uuid, _max_students integer, _description text, _wichtige_infos text, _pictures text[]) TO service_role;
GRANT ALL ON FUNCTION public.create_course_secure(_name text, _start_date date, _end_date date, _is_for_year_g integer[], _course_code text, _subject_id uuid, _max_students integer, _description text, _wichtige_infos text, _pictures text[]) TO test_user;


--
-- Name: FUNCTION create_course_with_options(_user_id uuid, _name text, _course_code text, _subject_id uuid, _max_students integer, _start_date date, _end_date date, _is_for_year_g integer[], _description text, _wichtige_infos text, _pictures text[], _possible_staff_members uuid[], _possible_times text[], _description_visible_to_parents boolean, _possible_room_id uuid); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.create_course_with_options(_user_id uuid, _name text, _course_code text, _subject_id uuid, _max_students integer, _start_date date, _end_date date, _is_for_year_g integer[], _description text, _wichtige_infos text, _pictures text[], _possible_staff_members uuid[], _possible_times text[], _description_visible_to_parents boolean, _possible_room_id uuid) TO postgres;
GRANT ALL ON FUNCTION public.create_course_with_options(_user_id uuid, _name text, _course_code text, _subject_id uuid, _max_students integer, _start_date date, _end_date date, _is_for_year_g integer[], _description text, _wichtige_infos text, _pictures text[], _possible_staff_members uuid[], _possible_times text[], _description_visible_to_parents boolean, _possible_room_id uuid) TO anon;
GRANT ALL ON FUNCTION public.create_course_with_options(_user_id uuid, _name text, _course_code text, _subject_id uuid, _max_students integer, _start_date date, _end_date date, _is_for_year_g integer[], _description text, _wichtige_infos text, _pictures text[], _possible_staff_members uuid[], _possible_times text[], _description_visible_to_parents boolean, _possible_room_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.create_course_with_options(_user_id uuid, _name text, _course_code text, _subject_id uuid, _max_students integer, _start_date date, _end_date date, _is_for_year_g integer[], _description text, _wichtige_infos text, _pictures text[], _possible_staff_members uuid[], _possible_times text[], _description_visible_to_parents boolean, _possible_room_id uuid) TO service_role;
GRANT ALL ON FUNCTION public.create_course_with_options(_user_id uuid, _name text, _course_code text, _subject_id uuid, _max_students integer, _start_date date, _end_date date, _is_for_year_g integer[], _description text, _wichtige_infos text, _pictures text[], _possible_staff_members uuid[], _possible_times text[], _description_visible_to_parents boolean, _possible_room_id uuid) TO test_user;


--
-- Name: FUNCTION create_course_with_options_alt(_user_id uuid, _name text, _course_code text, _subject_id uuid, _max_students integer, _start_date date, _end_date date, _is_for_year_g integer[], _description text, _wichtige_infos text, _pictures text[], _possible_staff_members uuid[], _possible_times text[]); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.create_course_with_options_alt(_user_id uuid, _name text, _course_code text, _subject_id uuid, _max_students integer, _start_date date, _end_date date, _is_for_year_g integer[], _description text, _wichtige_infos text, _pictures text[], _possible_staff_members uuid[], _possible_times text[]) TO postgres;
GRANT ALL ON FUNCTION public.create_course_with_options_alt(_user_id uuid, _name text, _course_code text, _subject_id uuid, _max_students integer, _start_date date, _end_date date, _is_for_year_g integer[], _description text, _wichtige_infos text, _pictures text[], _possible_staff_members uuid[], _possible_times text[]) TO anon;
GRANT ALL ON FUNCTION public.create_course_with_options_alt(_user_id uuid, _name text, _course_code text, _subject_id uuid, _max_students integer, _start_date date, _end_date date, _is_for_year_g integer[], _description text, _wichtige_infos text, _pictures text[], _possible_staff_members uuid[], _possible_times text[]) TO authenticated;
GRANT ALL ON FUNCTION public.create_course_with_options_alt(_user_id uuid, _name text, _course_code text, _subject_id uuid, _max_students integer, _start_date date, _end_date date, _is_for_year_g integer[], _description text, _wichtige_infos text, _pictures text[], _possible_staff_members uuid[], _possible_times text[]) TO service_role;
GRANT ALL ON FUNCTION public.create_course_with_options_alt(_user_id uuid, _name text, _course_code text, _subject_id uuid, _max_students integer, _start_date date, _end_date date, _is_for_year_g integer[], _description text, _wichtige_infos text, _pictures text[], _possible_staff_members uuid[], _possible_times text[]) TO test_user;


--
-- Name: FUNCTION create_course_with_options_alt(_user_id uuid, _name text, _course_code text, _subject_id uuid, _max_students integer, _start_date date, _end_date date, _is_for_year_g integer[], _description text, _wichtige_infos text, _pictures text[], _possible_staff_members uuid[], _possible_times text[], _description_visible_to_parents boolean); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.create_course_with_options_alt(_user_id uuid, _name text, _course_code text, _subject_id uuid, _max_students integer, _start_date date, _end_date date, _is_for_year_g integer[], _description text, _wichtige_infos text, _pictures text[], _possible_staff_members uuid[], _possible_times text[], _description_visible_to_parents boolean) TO postgres;
GRANT ALL ON FUNCTION public.create_course_with_options_alt(_user_id uuid, _name text, _course_code text, _subject_id uuid, _max_students integer, _start_date date, _end_date date, _is_for_year_g integer[], _description text, _wichtige_infos text, _pictures text[], _possible_staff_members uuid[], _possible_times text[], _description_visible_to_parents boolean) TO anon;
GRANT ALL ON FUNCTION public.create_course_with_options_alt(_user_id uuid, _name text, _course_code text, _subject_id uuid, _max_students integer, _start_date date, _end_date date, _is_for_year_g integer[], _description text, _wichtige_infos text, _pictures text[], _possible_staff_members uuid[], _possible_times text[], _description_visible_to_parents boolean) TO authenticated;
GRANT ALL ON FUNCTION public.create_course_with_options_alt(_user_id uuid, _name text, _course_code text, _subject_id uuid, _max_students integer, _start_date date, _end_date date, _is_for_year_g integer[], _description text, _wichtige_infos text, _pictures text[], _possible_staff_members uuid[], _possible_times text[], _description_visible_to_parents boolean) TO service_role;
GRANT ALL ON FUNCTION public.create_course_with_options_alt(_user_id uuid, _name text, _course_code text, _subject_id uuid, _max_students integer, _start_date date, _end_date date, _is_for_year_g integer[], _description text, _wichtige_infos text, _pictures text[], _possible_staff_members uuid[], _possible_times text[], _description_visible_to_parents boolean) TO test_user;


--
-- Name: FUNCTION create_family_and_link_student(in_family_name text, in_student_id uuid, in_user_id uuid); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.create_family_and_link_student(in_family_name text, in_student_id uuid, in_user_id uuid) TO postgres;
GRANT ALL ON FUNCTION public.create_family_and_link_student(in_family_name text, in_student_id uuid, in_user_id uuid) TO anon;
GRANT ALL ON FUNCTION public.create_family_and_link_student(in_family_name text, in_student_id uuid, in_user_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.create_family_and_link_student(in_family_name text, in_student_id uuid, in_user_id uuid) TO service_role;
GRANT ALL ON FUNCTION public.create_family_and_link_student(in_family_name text, in_student_id uuid, in_user_id uuid) TO test_user;


--
-- Name: FUNCTION create_or_update_subject_schedule(_subject_id uuid, _class_id uuid, _period_id uuid, _day_id integer, _room_id uuid, _staff_ids uuid[], _school_id uuid, _start_date date, _end_date date, _start_time time without time zone, _end_time time without time zone); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.create_or_update_subject_schedule(_subject_id uuid, _class_id uuid, _period_id uuid, _day_id integer, _room_id uuid, _staff_ids uuid[], _school_id uuid, _start_date date, _end_date date, _start_time time without time zone, _end_time time without time zone) TO postgres;
GRANT ALL ON FUNCTION public.create_or_update_subject_schedule(_subject_id uuid, _class_id uuid, _period_id uuid, _day_id integer, _room_id uuid, _staff_ids uuid[], _school_id uuid, _start_date date, _end_date date, _start_time time without time zone, _end_time time without time zone) TO anon;
GRANT ALL ON FUNCTION public.create_or_update_subject_schedule(_subject_id uuid, _class_id uuid, _period_id uuid, _day_id integer, _room_id uuid, _staff_ids uuid[], _school_id uuid, _start_date date, _end_date date, _start_time time without time zone, _end_time time without time zone) TO authenticated;
GRANT ALL ON FUNCTION public.create_or_update_subject_schedule(_subject_id uuid, _class_id uuid, _period_id uuid, _day_id integer, _room_id uuid, _staff_ids uuid[], _school_id uuid, _start_date date, _end_date date, _start_time time without time zone, _end_time time without time zone) TO service_role;
GRANT ALL ON FUNCTION public.create_or_update_subject_schedule(_subject_id uuid, _class_id uuid, _period_id uuid, _day_id integer, _room_id uuid, _staff_ids uuid[], _school_id uuid, _start_date date, _end_date date, _start_time time without time zone, _end_time time without time zone) TO test_user;


--
-- Name: FUNCTION create_parent_profile(p_first_name text, p_last_name text, p_school_id uuid, p_contact jsonb); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.create_parent_profile(p_first_name text, p_last_name text, p_school_id uuid, p_contact jsonb) TO postgres;
GRANT ALL ON FUNCTION public.create_parent_profile(p_first_name text, p_last_name text, p_school_id uuid, p_contact jsonb) TO anon;
GRANT ALL ON FUNCTION public.create_parent_profile(p_first_name text, p_last_name text, p_school_id uuid, p_contact jsonb) TO authenticated;
GRANT ALL ON FUNCTION public.create_parent_profile(p_first_name text, p_last_name text, p_school_id uuid, p_contact jsonb) TO service_role;
GRANT ALL ON FUNCTION public.create_parent_profile(p_first_name text, p_last_name text, p_school_id uuid, p_contact jsonb) TO test_user;


--
-- Name: FUNCTION create_registration_period(p_school_id uuid, p_semester_id uuid, p_title text, p_instructions text, p_internal_notes text, p_opens_at timestamp with time zone, p_closes_at timestamp with time zone, p_course_ids uuid[], p_user_id uuid); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.create_registration_period(p_school_id uuid, p_semester_id uuid, p_title text, p_instructions text, p_internal_notes text, p_opens_at timestamp with time zone, p_closes_at timestamp with time zone, p_course_ids uuid[], p_user_id uuid) TO postgres;
GRANT ALL ON FUNCTION public.create_registration_period(p_school_id uuid, p_semester_id uuid, p_title text, p_instructions text, p_internal_notes text, p_opens_at timestamp with time zone, p_closes_at timestamp with time zone, p_course_ids uuid[], p_user_id uuid) TO anon;
GRANT ALL ON FUNCTION public.create_registration_period(p_school_id uuid, p_semester_id uuid, p_title text, p_instructions text, p_internal_notes text, p_opens_at timestamp with time zone, p_closes_at timestamp with time zone, p_course_ids uuid[], p_user_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.create_registration_period(p_school_id uuid, p_semester_id uuid, p_title text, p_instructions text, p_internal_notes text, p_opens_at timestamp with time zone, p_closes_at timestamp with time zone, p_course_ids uuid[], p_user_id uuid) TO service_role;
GRANT ALL ON FUNCTION public.create_registration_period(p_school_id uuid, p_semester_id uuid, p_title text, p_instructions text, p_internal_notes text, p_opens_at timestamp with time zone, p_closes_at timestamp with time zone, p_course_ids uuid[], p_user_id uuid) TO test_user;


--
-- Name: FUNCTION create_registration_period(p_school_id uuid, p_semester_id uuid, p_title text, p_instructions text, p_internal_notes text, p_opens_at timestamp with time zone, p_closes_at timestamp with time zone, p_course_ids uuid[], p_user_id uuid, p_max_wishes_total integer, p_max_wishes_per_day integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.create_registration_period(p_school_id uuid, p_semester_id uuid, p_title text, p_instructions text, p_internal_notes text, p_opens_at timestamp with time zone, p_closes_at timestamp with time zone, p_course_ids uuid[], p_user_id uuid, p_max_wishes_total integer, p_max_wishes_per_day integer) TO postgres;
GRANT ALL ON FUNCTION public.create_registration_period(p_school_id uuid, p_semester_id uuid, p_title text, p_instructions text, p_internal_notes text, p_opens_at timestamp with time zone, p_closes_at timestamp with time zone, p_course_ids uuid[], p_user_id uuid, p_max_wishes_total integer, p_max_wishes_per_day integer) TO anon;
GRANT ALL ON FUNCTION public.create_registration_period(p_school_id uuid, p_semester_id uuid, p_title text, p_instructions text, p_internal_notes text, p_opens_at timestamp with time zone, p_closes_at timestamp with time zone, p_course_ids uuid[], p_user_id uuid, p_max_wishes_total integer, p_max_wishes_per_day integer) TO authenticated;
GRANT ALL ON FUNCTION public.create_registration_period(p_school_id uuid, p_semester_id uuid, p_title text, p_instructions text, p_internal_notes text, p_opens_at timestamp with time zone, p_closes_at timestamp with time zone, p_course_ids uuid[], p_user_id uuid, p_max_wishes_total integer, p_max_wishes_per_day integer) TO service_role;
GRANT ALL ON FUNCTION public.create_registration_period(p_school_id uuid, p_semester_id uuid, p_title text, p_instructions text, p_internal_notes text, p_opens_at timestamp with time zone, p_closes_at timestamp with time zone, p_course_ids uuid[], p_user_id uuid, p_max_wishes_total integer, p_max_wishes_per_day integer) TO test_user;


--
-- Name: FUNCTION create_schedule_and_generate_lessons(_course_id uuid, _day_id integer, _start_date date, _end_date date, _start_time time without time zone, _end_time time without time zone, _teacher_ids uuid[], _room_id uuid, _school_id uuid, _period_id uuid, _period_count integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.create_schedule_and_generate_lessons(_course_id uuid, _day_id integer, _start_date date, _end_date date, _start_time time without time zone, _end_time time without time zone, _teacher_ids uuid[], _room_id uuid, _school_id uuid, _period_id uuid, _period_count integer) TO postgres;
GRANT ALL ON FUNCTION public.create_schedule_and_generate_lessons(_course_id uuid, _day_id integer, _start_date date, _end_date date, _start_time time without time zone, _end_time time without time zone, _teacher_ids uuid[], _room_id uuid, _school_id uuid, _period_id uuid, _period_count integer) TO anon;
GRANT ALL ON FUNCTION public.create_schedule_and_generate_lessons(_course_id uuid, _day_id integer, _start_date date, _end_date date, _start_time time without time zone, _end_time time without time zone, _teacher_ids uuid[], _room_id uuid, _school_id uuid, _period_id uuid, _period_count integer) TO authenticated;
GRANT ALL ON FUNCTION public.create_schedule_and_generate_lessons(_course_id uuid, _day_id integer, _start_date date, _end_date date, _start_time time without time zone, _end_time time without time zone, _teacher_ids uuid[], _room_id uuid, _school_id uuid, _period_id uuid, _period_count integer) TO service_role;
GRANT ALL ON FUNCTION public.create_schedule_and_generate_lessons(_course_id uuid, _day_id integer, _start_date date, _end_date date, _start_time time without time zone, _end_time time without time zone, _teacher_ids uuid[], _room_id uuid, _school_id uuid, _period_id uuid, _period_count integer) TO test_user;


--
-- Name: FUNCTION create_school_year_with_semesters_and_log(_school_id uuid, _label text, _start_date date, _end_date date, _semesters jsonb, _user_id uuid, _reason text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.create_school_year_with_semesters_and_log(_school_id uuid, _label text, _start_date date, _end_date date, _semesters jsonb, _user_id uuid, _reason text) TO postgres;
GRANT ALL ON FUNCTION public.create_school_year_with_semesters_and_log(_school_id uuid, _label text, _start_date date, _end_date date, _semesters jsonb, _user_id uuid, _reason text) TO anon;
GRANT ALL ON FUNCTION public.create_school_year_with_semesters_and_log(_school_id uuid, _label text, _start_date date, _end_date date, _semesters jsonb, _user_id uuid, _reason text) TO authenticated;
GRANT ALL ON FUNCTION public.create_school_year_with_semesters_and_log(_school_id uuid, _label text, _start_date date, _end_date date, _semesters jsonb, _user_id uuid, _reason text) TO service_role;
GRANT ALL ON FUNCTION public.create_school_year_with_semesters_and_log(_school_id uuid, _label text, _start_date date, _end_date date, _semesters jsonb, _user_id uuid, _reason text) TO test_user;


--
-- Name: FUNCTION create_staff_absence(p_staff_id uuid, p_start_date date, p_end_date date, p_start_period integer, p_end_period integer, p_reason text, p_notes text, p_attachment_url text, p_is_approved boolean, p_approved_by uuid, p_created_by uuid, p_substitution_status text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.create_staff_absence(p_staff_id uuid, p_start_date date, p_end_date date, p_start_period integer, p_end_period integer, p_reason text, p_notes text, p_attachment_url text, p_is_approved boolean, p_approved_by uuid, p_created_by uuid, p_substitution_status text) TO postgres;
GRANT ALL ON FUNCTION public.create_staff_absence(p_staff_id uuid, p_start_date date, p_end_date date, p_start_period integer, p_end_period integer, p_reason text, p_notes text, p_attachment_url text, p_is_approved boolean, p_approved_by uuid, p_created_by uuid, p_substitution_status text) TO anon;
GRANT ALL ON FUNCTION public.create_staff_absence(p_staff_id uuid, p_start_date date, p_end_date date, p_start_period integer, p_end_period integer, p_reason text, p_notes text, p_attachment_url text, p_is_approved boolean, p_approved_by uuid, p_created_by uuid, p_substitution_status text) TO authenticated;
GRANT ALL ON FUNCTION public.create_staff_absence(p_staff_id uuid, p_start_date date, p_end_date date, p_start_period integer, p_end_period integer, p_reason text, p_notes text, p_attachment_url text, p_is_approved boolean, p_approved_by uuid, p_created_by uuid, p_substitution_status text) TO service_role;
GRANT ALL ON FUNCTION public.create_staff_absence(p_staff_id uuid, p_start_date date, p_end_date date, p_start_period integer, p_end_period integer, p_reason text, p_notes text, p_attachment_url text, p_is_approved boolean, p_approved_by uuid, p_created_by uuid, p_substitution_status text) TO test_user;


--
-- Name: FUNCTION create_staff_member(_school_id uuid, _semester_id uuid, _role_id uuid, _data jsonb, OUT created_user_profile_id uuid, OUT created_staff_profile_id uuid, OUT created_preference_id uuid); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.create_staff_member(_school_id uuid, _semester_id uuid, _role_id uuid, _data jsonb, OUT created_user_profile_id uuid, OUT created_staff_profile_id uuid, OUT created_preference_id uuid) TO postgres;
GRANT ALL ON FUNCTION public.create_staff_member(_school_id uuid, _semester_id uuid, _role_id uuid, _data jsonb, OUT created_user_profile_id uuid, OUT created_staff_profile_id uuid, OUT created_preference_id uuid) TO anon;
GRANT ALL ON FUNCTION public.create_staff_member(_school_id uuid, _semester_id uuid, _role_id uuid, _data jsonb, OUT created_user_profile_id uuid, OUT created_staff_profile_id uuid, OUT created_preference_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.create_staff_member(_school_id uuid, _semester_id uuid, _role_id uuid, _data jsonb, OUT created_user_profile_id uuid, OUT created_staff_profile_id uuid, OUT created_preference_id uuid) TO service_role;
GRANT ALL ON FUNCTION public.create_staff_member(_school_id uuid, _semester_id uuid, _role_id uuid, _data jsonb, OUT created_user_profile_id uuid, OUT created_staff_profile_id uuid, OUT created_preference_id uuid) TO test_user;


--
-- Name: FUNCTION create_standard_pickup_rules(p_student_id uuid, p_school_id uuid, p_rules jsonb, p_valid_from date, p_created_by uuid, p_valid_until date); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.create_standard_pickup_rules(p_student_id uuid, p_school_id uuid, p_rules jsonb, p_valid_from date, p_created_by uuid, p_valid_until date) TO postgres;
GRANT ALL ON FUNCTION public.create_standard_pickup_rules(p_student_id uuid, p_school_id uuid, p_rules jsonb, p_valid_from date, p_created_by uuid, p_valid_until date) TO anon;
GRANT ALL ON FUNCTION public.create_standard_pickup_rules(p_student_id uuid, p_school_id uuid, p_rules jsonb, p_valid_from date, p_created_by uuid, p_valid_until date) TO authenticated;
GRANT ALL ON FUNCTION public.create_standard_pickup_rules(p_student_id uuid, p_school_id uuid, p_rules jsonb, p_valid_from date, p_created_by uuid, p_valid_until date) TO service_role;
GRANT ALL ON FUNCTION public.create_standard_pickup_rules(p_student_id uuid, p_school_id uuid, p_rules jsonb, p_valid_from date, p_created_by uuid, p_valid_until date) TO test_user;


--
-- Name: FUNCTION delete_course_by_id(p_course_id uuid, p_user_id uuid, p_school_id uuid); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.delete_course_by_id(p_course_id uuid, p_user_id uuid, p_school_id uuid) TO postgres;
GRANT ALL ON FUNCTION public.delete_course_by_id(p_course_id uuid, p_user_id uuid, p_school_id uuid) TO anon;
GRANT ALL ON FUNCTION public.delete_course_by_id(p_course_id uuid, p_user_id uuid, p_school_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.delete_course_by_id(p_course_id uuid, p_user_id uuid, p_school_id uuid) TO service_role;
GRANT ALL ON FUNCTION public.delete_course_by_id(p_course_id uuid, p_user_id uuid, p_school_id uuid) TO test_user;


--
-- Name: FUNCTION delete_my_school_days(); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.delete_my_school_days() TO postgres;
GRANT ALL ON FUNCTION public.delete_my_school_days() TO anon;
GRANT ALL ON FUNCTION public.delete_my_school_days() TO authenticated;
GRANT ALL ON FUNCTION public.delete_my_school_days() TO service_role;
GRANT ALL ON FUNCTION public.delete_my_school_days() TO test_user;


--
-- Name: FUNCTION delete_staff_absence(p_absence_id uuid, p_user_id uuid); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.delete_staff_absence(p_absence_id uuid, p_user_id uuid) TO postgres;
GRANT ALL ON FUNCTION public.delete_staff_absence(p_absence_id uuid, p_user_id uuid) TO anon;
GRANT ALL ON FUNCTION public.delete_staff_absence(p_absence_id uuid, p_user_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.delete_staff_absence(p_absence_id uuid, p_user_id uuid) TO service_role;
GRANT ALL ON FUNCTION public.delete_staff_absence(p_absence_id uuid, p_user_id uuid) TO test_user;


--
-- Name: FUNCTION delete_student_absence_with_cleanup(p_absence_note_id uuid, p_school_id uuid, p_deleted_by uuid, p_deletion_reason text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.delete_student_absence_with_cleanup(p_absence_note_id uuid, p_school_id uuid, p_deleted_by uuid, p_deletion_reason text) TO postgres;
GRANT ALL ON FUNCTION public.delete_student_absence_with_cleanup(p_absence_note_id uuid, p_school_id uuid, p_deleted_by uuid, p_deletion_reason text) TO anon;
GRANT ALL ON FUNCTION public.delete_student_absence_with_cleanup(p_absence_note_id uuid, p_school_id uuid, p_deleted_by uuid, p_deletion_reason text) TO authenticated;
GRANT ALL ON FUNCTION public.delete_student_absence_with_cleanup(p_absence_note_id uuid, p_school_id uuid, p_deleted_by uuid, p_deletion_reason text) TO service_role;
GRANT ALL ON FUNCTION public.delete_student_absence_with_cleanup(p_absence_note_id uuid, p_school_id uuid, p_deleted_by uuid, p_deletion_reason text) TO test_user;


--
-- Name: FUNCTION delete_user_refresh_tokens(user_email text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.delete_user_refresh_tokens(user_email text) TO postgres;
GRANT ALL ON FUNCTION public.delete_user_refresh_tokens(user_email text) TO anon;
GRANT ALL ON FUNCTION public.delete_user_refresh_tokens(user_email text) TO authenticated;
GRANT ALL ON FUNCTION public.delete_user_refresh_tokens(user_email text) TO service_role;
GRANT ALL ON FUNCTION public.delete_user_refresh_tokens(user_email text) TO test_user;


--
-- Name: FUNCTION demo_simplified_pickup_system(p_demo_student_id uuid); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.demo_simplified_pickup_system(p_demo_student_id uuid) TO postgres;
GRANT ALL ON FUNCTION public.demo_simplified_pickup_system(p_demo_student_id uuid) TO anon;
GRANT ALL ON FUNCTION public.demo_simplified_pickup_system(p_demo_student_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.demo_simplified_pickup_system(p_demo_student_id uuid) TO service_role;
GRANT ALL ON FUNCTION public.demo_simplified_pickup_system(p_demo_student_id uuid) TO test_user;


--
-- Name: FUNCTION edit_bulletin_post_instance(_post_id uuid, _title text, _body text, _display_from timestamp without time zone, _edited_by uuid, _attachments text[], _is_important boolean, _notify_on_post boolean, _read_required boolean, _visible_users uuid[], _visible_groups uuid[]); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.edit_bulletin_post_instance(_post_id uuid, _title text, _body text, _display_from timestamp without time zone, _edited_by uuid, _attachments text[], _is_important boolean, _notify_on_post boolean, _read_required boolean, _visible_users uuid[], _visible_groups uuid[]) TO postgres;
GRANT ALL ON FUNCTION public.edit_bulletin_post_instance(_post_id uuid, _title text, _body text, _display_from timestamp without time zone, _edited_by uuid, _attachments text[], _is_important boolean, _notify_on_post boolean, _read_required boolean, _visible_users uuid[], _visible_groups uuid[]) TO anon;
GRANT ALL ON FUNCTION public.edit_bulletin_post_instance(_post_id uuid, _title text, _body text, _display_from timestamp without time zone, _edited_by uuid, _attachments text[], _is_important boolean, _notify_on_post boolean, _read_required boolean, _visible_users uuid[], _visible_groups uuid[]) TO authenticated;
GRANT ALL ON FUNCTION public.edit_bulletin_post_instance(_post_id uuid, _title text, _body text, _display_from timestamp without time zone, _edited_by uuid, _attachments text[], _is_important boolean, _notify_on_post boolean, _read_required boolean, _visible_users uuid[], _visible_groups uuid[]) TO service_role;
GRANT ALL ON FUNCTION public.edit_bulletin_post_instance(_post_id uuid, _title text, _body text, _display_from timestamp without time zone, _edited_by uuid, _attachments text[], _is_important boolean, _notify_on_post boolean, _read_required boolean, _visible_users uuid[], _visible_groups uuid[]) TO test_user;


--
-- Name: FUNCTION edit_student_absence(p_absence_id uuid, p_school_id uuid, p_start_date date, p_end_date date, p_absence_type text, p_reason text, p_attachment_url text, p_time_range text, p_duration text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.edit_student_absence(p_absence_id uuid, p_school_id uuid, p_start_date date, p_end_date date, p_absence_type text, p_reason text, p_attachment_url text, p_time_range text, p_duration text) TO postgres;
GRANT ALL ON FUNCTION public.edit_student_absence(p_absence_id uuid, p_school_id uuid, p_start_date date, p_end_date date, p_absence_type text, p_reason text, p_attachment_url text, p_time_range text, p_duration text) TO anon;
GRANT ALL ON FUNCTION public.edit_student_absence(p_absence_id uuid, p_school_id uuid, p_start_date date, p_end_date date, p_absence_type text, p_reason text, p_attachment_url text, p_time_range text, p_duration text) TO authenticated;
GRANT ALL ON FUNCTION public.edit_student_absence(p_absence_id uuid, p_school_id uuid, p_start_date date, p_end_date date, p_absence_type text, p_reason text, p_attachment_url text, p_time_range text, p_duration text) TO service_role;
GRANT ALL ON FUNCTION public.edit_student_absence(p_absence_id uuid, p_school_id uuid, p_start_date date, p_end_date date, p_absence_type text, p_reason text, p_attachment_url text, p_time_range text, p_duration text) TO test_user;


--
-- Name: FUNCTION finalize_lesson_substitutions(p_lesson_id uuid, p_user_id uuid, p_notes text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.finalize_lesson_substitutions(p_lesson_id uuid, p_user_id uuid, p_notes text) TO postgres;
GRANT ALL ON FUNCTION public.finalize_lesson_substitutions(p_lesson_id uuid, p_user_id uuid, p_notes text) TO anon;
GRANT ALL ON FUNCTION public.finalize_lesson_substitutions(p_lesson_id uuid, p_user_id uuid, p_notes text) TO authenticated;
GRANT ALL ON FUNCTION public.finalize_lesson_substitutions(p_lesson_id uuid, p_user_id uuid, p_notes text) TO service_role;
GRANT ALL ON FUNCTION public.finalize_lesson_substitutions(p_lesson_id uuid, p_user_id uuid, p_notes text) TO test_user;


--
-- Name: FUNCTION generate_random_code(); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.generate_random_code() TO postgres;
GRANT ALL ON FUNCTION public.generate_random_code() TO anon;
GRANT ALL ON FUNCTION public.generate_random_code() TO authenticated;
GRANT ALL ON FUNCTION public.generate_random_code() TO service_role;
GRANT ALL ON FUNCTION public.generate_random_code() TO test_user;


--
-- Name: FUNCTION generate_user_code(p_profile_id uuid, p_code_instance integer, p_created_by uuid, p_notes text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.generate_user_code(p_profile_id uuid, p_code_instance integer, p_created_by uuid, p_notes text) TO postgres;
GRANT ALL ON FUNCTION public.generate_user_code(p_profile_id uuid, p_code_instance integer, p_created_by uuid, p_notes text) TO anon;
GRANT ALL ON FUNCTION public.generate_user_code(p_profile_id uuid, p_code_instance integer, p_created_by uuid, p_notes text) TO authenticated;
GRANT ALL ON FUNCTION public.generate_user_code(p_profile_id uuid, p_code_instance integer, p_created_by uuid, p_notes text) TO service_role;
GRANT ALL ON FUNCTION public.generate_user_code(p_profile_id uuid, p_code_instance integer, p_created_by uuid, p_notes text) TO test_user;


--
-- Name: FUNCTION get_all_policies(); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.get_all_policies() TO postgres;
GRANT ALL ON FUNCTION public.get_all_policies() TO anon;
GRANT ALL ON FUNCTION public.get_all_policies() TO authenticated;
GRANT ALL ON FUNCTION public.get_all_policies() TO service_role;


--
-- Name: FUNCTION get_bucket_privacy_summary(); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.get_bucket_privacy_summary() TO postgres;
GRANT ALL ON FUNCTION public.get_bucket_privacy_summary() TO anon;
GRANT ALL ON FUNCTION public.get_bucket_privacy_summary() TO authenticated;
GRANT ALL ON FUNCTION public.get_bucket_privacy_summary() TO service_role;


--
-- Name: FUNCTION get_current_user_children(); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.get_current_user_children() TO postgres;
GRANT ALL ON FUNCTION public.get_current_user_children() TO anon;
GRANT ALL ON FUNCTION public.get_current_user_children() TO authenticated;
GRANT ALL ON FUNCTION public.get_current_user_children() TO service_role;


--
-- Name: FUNCTION get_current_user_family_ids(); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.get_current_user_family_ids() TO postgres;
GRANT ALL ON FUNCTION public.get_current_user_family_ids() TO anon;
GRANT ALL ON FUNCTION public.get_current_user_family_ids() TO authenticated;
GRANT ALL ON FUNCTION public.get_current_user_family_ids() TO service_role;


--
-- Name: FUNCTION get_or_create_family(p_parent_profile_id uuid, p_student_profile_id uuid, p_school_id uuid, p_family_name text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.get_or_create_family(p_parent_profile_id uuid, p_student_profile_id uuid, p_school_id uuid, p_family_name text) TO postgres;
GRANT ALL ON FUNCTION public.get_or_create_family(p_parent_profile_id uuid, p_student_profile_id uuid, p_school_id uuid, p_family_name text) TO anon;
GRANT ALL ON FUNCTION public.get_or_create_family(p_parent_profile_id uuid, p_student_profile_id uuid, p_school_id uuid, p_family_name text) TO authenticated;
GRANT ALL ON FUNCTION public.get_or_create_family(p_parent_profile_id uuid, p_student_profile_id uuid, p_school_id uuid, p_family_name text) TO service_role;
GRANT ALL ON FUNCTION public.get_or_create_family(p_parent_profile_id uuid, p_student_profile_id uuid, p_school_id uuid, p_family_name text) TO test_user;


--
-- Name: FUNCTION get_or_generate_user_code(profile_id uuid, code_instance integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.get_or_generate_user_code(profile_id uuid, code_instance integer) TO postgres;
GRANT ALL ON FUNCTION public.get_or_generate_user_code(profile_id uuid, code_instance integer) TO anon;
GRANT ALL ON FUNCTION public.get_or_generate_user_code(profile_id uuid, code_instance integer) TO authenticated;
GRANT ALL ON FUNCTION public.get_or_generate_user_code(profile_id uuid, code_instance integer) TO service_role;
GRANT ALL ON FUNCTION public.get_or_generate_user_code(profile_id uuid, code_instance integer) TO test_user;


--
-- Name: FUNCTION get_random_class_color(); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.get_random_class_color() TO postgres;
GRANT ALL ON FUNCTION public.get_random_class_color() TO anon;
GRANT ALL ON FUNCTION public.get_random_class_color() TO authenticated;
GRANT ALL ON FUNCTION public.get_random_class_color() TO service_role;
GRANT ALL ON FUNCTION public.get_random_class_color() TO test_user;


--
-- Name: FUNCTION get_role_protection_summary(); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.get_role_protection_summary() TO postgres;
GRANT ALL ON FUNCTION public.get_role_protection_summary() TO anon;
GRANT ALL ON FUNCTION public.get_role_protection_summary() TO authenticated;
GRANT ALL ON FUNCTION public.get_role_protection_summary() TO service_role;


--
-- Name: FUNCTION get_role_usage_count(p_role_id uuid); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.get_role_usage_count(p_role_id uuid) TO postgres;
GRANT ALL ON FUNCTION public.get_role_usage_count(p_role_id uuid) TO anon;
GRANT ALL ON FUNCTION public.get_role_usage_count(p_role_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.get_role_usage_count(p_role_id uuid) TO service_role;


--
-- Name: FUNCTION get_storage_rls_policies(); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.get_storage_rls_policies() TO postgres;
GRANT ALL ON FUNCTION public.get_storage_rls_policies() TO anon;
GRANT ALL ON FUNCTION public.get_storage_rls_policies() TO authenticated;
GRANT ALL ON FUNCTION public.get_storage_rls_policies() TO service_role;


--
-- Name: FUNCTION get_student_interview_submission(p_student_id uuid, p_registration_period_id uuid); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.get_student_interview_submission(p_student_id uuid, p_registration_period_id uuid) TO postgres;
GRANT ALL ON FUNCTION public.get_student_interview_submission(p_student_id uuid, p_registration_period_id uuid) TO anon;
GRANT ALL ON FUNCTION public.get_student_interview_submission(p_student_id uuid, p_registration_period_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.get_student_interview_submission(p_student_id uuid, p_registration_period_id uuid) TO service_role;
GRANT ALL ON FUNCTION public.get_student_interview_submission(p_student_id uuid, p_registration_period_id uuid) TO test_user;


--
-- Name: FUNCTION get_table_policies(table_name text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.get_table_policies(table_name text) TO postgres;
GRANT ALL ON FUNCTION public.get_table_policies(table_name text) TO anon;
GRANT ALL ON FUNCTION public.get_table_policies(table_name text) TO authenticated;
GRANT ALL ON FUNCTION public.get_table_policies(table_name text) TO service_role;


--
-- Name: FUNCTION get_tables_with_policies(); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.get_tables_with_policies() TO postgres;
GRANT ALL ON FUNCTION public.get_tables_with_policies() TO anon;
GRANT ALL ON FUNCTION public.get_tables_with_policies() TO authenticated;
GRANT ALL ON FUNCTION public.get_tables_with_policies() TO service_role;


--
-- Name: FUNCTION get_unresolved_problems(p_school_id text, p_registration_period_id text, p_semester_id text, p_day_of_week integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.get_unresolved_problems(p_school_id text, p_registration_period_id text, p_semester_id text, p_day_of_week integer) TO postgres;
GRANT ALL ON FUNCTION public.get_unresolved_problems(p_school_id text, p_registration_period_id text, p_semester_id text, p_day_of_week integer) TO anon;
GRANT ALL ON FUNCTION public.get_unresolved_problems(p_school_id text, p_registration_period_id text, p_semester_id text, p_day_of_week integer) TO authenticated;
GRANT ALL ON FUNCTION public.get_unresolved_problems(p_school_id text, p_registration_period_id text, p_semester_id text, p_day_of_week integer) TO service_role;
GRANT ALL ON FUNCTION public.get_unresolved_problems(p_school_id text, p_registration_period_id text, p_semester_id text, p_day_of_week integer) TO test_user;


--
-- Name: FUNCTION get_user_children_optimized(user_id uuid); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.get_user_children_optimized(user_id uuid) TO postgres;
GRANT ALL ON FUNCTION public.get_user_children_optimized(user_id uuid) TO anon;
GRANT ALL ON FUNCTION public.get_user_children_optimized(user_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.get_user_children_optimized(user_id uuid) TO service_role;


--
-- Name: FUNCTION get_user_family_ids(); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.get_user_family_ids() TO postgres;
GRANT ALL ON FUNCTION public.get_user_family_ids() TO anon;
GRANT ALL ON FUNCTION public.get_user_family_ids() TO authenticated;
GRANT ALL ON FUNCTION public.get_user_family_ids() TO service_role;
GRANT ALL ON FUNCTION public.get_user_family_ids() TO test_user;


--
-- Name: FUNCTION get_user_family_ids_optimized(user_id uuid); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.get_user_family_ids_optimized(user_id uuid) TO postgres;
GRANT ALL ON FUNCTION public.get_user_family_ids_optimized(user_id uuid) TO anon;
GRANT ALL ON FUNCTION public.get_user_family_ids_optimized(user_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.get_user_family_ids_optimized(user_id uuid) TO service_role;


--
-- Name: FUNCTION get_user_profile_by_code(input_code character varying); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.get_user_profile_by_code(input_code character varying) TO postgres;
GRANT ALL ON FUNCTION public.get_user_profile_by_code(input_code character varying) TO anon;
GRANT ALL ON FUNCTION public.get_user_profile_by_code(input_code character varying) TO authenticated;
GRANT ALL ON FUNCTION public.get_user_profile_by_code(input_code character varying) TO service_role;
GRANT ALL ON FUNCTION public.get_user_profile_by_code(input_code character varying) TO test_user;


--
-- Name: FUNCTION get_user_school_id(); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.get_user_school_id() TO postgres;
GRANT ALL ON FUNCTION public.get_user_school_id() TO anon;
GRANT ALL ON FUNCTION public.get_user_school_id() TO authenticated;
GRANT ALL ON FUNCTION public.get_user_school_id() TO service_role;


--
-- Name: FUNCTION handle_new_user(); Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON FUNCTION public.handle_new_user() TO anon;
GRANT ALL ON FUNCTION public.handle_new_user() TO authenticated;
GRANT ALL ON FUNCTION public.handle_new_user() TO service_role;
GRANT ALL ON FUNCTION public.handle_new_user() TO test_user;


--
-- Name: FUNCTION import_selected_holidays_to_calendar(school_id uuid, selected_ids uuid[]); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.import_selected_holidays_to_calendar(school_id uuid, selected_ids uuid[]) TO postgres;
GRANT ALL ON FUNCTION public.import_selected_holidays_to_calendar(school_id uuid, selected_ids uuid[]) TO anon;
GRANT ALL ON FUNCTION public.import_selected_holidays_to_calendar(school_id uuid, selected_ids uuid[]) TO authenticated;
GRANT ALL ON FUNCTION public.import_selected_holidays_to_calendar(school_id uuid, selected_ids uuid[]) TO service_role;
GRANT ALL ON FUNCTION public.import_selected_holidays_to_calendar(school_id uuid, selected_ids uuid[]) TO test_user;


--
-- Name: FUNCTION ingest_interview_everything(p_student_id uuid, p_registration_period_id uuid, p_payload jsonb, p_submitted_by uuid, p_debug boolean); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.ingest_interview_everything(p_student_id uuid, p_registration_period_id uuid, p_payload jsonb, p_submitted_by uuid, p_debug boolean) TO postgres;
GRANT ALL ON FUNCTION public.ingest_interview_everything(p_student_id uuid, p_registration_period_id uuid, p_payload jsonb, p_submitted_by uuid, p_debug boolean) TO anon;
GRANT ALL ON FUNCTION public.ingest_interview_everything(p_student_id uuid, p_registration_period_id uuid, p_payload jsonb, p_submitted_by uuid, p_debug boolean) TO authenticated;
GRANT ALL ON FUNCTION public.ingest_interview_everything(p_student_id uuid, p_registration_period_id uuid, p_payload jsonb, p_submitted_by uuid, p_debug boolean) TO service_role;
GRANT ALL ON FUNCTION public.ingest_interview_everything(p_student_id uuid, p_registration_period_id uuid, p_payload jsonb, p_submitted_by uuid, p_debug boolean) TO test_user;


--
-- Name: FUNCTION ingest_interview_ui_wrapper(p_student_id uuid, p_registration_period_id uuid, p_ui_payload jsonb, p_submitted_by uuid, p_debug boolean); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.ingest_interview_ui_wrapper(p_student_id uuid, p_registration_period_id uuid, p_ui_payload jsonb, p_submitted_by uuid, p_debug boolean) TO postgres;
GRANT ALL ON FUNCTION public.ingest_interview_ui_wrapper(p_student_id uuid, p_registration_period_id uuid, p_ui_payload jsonb, p_submitted_by uuid, p_debug boolean) TO anon;
GRANT ALL ON FUNCTION public.ingest_interview_ui_wrapper(p_student_id uuid, p_registration_period_id uuid, p_ui_payload jsonb, p_submitted_by uuid, p_debug boolean) TO authenticated;
GRANT ALL ON FUNCTION public.ingest_interview_ui_wrapper(p_student_id uuid, p_registration_period_id uuid, p_ui_payload jsonb, p_submitted_by uuid, p_debug boolean) TO service_role;
GRANT ALL ON FUNCTION public.ingest_interview_ui_wrapper(p_student_id uuid, p_registration_period_id uuid, p_ui_payload jsonb, p_submitted_by uuid, p_debug boolean) TO test_user;


--
-- Name: FUNCTION "ingest_interview_ui_wrapper.alt"(p_student_id uuid, p_registration_period_id uuid, p_ui_payload jsonb, p_submitted_by uuid, p_debug boolean); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public."ingest_interview_ui_wrapper.alt"(p_student_id uuid, p_registration_period_id uuid, p_ui_payload jsonb, p_submitted_by uuid, p_debug boolean) TO postgres;
GRANT ALL ON FUNCTION public."ingest_interview_ui_wrapper.alt"(p_student_id uuid, p_registration_period_id uuid, p_ui_payload jsonb, p_submitted_by uuid, p_debug boolean) TO anon;
GRANT ALL ON FUNCTION public."ingest_interview_ui_wrapper.alt"(p_student_id uuid, p_registration_period_id uuid, p_ui_payload jsonb, p_submitted_by uuid, p_debug boolean) TO authenticated;
GRANT ALL ON FUNCTION public."ingest_interview_ui_wrapper.alt"(p_student_id uuid, p_registration_period_id uuid, p_ui_payload jsonb, p_submitted_by uuid, p_debug boolean) TO service_role;
GRANT ALL ON FUNCTION public."ingest_interview_ui_wrapper.alt"(p_student_id uuid, p_registration_period_id uuid, p_ui_payload jsonb, p_submitted_by uuid, p_debug boolean) TO test_user;


--
-- Name: FUNCTION is_current_user_staff(); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.is_current_user_staff() TO postgres;
GRANT ALL ON FUNCTION public.is_current_user_staff() TO anon;
GRANT ALL ON FUNCTION public.is_current_user_staff() TO authenticated;
GRANT ALL ON FUNCTION public.is_current_user_staff() TO service_role;


--
-- Name: FUNCTION is_user_staff_optimized(user_id uuid); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.is_user_staff_optimized(user_id uuid) TO postgres;
GRANT ALL ON FUNCTION public.is_user_staff_optimized(user_id uuid) TO anon;
GRANT ALL ON FUNCTION public.is_user_staff_optimized(user_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.is_user_staff_optimized(user_id uuid) TO service_role;


--
-- Name: FUNCTION link_and_invite_parent(p_parent_profile_id uuid, p_first_name text, p_last_name text, p_family_id uuid, p_school_id uuid, p_contacts jsonb, p_student_connections jsonb, p_added_by uuid, p_send_invite boolean); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.link_and_invite_parent(p_parent_profile_id uuid, p_first_name text, p_last_name text, p_family_id uuid, p_school_id uuid, p_contacts jsonb, p_student_connections jsonb, p_added_by uuid, p_send_invite boolean) TO postgres;
GRANT ALL ON FUNCTION public.link_and_invite_parent(p_parent_profile_id uuid, p_first_name text, p_last_name text, p_family_id uuid, p_school_id uuid, p_contacts jsonb, p_student_connections jsonb, p_added_by uuid, p_send_invite boolean) TO anon;
GRANT ALL ON FUNCTION public.link_and_invite_parent(p_parent_profile_id uuid, p_first_name text, p_last_name text, p_family_id uuid, p_school_id uuid, p_contacts jsonb, p_student_connections jsonb, p_added_by uuid, p_send_invite boolean) TO authenticated;
GRANT ALL ON FUNCTION public.link_and_invite_parent(p_parent_profile_id uuid, p_first_name text, p_last_name text, p_family_id uuid, p_school_id uuid, p_contacts jsonb, p_student_connections jsonb, p_added_by uuid, p_send_invite boolean) TO service_role;
GRANT ALL ON FUNCTION public.link_and_invite_parent(p_parent_profile_id uuid, p_first_name text, p_last_name text, p_family_id uuid, p_school_id uuid, p_contacts jsonb, p_student_connections jsonb, p_added_by uuid, p_send_invite boolean) TO test_user;


--
-- Name: FUNCTION log_change(); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.log_change() TO postgres;
GRANT ALL ON FUNCTION public.log_change() TO anon;
GRANT ALL ON FUNCTION public.log_change() TO authenticated;
GRANT ALL ON FUNCTION public.log_change() TO service_role;
GRANT ALL ON FUNCTION public.log_change() TO test_user;


--
-- Name: FUNCTION log_change_generic(); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.log_change_generic() TO postgres;
GRANT ALL ON FUNCTION public.log_change_generic() TO anon;
GRANT ALL ON FUNCTION public.log_change_generic() TO authenticated;
GRANT ALL ON FUNCTION public.log_change_generic() TO service_role;
GRANT ALL ON FUNCTION public.log_change_generic() TO test_user;


--
-- Name: FUNCTION log_ddl_command(); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.log_ddl_command() TO postgres;
GRANT ALL ON FUNCTION public.log_ddl_command() TO anon;
GRANT ALL ON FUNCTION public.log_ddl_command() TO authenticated;
GRANT ALL ON FUNCTION public.log_ddl_command() TO service_role;
GRANT ALL ON FUNCTION public.log_ddl_command() TO test_user;


--
-- Name: FUNCTION log_ingest_debug(p_stage text, p_student_id uuid, p_registration_period_id uuid, p_message text, p_details jsonb); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.log_ingest_debug(p_stage text, p_student_id uuid, p_registration_period_id uuid, p_message text, p_details jsonb) TO postgres;
GRANT ALL ON FUNCTION public.log_ingest_debug(p_stage text, p_student_id uuid, p_registration_period_id uuid, p_message text, p_details jsonb) TO anon;
GRANT ALL ON FUNCTION public.log_ingest_debug(p_stage text, p_student_id uuid, p_registration_period_id uuid, p_message text, p_details jsonb) TO authenticated;
GRANT ALL ON FUNCTION public.log_ingest_debug(p_stage text, p_student_id uuid, p_registration_period_id uuid, p_message text, p_details jsonb) TO service_role;
GRANT ALL ON FUNCTION public.log_ingest_debug(p_stage text, p_student_id uuid, p_registration_period_id uuid, p_message text, p_details jsonb) TO test_user;


--
-- Name: FUNCTION log_manual_change(p_table_name text, p_record_id uuid, p_action_type text, p_user_id uuid, p_school_id uuid, p_data jsonb, p_change_group_id uuid); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.log_manual_change(p_table_name text, p_record_id uuid, p_action_type text, p_user_id uuid, p_school_id uuid, p_data jsonb, p_change_group_id uuid) TO postgres;
GRANT ALL ON FUNCTION public.log_manual_change(p_table_name text, p_record_id uuid, p_action_type text, p_user_id uuid, p_school_id uuid, p_data jsonb, p_change_group_id uuid) TO anon;
GRANT ALL ON FUNCTION public.log_manual_change(p_table_name text, p_record_id uuid, p_action_type text, p_user_id uuid, p_school_id uuid, p_data jsonb, p_change_group_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.log_manual_change(p_table_name text, p_record_id uuid, p_action_type text, p_user_id uuid, p_school_id uuid, p_data jsonb, p_change_group_id uuid) TO service_role;
GRANT ALL ON FUNCTION public.log_manual_change(p_table_name text, p_record_id uuid, p_action_type text, p_user_id uuid, p_school_id uuid, p_data jsonb, p_change_group_id uuid) TO test_user;


--
-- Name: PROCEDURE log_recurrence_debug(IN p_recurrence_id uuid, IN p_function_called text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON PROCEDURE public.log_recurrence_debug(IN p_recurrence_id uuid, IN p_function_called text) TO postgres;
GRANT ALL ON PROCEDURE public.log_recurrence_debug(IN p_recurrence_id uuid, IN p_function_called text) TO anon;
GRANT ALL ON PROCEDURE public.log_recurrence_debug(IN p_recurrence_id uuid, IN p_function_called text) TO authenticated;
GRANT ALL ON PROCEDURE public.log_recurrence_debug(IN p_recurrence_id uuid, IN p_function_called text) TO service_role;


--
-- Name: FUNCTION log_schema_change(); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.log_schema_change() TO postgres;
GRANT ALL ON FUNCTION public.log_schema_change() TO anon;
GRANT ALL ON FUNCTION public.log_schema_change() TO authenticated;
GRANT ALL ON FUNCTION public.log_schema_change() TO service_role;
GRANT ALL ON FUNCTION public.log_schema_change() TO test_user;


--
-- Name: FUNCTION mark_all_students_present(p_student_ids uuid[], p_lesson_id uuid, p_school_id uuid, p_recorded_by uuid); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.mark_all_students_present(p_student_ids uuid[], p_lesson_id uuid, p_school_id uuid, p_recorded_by uuid) TO postgres;
GRANT ALL ON FUNCTION public.mark_all_students_present(p_student_ids uuid[], p_lesson_id uuid, p_school_id uuid, p_recorded_by uuid) TO anon;
GRANT ALL ON FUNCTION public.mark_all_students_present(p_student_ids uuid[], p_lesson_id uuid, p_school_id uuid, p_recorded_by uuid) TO authenticated;
GRANT ALL ON FUNCTION public.mark_all_students_present(p_student_ids uuid[], p_lesson_id uuid, p_school_id uuid, p_recorded_by uuid) TO service_role;
GRANT ALL ON FUNCTION public.mark_all_students_present(p_student_ids uuid[], p_lesson_id uuid, p_school_id uuid, p_recorded_by uuid) TO test_user;


--
-- Name: FUNCTION mark_student_attendance(p_student_id uuid, p_lesson_id uuid, p_school_id uuid, p_recorded_by uuid, p_status public.attendance_status); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.mark_student_attendance(p_student_id uuid, p_lesson_id uuid, p_school_id uuid, p_recorded_by uuid, p_status public.attendance_status) TO postgres;
GRANT ALL ON FUNCTION public.mark_student_attendance(p_student_id uuid, p_lesson_id uuid, p_school_id uuid, p_recorded_by uuid, p_status public.attendance_status) TO anon;
GRANT ALL ON FUNCTION public.mark_student_attendance(p_student_id uuid, p_lesson_id uuid, p_school_id uuid, p_recorded_by uuid, p_status public.attendance_status) TO authenticated;
GRANT ALL ON FUNCTION public.mark_student_attendance(p_student_id uuid, p_lesson_id uuid, p_school_id uuid, p_recorded_by uuid, p_status public.attendance_status) TO service_role;
GRANT ALL ON FUNCTION public.mark_student_attendance(p_student_id uuid, p_lesson_id uuid, p_school_id uuid, p_recorded_by uuid, p_status public.attendance_status) TO test_user;


--
-- Name: FUNCTION mark_student_attendance_legacy(p_student_id uuid, p_lesson_id uuid, p_school_id uuid, p_recorded_by uuid, p_status text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.mark_student_attendance_legacy(p_student_id uuid, p_lesson_id uuid, p_school_id uuid, p_recorded_by uuid, p_status text) TO postgres;
GRANT ALL ON FUNCTION public.mark_student_attendance_legacy(p_student_id uuid, p_lesson_id uuid, p_school_id uuid, p_recorded_by uuid, p_status text) TO anon;
GRANT ALL ON FUNCTION public.mark_student_attendance_legacy(p_student_id uuid, p_lesson_id uuid, p_school_id uuid, p_recorded_by uuid, p_status text) TO authenticated;
GRANT ALL ON FUNCTION public.mark_student_attendance_legacy(p_student_id uuid, p_lesson_id uuid, p_school_id uuid, p_recorded_by uuid, p_status text) TO service_role;
GRANT ALL ON FUNCTION public.mark_student_attendance_legacy(p_student_id uuid, p_lesson_id uuid, p_school_id uuid, p_recorded_by uuid, p_status text) TO test_user;


--
-- Name: FUNCTION mark_student_present(p_student_id uuid, p_lesson_id uuid, p_school_id uuid, p_recorded_by uuid); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.mark_student_present(p_student_id uuid, p_lesson_id uuid, p_school_id uuid, p_recorded_by uuid) TO postgres;
GRANT ALL ON FUNCTION public.mark_student_present(p_student_id uuid, p_lesson_id uuid, p_school_id uuid, p_recorded_by uuid) TO anon;
GRANT ALL ON FUNCTION public.mark_student_present(p_student_id uuid, p_lesson_id uuid, p_school_id uuid, p_recorded_by uuid) TO authenticated;
GRANT ALL ON FUNCTION public.mark_student_present(p_student_id uuid, p_lesson_id uuid, p_school_id uuid, p_recorded_by uuid) TO service_role;
GRANT ALL ON FUNCTION public.mark_student_present(p_student_id uuid, p_lesson_id uuid, p_school_id uuid, p_recorded_by uuid) TO test_user;


--
-- Name: FUNCTION normalize_interview_ui_payload(p_ui_payload jsonb); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.normalize_interview_ui_payload(p_ui_payload jsonb) TO postgres;
GRANT ALL ON FUNCTION public.normalize_interview_ui_payload(p_ui_payload jsonb) TO anon;
GRANT ALL ON FUNCTION public.normalize_interview_ui_payload(p_ui_payload jsonb) TO authenticated;
GRANT ALL ON FUNCTION public.normalize_interview_ui_payload(p_ui_payload jsonb) TO service_role;
GRANT ALL ON FUNCTION public.normalize_interview_ui_payload(p_ui_payload jsonb) TO test_user;


--
-- Name: FUNCTION pgaudit_ddl_command_end(); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.pgaudit_ddl_command_end() TO postgres;
GRANT ALL ON FUNCTION public.pgaudit_ddl_command_end() TO anon;
GRANT ALL ON FUNCTION public.pgaudit_ddl_command_end() TO authenticated;
GRANT ALL ON FUNCTION public.pgaudit_ddl_command_end() TO service_role;
GRANT ALL ON FUNCTION public.pgaudit_ddl_command_end() TO test_user;


--
-- Name: FUNCTION pgaudit_sql_drop(); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.pgaudit_sql_drop() TO postgres;
GRANT ALL ON FUNCTION public.pgaudit_sql_drop() TO anon;
GRANT ALL ON FUNCTION public.pgaudit_sql_drop() TO authenticated;
GRANT ALL ON FUNCTION public.pgaudit_sql_drop() TO service_role;
GRANT ALL ON FUNCTION public.pgaudit_sql_drop() TO test_user;


--
-- Name: FUNCTION process_first_login(input_code character varying, p_profile_id uuid); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.process_first_login(input_code character varying, p_profile_id uuid) TO postgres;
GRANT ALL ON FUNCTION public.process_first_login(input_code character varying, p_profile_id uuid) TO anon;
GRANT ALL ON FUNCTION public.process_first_login(input_code character varying, p_profile_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.process_first_login(input_code character varying, p_profile_id uuid) TO service_role;
GRANT ALL ON FUNCTION public.process_first_login(input_code character varying, p_profile_id uuid) TO test_user;


--
-- Name: FUNCTION process_parent_student_first_login(input_code character varying, p_child_profile_id uuid, p_adult_profile_id uuid); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.process_parent_student_first_login(input_code character varying, p_child_profile_id uuid, p_adult_profile_id uuid) TO postgres;
GRANT ALL ON FUNCTION public.process_parent_student_first_login(input_code character varying, p_child_profile_id uuid, p_adult_profile_id uuid) TO anon;
GRANT ALL ON FUNCTION public.process_parent_student_first_login(input_code character varying, p_child_profile_id uuid, p_adult_profile_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.process_parent_student_first_login(input_code character varying, p_child_profile_id uuid, p_adult_profile_id uuid) TO service_role;
GRANT ALL ON FUNCTION public.process_parent_student_first_login(input_code character varying, p_child_profile_id uuid, p_adult_profile_id uuid) TO test_user;


--
-- Name: FUNCTION protect_role_deletion(); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.protect_role_deletion() TO postgres;
GRANT ALL ON FUNCTION public.protect_role_deletion() TO anon;
GRANT ALL ON FUNCTION public.protect_role_deletion() TO authenticated;
GRANT ALL ON FUNCTION public.protect_role_deletion() TO service_role;


--
-- Name: FUNCTION protect_role_modification(); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.protect_role_modification() TO postgres;
GRANT ALL ON FUNCTION public.protect_role_modification() TO anon;
GRANT ALL ON FUNCTION public.protect_role_modification() TO authenticated;
GRANT ALL ON FUNCTION public.protect_role_modification() TO service_role;


--
-- Name: FUNCTION publish_all_pending_substitutions(p_school_id uuid, p_date date, p_user_id uuid, p_notes jsonb); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.publish_all_pending_substitutions(p_school_id uuid, p_date date, p_user_id uuid, p_notes jsonb) TO postgres;
GRANT ALL ON FUNCTION public.publish_all_pending_substitutions(p_school_id uuid, p_date date, p_user_id uuid, p_notes jsonb) TO anon;
GRANT ALL ON FUNCTION public.publish_all_pending_substitutions(p_school_id uuid, p_date date, p_user_id uuid, p_notes jsonb) TO authenticated;
GRANT ALL ON FUNCTION public.publish_all_pending_substitutions(p_school_id uuid, p_date date, p_user_id uuid, p_notes jsonb) TO service_role;
GRANT ALL ON FUNCTION public.publish_all_pending_substitutions(p_school_id uuid, p_date date, p_user_id uuid, p_notes jsonb) TO test_user;


--
-- Name: FUNCTION publish_schedule_draft_v2(_draft_id uuid, _school_id uuid, _published_by uuid); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.publish_schedule_draft_v2(_draft_id uuid, _school_id uuid, _published_by uuid) TO postgres;
GRANT ALL ON FUNCTION public.publish_schedule_draft_v2(_draft_id uuid, _school_id uuid, _published_by uuid) TO anon;
GRANT ALL ON FUNCTION public.publish_schedule_draft_v2(_draft_id uuid, _school_id uuid, _published_by uuid) TO authenticated;
GRANT ALL ON FUNCTION public.publish_schedule_draft_v2(_draft_id uuid, _school_id uuid, _published_by uuid) TO service_role;
GRANT ALL ON FUNCTION public.publish_schedule_draft_v2(_draft_id uuid, _school_id uuid, _published_by uuid) TO test_user;


--
-- Name: FUNCTION "publish_schedule_draft_v2_Alt_new"(_draft_id uuid, _school_id uuid, _published_by uuid); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public."publish_schedule_draft_v2_Alt_new"(_draft_id uuid, _school_id uuid, _published_by uuid) TO postgres;
GRANT ALL ON FUNCTION public."publish_schedule_draft_v2_Alt_new"(_draft_id uuid, _school_id uuid, _published_by uuid) TO anon;
GRANT ALL ON FUNCTION public."publish_schedule_draft_v2_Alt_new"(_draft_id uuid, _school_id uuid, _published_by uuid) TO authenticated;
GRANT ALL ON FUNCTION public."publish_schedule_draft_v2_Alt_new"(_draft_id uuid, _school_id uuid, _published_by uuid) TO service_role;
GRANT ALL ON FUNCTION public."publish_schedule_draft_v2_Alt_new"(_draft_id uuid, _school_id uuid, _published_by uuid) TO test_user;


--
-- Name: FUNCTION publish_schedule_draft_v2_alt(_draft_id uuid, _school_id uuid, _published_by uuid); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.publish_schedule_draft_v2_alt(_draft_id uuid, _school_id uuid, _published_by uuid) TO postgres;
GRANT ALL ON FUNCTION public.publish_schedule_draft_v2_alt(_draft_id uuid, _school_id uuid, _published_by uuid) TO anon;
GRANT ALL ON FUNCTION public.publish_schedule_draft_v2_alt(_draft_id uuid, _school_id uuid, _published_by uuid) TO authenticated;
GRANT ALL ON FUNCTION public.publish_schedule_draft_v2_alt(_draft_id uuid, _school_id uuid, _published_by uuid) TO service_role;
GRANT ALL ON FUNCTION public.publish_schedule_draft_v2_alt(_draft_id uuid, _school_id uuid, _published_by uuid) TO test_user;


--
-- Name: FUNCTION refresh_user_login_profiles(); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.refresh_user_login_profiles() TO postgres;
GRANT ALL ON FUNCTION public.refresh_user_login_profiles() TO anon;
GRANT ALL ON FUNCTION public.refresh_user_login_profiles() TO authenticated;
GRANT ALL ON FUNCTION public.refresh_user_login_profiles() TO service_role;
GRANT ALL ON FUNCTION public.refresh_user_login_profiles() TO test_user;


--
-- Name: FUNCTION remove_student_from_family(target_student_profile_id uuid); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.remove_student_from_family(target_student_profile_id uuid) TO postgres;
GRANT ALL ON FUNCTION public.remove_student_from_family(target_student_profile_id uuid) TO anon;
GRANT ALL ON FUNCTION public.remove_student_from_family(target_student_profile_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.remove_student_from_family(target_student_profile_id uuid) TO service_role;
GRANT ALL ON FUNCTION public.remove_student_from_family(target_student_profile_id uuid) TO test_user;


--
-- Name: FUNCTION remove_user_from_group(); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.remove_user_from_group() TO postgres;
GRANT ALL ON FUNCTION public.remove_user_from_group() TO anon;
GRANT ALL ON FUNCTION public.remove_user_from_group() TO authenticated;
GRANT ALL ON FUNCTION public.remove_user_from_group() TO service_role;
GRANT ALL ON FUNCTION public.remove_user_from_group() TO test_user;


--
-- Name: FUNCTION resolve_course_note(p_note_id uuid, p_resolved_by text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.resolve_course_note(p_note_id uuid, p_resolved_by text) TO postgres;
GRANT ALL ON FUNCTION public.resolve_course_note(p_note_id uuid, p_resolved_by text) TO anon;
GRANT ALL ON FUNCTION public.resolve_course_note(p_note_id uuid, p_resolved_by text) TO authenticated;
GRANT ALL ON FUNCTION public.resolve_course_note(p_note_id uuid, p_resolved_by text) TO service_role;
GRANT ALL ON FUNCTION public.resolve_course_note(p_note_id uuid, p_resolved_by text) TO test_user;


--
-- Name: FUNCTION save_draft_to_db(_draft_id uuid, _schedule_data jsonb); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.save_draft_to_db(_draft_id uuid, _schedule_data jsonb) TO postgres;
GRANT ALL ON FUNCTION public.save_draft_to_db(_draft_id uuid, _schedule_data jsonb) TO anon;
GRANT ALL ON FUNCTION public.save_draft_to_db(_draft_id uuid, _schedule_data jsonb) TO authenticated;
GRANT ALL ON FUNCTION public.save_draft_to_db(_draft_id uuid, _schedule_data jsonb) TO service_role;
GRANT ALL ON FUNCTION public.save_draft_to_db(_draft_id uuid, _schedule_data jsonb) TO test_user;


--
-- Name: FUNCTION scheduling_create_new_draft(_created_by uuid, _name text, _notes text, _school_id uuid, _semester_id uuid); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.scheduling_create_new_draft(_created_by uuid, _name text, _notes text, _school_id uuid, _semester_id uuid) TO postgres;
GRANT ALL ON FUNCTION public.scheduling_create_new_draft(_created_by uuid, _name text, _notes text, _school_id uuid, _semester_id uuid) TO anon;
GRANT ALL ON FUNCTION public.scheduling_create_new_draft(_created_by uuid, _name text, _notes text, _school_id uuid, _semester_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.scheduling_create_new_draft(_created_by uuid, _name text, _notes text, _school_id uuid, _semester_id uuid) TO service_role;
GRANT ALL ON FUNCTION public.scheduling_create_new_draft(_created_by uuid, _name text, _notes text, _school_id uuid, _semester_id uuid) TO test_user;


--
-- Name: FUNCTION scheduling_save_draft_version(_draft_id uuid, _schedule_data jsonb); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.scheduling_save_draft_version(_draft_id uuid, _schedule_data jsonb) TO postgres;
GRANT ALL ON FUNCTION public.scheduling_save_draft_version(_draft_id uuid, _schedule_data jsonb) TO anon;
GRANT ALL ON FUNCTION public.scheduling_save_draft_version(_draft_id uuid, _schedule_data jsonb) TO authenticated;
GRANT ALL ON FUNCTION public.scheduling_save_draft_version(_draft_id uuid, _schedule_data jsonb) TO service_role;
GRANT ALL ON FUNCTION public.scheduling_save_draft_version(_draft_id uuid, _schedule_data jsonb) TO test_user;


--
-- Name: FUNCTION set_pickup_authorization(_family_id uuid, _adult_profile_id uuid, _child_profile_id uuid, _authorized_for_pickup boolean); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.set_pickup_authorization(_family_id uuid, _adult_profile_id uuid, _child_profile_id uuid, _authorized_for_pickup boolean) TO postgres;
GRANT ALL ON FUNCTION public.set_pickup_authorization(_family_id uuid, _adult_profile_id uuid, _child_profile_id uuid, _authorized_for_pickup boolean) TO anon;
GRANT ALL ON FUNCTION public.set_pickup_authorization(_family_id uuid, _adult_profile_id uuid, _child_profile_id uuid, _authorized_for_pickup boolean) TO authenticated;
GRANT ALL ON FUNCTION public.set_pickup_authorization(_family_id uuid, _adult_profile_id uuid, _child_profile_id uuid, _authorized_for_pickup boolean) TO service_role;
GRANT ALL ON FUNCTION public.set_pickup_authorization(_family_id uuid, _adult_profile_id uuid, _child_profile_id uuid, _authorized_for_pickup boolean) TO test_user;


--
-- Name: FUNCTION set_sibling_pickup_authorization(_student_profile_id uuid, _sibling_profile_id uuid, _authorized boolean); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.set_sibling_pickup_authorization(_student_profile_id uuid, _sibling_profile_id uuid, _authorized boolean) TO postgres;
GRANT ALL ON FUNCTION public.set_sibling_pickup_authorization(_student_profile_id uuid, _sibling_profile_id uuid, _authorized boolean) TO anon;
GRANT ALL ON FUNCTION public.set_sibling_pickup_authorization(_student_profile_id uuid, _sibling_profile_id uuid, _authorized boolean) TO authenticated;
GRANT ALL ON FUNCTION public.set_sibling_pickup_authorization(_student_profile_id uuid, _sibling_profile_id uuid, _authorized boolean) TO service_role;
GRANT ALL ON FUNCTION public.set_sibling_pickup_authorization(_student_profile_id uuid, _sibling_profile_id uuid, _authorized boolean) TO test_user;


--
-- Name: FUNCTION set_updated_at(); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.set_updated_at() TO postgres;
GRANT ALL ON FUNCTION public.set_updated_at() TO anon;
GRANT ALL ON FUNCTION public.set_updated_at() TO authenticated;
GRANT ALL ON FUNCTION public.set_updated_at() TO service_role;
GRANT ALL ON FUNCTION public.set_updated_at() TO test_user;


--
-- Name: FUNCTION set_user_context(p_user_id uuid); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.set_user_context(p_user_id uuid) TO postgres;
GRANT ALL ON FUNCTION public.set_user_context(p_user_id uuid) TO anon;
GRANT ALL ON FUNCTION public.set_user_context(p_user_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.set_user_context(p_user_id uuid) TO service_role;
GRANT ALL ON FUNCTION public.set_user_context(p_user_id uuid) TO test_user;


--
-- Name: FUNCTION soft_delete_enrollment_with_logging(p_enrollment_id uuid, p_user_id uuid, p_school_id uuid, p_change_group_id uuid); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.soft_delete_enrollment_with_logging(p_enrollment_id uuid, p_user_id uuid, p_school_id uuid, p_change_group_id uuid) TO postgres;
GRANT ALL ON FUNCTION public.soft_delete_enrollment_with_logging(p_enrollment_id uuid, p_user_id uuid, p_school_id uuid, p_change_group_id uuid) TO anon;
GRANT ALL ON FUNCTION public.soft_delete_enrollment_with_logging(p_enrollment_id uuid, p_user_id uuid, p_school_id uuid, p_change_group_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.soft_delete_enrollment_with_logging(p_enrollment_id uuid, p_user_id uuid, p_school_id uuid, p_change_group_id uuid) TO service_role;
GRANT ALL ON FUNCTION public.soft_delete_enrollment_with_logging(p_enrollment_id uuid, p_user_id uuid, p_school_id uuid, p_change_group_id uuid) TO test_user;


--
-- Name: FUNCTION soft_delete_enrollment_with_logging_alt(p_enrollment_id uuid, p_user_id uuid, p_school_id uuid, p_change_group_id uuid); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.soft_delete_enrollment_with_logging_alt(p_enrollment_id uuid, p_user_id uuid, p_school_id uuid, p_change_group_id uuid) TO postgres;
GRANT ALL ON FUNCTION public.soft_delete_enrollment_with_logging_alt(p_enrollment_id uuid, p_user_id uuid, p_school_id uuid, p_change_group_id uuid) TO anon;
GRANT ALL ON FUNCTION public.soft_delete_enrollment_with_logging_alt(p_enrollment_id uuid, p_user_id uuid, p_school_id uuid, p_change_group_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.soft_delete_enrollment_with_logging_alt(p_enrollment_id uuid, p_user_id uuid, p_school_id uuid, p_change_group_id uuid) TO service_role;
GRANT ALL ON FUNCTION public.soft_delete_enrollment_with_logging_alt(p_enrollment_id uuid, p_user_id uuid, p_school_id uuid, p_change_group_id uuid) TO test_user;


--
-- Name: FUNCTION student_absence_recurrences_generate(p_recurrence_id uuid, p_student_id uuid, p_school_id uuid, p_created_by uuid, p_reason text, p_from_time time without time zone, p_to_time time without time zone, p_attachment_url text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.student_absence_recurrences_generate(p_recurrence_id uuid, p_student_id uuid, p_school_id uuid, p_created_by uuid, p_reason text, p_from_time time without time zone, p_to_time time without time zone, p_attachment_url text) TO postgres;
GRANT ALL ON FUNCTION public.student_absence_recurrences_generate(p_recurrence_id uuid, p_student_id uuid, p_school_id uuid, p_created_by uuid, p_reason text, p_from_time time without time zone, p_to_time time without time zone, p_attachment_url text) TO anon;
GRANT ALL ON FUNCTION public.student_absence_recurrences_generate(p_recurrence_id uuid, p_student_id uuid, p_school_id uuid, p_created_by uuid, p_reason text, p_from_time time without time zone, p_to_time time without time zone, p_attachment_url text) TO authenticated;
GRANT ALL ON FUNCTION public.student_absence_recurrences_generate(p_recurrence_id uuid, p_student_id uuid, p_school_id uuid, p_created_by uuid, p_reason text, p_from_time time without time zone, p_to_time time without time zone, p_attachment_url text) TO service_role;
GRANT ALL ON FUNCTION public.student_absence_recurrences_generate(p_recurrence_id uuid, p_student_id uuid, p_school_id uuid, p_created_by uuid, p_reason text, p_from_time time without time zone, p_to_time time without time zone, p_attachment_url text) TO test_user;


--
-- Name: FUNCTION test_as_user(user_id uuid); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.test_as_user(user_id uuid) TO postgres;
GRANT ALL ON FUNCTION public.test_as_user(user_id uuid) TO anon;
GRANT ALL ON FUNCTION public.test_as_user(user_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.test_as_user(user_id uuid) TO service_role;
GRANT ALL ON FUNCTION public.test_as_user(user_id uuid) TO test_user;


--
-- Name: FUNCTION test_current_user_rls(); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.test_current_user_rls() TO postgres;
GRANT ALL ON FUNCTION public.test_current_user_rls() TO anon;
GRANT ALL ON FUNCTION public.test_current_user_rls() TO authenticated;
GRANT ALL ON FUNCTION public.test_current_user_rls() TO service_role;
GRANT ALL ON FUNCTION public.test_current_user_rls() TO test_user;


--
-- Name: FUNCTION test_rls_as_father_muller(); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.test_rls_as_father_muller() TO postgres;
GRANT ALL ON FUNCTION public.test_rls_as_father_muller() TO anon;
GRANT ALL ON FUNCTION public.test_rls_as_father_muller() TO authenticated;
GRANT ALL ON FUNCTION public.test_rls_as_father_muller() TO service_role;
GRANT ALL ON FUNCTION public.test_rls_as_father_muller() TO test_user;


--
-- Name: FUNCTION test_storage_access(); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.test_storage_access() TO postgres;
GRANT ALL ON FUNCTION public.test_storage_access() TO anon;
GRANT ALL ON FUNCTION public.test_storage_access() TO authenticated;
GRANT ALL ON FUNCTION public.test_storage_access() TO service_role;


--
-- Name: FUNCTION test_timeout(seconds integer); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.test_timeout(seconds integer) TO postgres;
GRANT ALL ON FUNCTION public.test_timeout(seconds integer) TO anon;
GRANT ALL ON FUNCTION public.test_timeout(seconds integer) TO authenticated;
GRANT ALL ON FUNCTION public.test_timeout(seconds integer) TO service_role;
GRANT ALL ON FUNCTION public.test_timeout(seconds integer) TO test_user;


--
-- Name: FUNCTION toggle_custom_period(p_school_id uuid, p_user_id uuid, p_allow_custom boolean); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.toggle_custom_period(p_school_id uuid, p_user_id uuid, p_allow_custom boolean) TO postgres;
GRANT ALL ON FUNCTION public.toggle_custom_period(p_school_id uuid, p_user_id uuid, p_allow_custom boolean) TO anon;
GRANT ALL ON FUNCTION public.toggle_custom_period(p_school_id uuid, p_user_id uuid, p_allow_custom boolean) TO authenticated;
GRANT ALL ON FUNCTION public.toggle_custom_period(p_school_id uuid, p_user_id uuid, p_allow_custom boolean) TO service_role;
GRANT ALL ON FUNCTION public.toggle_custom_period(p_school_id uuid, p_user_id uuid, p_allow_custom boolean) TO test_user;


--
-- Name: FUNCTION trg_set_school_on_possible_times(); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.trg_set_school_on_possible_times() TO postgres;
GRANT ALL ON FUNCTION public.trg_set_school_on_possible_times() TO anon;
GRANT ALL ON FUNCTION public.trg_set_school_on_possible_times() TO authenticated;
GRANT ALL ON FUNCTION public.trg_set_school_on_possible_times() TO service_role;
GRANT ALL ON FUNCTION public.trg_set_school_on_possible_times() TO test_user;


--
-- Name: FUNCTION undo_change(p_change_id uuid, p_user_id uuid); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.undo_change(p_change_id uuid, p_user_id uuid) TO postgres;
GRANT ALL ON FUNCTION public.undo_change(p_change_id uuid, p_user_id uuid) TO anon;
GRANT ALL ON FUNCTION public.undo_change(p_change_id uuid, p_user_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.undo_change(p_change_id uuid, p_user_id uuid) TO service_role;
GRANT ALL ON FUNCTION public.undo_change(p_change_id uuid, p_user_id uuid) TO test_user;


--
-- Name: FUNCTION update_course_with_custom_times_alt(p_user_id uuid, p_school_id uuid, p_course_id uuid, p_name text, p_max_students integer, p_start_date date, p_end_date date, p_is_active boolean, p_course_code text, p_is_for_year_g smallint[], p_description text, p_pictures text[], p_wichtige_infos text, p_subject_id uuid, p_is_open_course boolean, p_description_visible_to_parents boolean, p_possible_staff_members uuid[], p_possible_times text[]); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.update_course_with_custom_times_alt(p_user_id uuid, p_school_id uuid, p_course_id uuid, p_name text, p_max_students integer, p_start_date date, p_end_date date, p_is_active boolean, p_course_code text, p_is_for_year_g smallint[], p_description text, p_pictures text[], p_wichtige_infos text, p_subject_id uuid, p_is_open_course boolean, p_description_visible_to_parents boolean, p_possible_staff_members uuid[], p_possible_times text[]) TO postgres;
GRANT ALL ON FUNCTION public.update_course_with_custom_times_alt(p_user_id uuid, p_school_id uuid, p_course_id uuid, p_name text, p_max_students integer, p_start_date date, p_end_date date, p_is_active boolean, p_course_code text, p_is_for_year_g smallint[], p_description text, p_pictures text[], p_wichtige_infos text, p_subject_id uuid, p_is_open_course boolean, p_description_visible_to_parents boolean, p_possible_staff_members uuid[], p_possible_times text[]) TO anon;
GRANT ALL ON FUNCTION public.update_course_with_custom_times_alt(p_user_id uuid, p_school_id uuid, p_course_id uuid, p_name text, p_max_students integer, p_start_date date, p_end_date date, p_is_active boolean, p_course_code text, p_is_for_year_g smallint[], p_description text, p_pictures text[], p_wichtige_infos text, p_subject_id uuid, p_is_open_course boolean, p_description_visible_to_parents boolean, p_possible_staff_members uuid[], p_possible_times text[]) TO authenticated;
GRANT ALL ON FUNCTION public.update_course_with_custom_times_alt(p_user_id uuid, p_school_id uuid, p_course_id uuid, p_name text, p_max_students integer, p_start_date date, p_end_date date, p_is_active boolean, p_course_code text, p_is_for_year_g smallint[], p_description text, p_pictures text[], p_wichtige_infos text, p_subject_id uuid, p_is_open_course boolean, p_description_visible_to_parents boolean, p_possible_staff_members uuid[], p_possible_times text[]) TO service_role;
GRANT ALL ON FUNCTION public.update_course_with_custom_times_alt(p_user_id uuid, p_school_id uuid, p_course_id uuid, p_name text, p_max_students integer, p_start_date date, p_end_date date, p_is_active boolean, p_course_code text, p_is_for_year_g smallint[], p_description text, p_pictures text[], p_wichtige_infos text, p_subject_id uuid, p_is_open_course boolean, p_description_visible_to_parents boolean, p_possible_staff_members uuid[], p_possible_times text[]) TO test_user;


--
-- Name: FUNCTION update_course_with_options(p_course_id uuid, p_user_id uuid, p_school_id uuid, p_name text, p_max_students integer, p_start_date date, p_end_date date, p_is_active boolean, p_course_code text, p_is_for_year_g integer[], p_description text, p_pictures text[], p_wichtige_infos text, p_subject_id uuid, p_is_open_course boolean, p_description_visible_to_parents boolean, p_possible_staff_members uuid[], p_possible_times text[]); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.update_course_with_options(p_course_id uuid, p_user_id uuid, p_school_id uuid, p_name text, p_max_students integer, p_start_date date, p_end_date date, p_is_active boolean, p_course_code text, p_is_for_year_g integer[], p_description text, p_pictures text[], p_wichtige_infos text, p_subject_id uuid, p_is_open_course boolean, p_description_visible_to_parents boolean, p_possible_staff_members uuid[], p_possible_times text[]) TO postgres;
GRANT ALL ON FUNCTION public.update_course_with_options(p_course_id uuid, p_user_id uuid, p_school_id uuid, p_name text, p_max_students integer, p_start_date date, p_end_date date, p_is_active boolean, p_course_code text, p_is_for_year_g integer[], p_description text, p_pictures text[], p_wichtige_infos text, p_subject_id uuid, p_is_open_course boolean, p_description_visible_to_parents boolean, p_possible_staff_members uuid[], p_possible_times text[]) TO anon;
GRANT ALL ON FUNCTION public.update_course_with_options(p_course_id uuid, p_user_id uuid, p_school_id uuid, p_name text, p_max_students integer, p_start_date date, p_end_date date, p_is_active boolean, p_course_code text, p_is_for_year_g integer[], p_description text, p_pictures text[], p_wichtige_infos text, p_subject_id uuid, p_is_open_course boolean, p_description_visible_to_parents boolean, p_possible_staff_members uuid[], p_possible_times text[]) TO authenticated;
GRANT ALL ON FUNCTION public.update_course_with_options(p_course_id uuid, p_user_id uuid, p_school_id uuid, p_name text, p_max_students integer, p_start_date date, p_end_date date, p_is_active boolean, p_course_code text, p_is_for_year_g integer[], p_description text, p_pictures text[], p_wichtige_infos text, p_subject_id uuid, p_is_open_course boolean, p_description_visible_to_parents boolean, p_possible_staff_members uuid[], p_possible_times text[]) TO service_role;
GRANT ALL ON FUNCTION public.update_course_with_options(p_course_id uuid, p_user_id uuid, p_school_id uuid, p_name text, p_max_students integer, p_start_date date, p_end_date date, p_is_active boolean, p_course_code text, p_is_for_year_g integer[], p_description text, p_pictures text[], p_wichtige_infos text, p_subject_id uuid, p_is_open_course boolean, p_description_visible_to_parents boolean, p_possible_staff_members uuid[], p_possible_times text[]) TO test_user;


--
-- Name: FUNCTION update_course_with_possible_times_alt(p_course_id uuid, p_school_id uuid, p_user_id uuid, p_name text, p_max_students integer, p_start_date date, p_end_date date, p_is_active boolean, p_course_code text, p_is_for_year_g integer[], p_description text, p_pictures text[], p_wichtige_infos text, p_subject_id uuid, p_is_open_course boolean, p_description_visible_to_parents boolean, p_possible_times text[], p_possible_staff_members uuid[]); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.update_course_with_possible_times_alt(p_course_id uuid, p_school_id uuid, p_user_id uuid, p_name text, p_max_students integer, p_start_date date, p_end_date date, p_is_active boolean, p_course_code text, p_is_for_year_g integer[], p_description text, p_pictures text[], p_wichtige_infos text, p_subject_id uuid, p_is_open_course boolean, p_description_visible_to_parents boolean, p_possible_times text[], p_possible_staff_members uuid[]) TO postgres;
GRANT ALL ON FUNCTION public.update_course_with_possible_times_alt(p_course_id uuid, p_school_id uuid, p_user_id uuid, p_name text, p_max_students integer, p_start_date date, p_end_date date, p_is_active boolean, p_course_code text, p_is_for_year_g integer[], p_description text, p_pictures text[], p_wichtige_infos text, p_subject_id uuid, p_is_open_course boolean, p_description_visible_to_parents boolean, p_possible_times text[], p_possible_staff_members uuid[]) TO anon;
GRANT ALL ON FUNCTION public.update_course_with_possible_times_alt(p_course_id uuid, p_school_id uuid, p_user_id uuid, p_name text, p_max_students integer, p_start_date date, p_end_date date, p_is_active boolean, p_course_code text, p_is_for_year_g integer[], p_description text, p_pictures text[], p_wichtige_infos text, p_subject_id uuid, p_is_open_course boolean, p_description_visible_to_parents boolean, p_possible_times text[], p_possible_staff_members uuid[]) TO authenticated;
GRANT ALL ON FUNCTION public.update_course_with_possible_times_alt(p_course_id uuid, p_school_id uuid, p_user_id uuid, p_name text, p_max_students integer, p_start_date date, p_end_date date, p_is_active boolean, p_course_code text, p_is_for_year_g integer[], p_description text, p_pictures text[], p_wichtige_infos text, p_subject_id uuid, p_is_open_course boolean, p_description_visible_to_parents boolean, p_possible_times text[], p_possible_staff_members uuid[]) TO service_role;
GRANT ALL ON FUNCTION public.update_course_with_possible_times_alt(p_course_id uuid, p_school_id uuid, p_user_id uuid, p_name text, p_max_students integer, p_start_date date, p_end_date date, p_is_active boolean, p_course_code text, p_is_for_year_g integer[], p_description text, p_pictures text[], p_wichtige_infos text, p_subject_id uuid, p_is_open_course boolean, p_description_visible_to_parents boolean, p_possible_times text[], p_possible_staff_members uuid[]) TO test_user;


--
-- Name: FUNCTION update_registration_periods_updated_at(); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.update_registration_periods_updated_at() TO postgres;
GRANT ALL ON FUNCTION public.update_registration_periods_updated_at() TO anon;
GRANT ALL ON FUNCTION public.update_registration_periods_updated_at() TO authenticated;
GRANT ALL ON FUNCTION public.update_registration_periods_updated_at() TO service_role;
GRANT ALL ON FUNCTION public.update_registration_periods_updated_at() TO test_user;


--
-- Name: FUNCTION update_schedule_draft_info(p_draft_id uuid, p_title text, p_notes text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.update_schedule_draft_info(p_draft_id uuid, p_title text, p_notes text) TO postgres;
GRANT ALL ON FUNCTION public.update_schedule_draft_info(p_draft_id uuid, p_title text, p_notes text) TO anon;
GRANT ALL ON FUNCTION public.update_schedule_draft_info(p_draft_id uuid, p_title text, p_notes text) TO authenticated;
GRANT ALL ON FUNCTION public.update_schedule_draft_info(p_draft_id uuid, p_title text, p_notes text) TO service_role;
GRANT ALL ON FUNCTION public.update_schedule_draft_info(p_draft_id uuid, p_title text, p_notes text) TO test_user;


--
-- Name: FUNCTION update_staff_profile(p_profile_id uuid, p_user_id uuid, p_first_name text, p_last_name text, p_date_of_birth date, p_gender text, p_joined_at date, p_employee_id text, p_contacts jsonb, p_reason text, p_source text); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.update_staff_profile(p_profile_id uuid, p_user_id uuid, p_first_name text, p_last_name text, p_date_of_birth date, p_gender text, p_joined_at date, p_employee_id text, p_contacts jsonb, p_reason text, p_source text) TO postgres;
GRANT ALL ON FUNCTION public.update_staff_profile(p_profile_id uuid, p_user_id uuid, p_first_name text, p_last_name text, p_date_of_birth date, p_gender text, p_joined_at date, p_employee_id text, p_contacts jsonb, p_reason text, p_source text) TO anon;
GRANT ALL ON FUNCTION public.update_staff_profile(p_profile_id uuid, p_user_id uuid, p_first_name text, p_last_name text, p_date_of_birth date, p_gender text, p_joined_at date, p_employee_id text, p_contacts jsonb, p_reason text, p_source text) TO authenticated;
GRANT ALL ON FUNCTION public.update_staff_profile(p_profile_id uuid, p_user_id uuid, p_first_name text, p_last_name text, p_date_of_birth date, p_gender text, p_joined_at date, p_employee_id text, p_contacts jsonb, p_reason text, p_source text) TO service_role;
GRANT ALL ON FUNCTION public.update_staff_profile(p_profile_id uuid, p_user_id uuid, p_first_name text, p_last_name text, p_date_of_birth date, p_gender text, p_joined_at date, p_employee_id text, p_contacts jsonb, p_reason text, p_source text) TO test_user;


--
-- Name: FUNCTION upsert_school_days(p_school_id uuid, p_day_ids integer[]); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.upsert_school_days(p_school_id uuid, p_day_ids integer[]) TO postgres;
GRANT ALL ON FUNCTION public.upsert_school_days(p_school_id uuid, p_day_ids integer[]) TO anon;
GRANT ALL ON FUNCTION public.upsert_school_days(p_school_id uuid, p_day_ids integer[]) TO authenticated;
GRANT ALL ON FUNCTION public.upsert_school_days(p_school_id uuid, p_day_ids integer[]) TO service_role;


--
-- Name: FUNCTION use_code(input_code character varying, profile_id uuid); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.use_code(input_code character varying, profile_id uuid) TO postgres;
GRANT ALL ON FUNCTION public.use_code(input_code character varying, profile_id uuid) TO anon;
GRANT ALL ON FUNCTION public.use_code(input_code character varying, profile_id uuid) TO authenticated;
GRANT ALL ON FUNCTION public.use_code(input_code character varying, profile_id uuid) TO service_role;
GRANT ALL ON FUNCTION public.use_code(input_code character varying, profile_id uuid) TO test_user;


--
-- Name: FUNCTION whoami(); Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON FUNCTION public.whoami() TO postgres;
GRANT ALL ON FUNCTION public.whoami() TO anon;
GRANT ALL ON FUNCTION public.whoami() TO authenticated;
GRANT ALL ON FUNCTION public.whoami() TO service_role;
GRANT ALL ON FUNCTION public.whoami() TO test_user;


--
-- Name: FUNCTION apply_rls(wal jsonb, max_record_bytes integer); Type: ACL; Schema: realtime; Owner: supabase_admin
--

GRANT ALL ON FUNCTION realtime.apply_rls(wal jsonb, max_record_bytes integer) TO postgres;
GRANT ALL ON FUNCTION realtime.apply_rls(wal jsonb, max_record_bytes integer) TO dashboard_user;
GRANT ALL ON FUNCTION realtime.apply_rls(wal jsonb, max_record_bytes integer) TO anon;
GRANT ALL ON FUNCTION realtime.apply_rls(wal jsonb, max_record_bytes integer) TO authenticated;
GRANT ALL ON FUNCTION realtime.apply_rls(wal jsonb, max_record_bytes integer) TO service_role;
GRANT ALL ON FUNCTION realtime.apply_rls(wal jsonb, max_record_bytes integer) TO supabase_realtime_admin;


--
-- Name: FUNCTION broadcast_changes(topic_name text, event_name text, operation text, table_name text, table_schema text, new record, old record, level text); Type: ACL; Schema: realtime; Owner: supabase_admin
--

GRANT ALL ON FUNCTION realtime.broadcast_changes(topic_name text, event_name text, operation text, table_name text, table_schema text, new record, old record, level text) TO postgres;
GRANT ALL ON FUNCTION realtime.broadcast_changes(topic_name text, event_name text, operation text, table_name text, table_schema text, new record, old record, level text) TO dashboard_user;


--
-- Name: FUNCTION build_prepared_statement_sql(prepared_statement_name text, entity regclass, columns realtime.wal_column[]); Type: ACL; Schema: realtime; Owner: supabase_admin
--

GRANT ALL ON FUNCTION realtime.build_prepared_statement_sql(prepared_statement_name text, entity regclass, columns realtime.wal_column[]) TO postgres;
GRANT ALL ON FUNCTION realtime.build_prepared_statement_sql(prepared_statement_name text, entity regclass, columns realtime.wal_column[]) TO dashboard_user;
GRANT ALL ON FUNCTION realtime.build_prepared_statement_sql(prepared_statement_name text, entity regclass, columns realtime.wal_column[]) TO anon;
GRANT ALL ON FUNCTION realtime.build_prepared_statement_sql(prepared_statement_name text, entity regclass, columns realtime.wal_column[]) TO authenticated;
GRANT ALL ON FUNCTION realtime.build_prepared_statement_sql(prepared_statement_name text, entity regclass, columns realtime.wal_column[]) TO service_role;
GRANT ALL ON FUNCTION realtime.build_prepared_statement_sql(prepared_statement_name text, entity regclass, columns realtime.wal_column[]) TO supabase_realtime_admin;


--
-- Name: FUNCTION "cast"(val text, type_ regtype); Type: ACL; Schema: realtime; Owner: supabase_admin
--

GRANT ALL ON FUNCTION realtime."cast"(val text, type_ regtype) TO postgres;
GRANT ALL ON FUNCTION realtime."cast"(val text, type_ regtype) TO dashboard_user;
GRANT ALL ON FUNCTION realtime."cast"(val text, type_ regtype) TO anon;
GRANT ALL ON FUNCTION realtime."cast"(val text, type_ regtype) TO authenticated;
GRANT ALL ON FUNCTION realtime."cast"(val text, type_ regtype) TO service_role;
GRANT ALL ON FUNCTION realtime."cast"(val text, type_ regtype) TO supabase_realtime_admin;


--
-- Name: FUNCTION check_equality_op(op realtime.equality_op, type_ regtype, val_1 text, val_2 text); Type: ACL; Schema: realtime; Owner: supabase_admin
--

GRANT ALL ON FUNCTION realtime.check_equality_op(op realtime.equality_op, type_ regtype, val_1 text, val_2 text) TO postgres;
GRANT ALL ON FUNCTION realtime.check_equality_op(op realtime.equality_op, type_ regtype, val_1 text, val_2 text) TO dashboard_user;
GRANT ALL ON FUNCTION realtime.check_equality_op(op realtime.equality_op, type_ regtype, val_1 text, val_2 text) TO anon;
GRANT ALL ON FUNCTION realtime.check_equality_op(op realtime.equality_op, type_ regtype, val_1 text, val_2 text) TO authenticated;
GRANT ALL ON FUNCTION realtime.check_equality_op(op realtime.equality_op, type_ regtype, val_1 text, val_2 text) TO service_role;
GRANT ALL ON FUNCTION realtime.check_equality_op(op realtime.equality_op, type_ regtype, val_1 text, val_2 text) TO supabase_realtime_admin;


--
-- Name: FUNCTION is_visible_through_filters(columns realtime.wal_column[], filters realtime.user_defined_filter[]); Type: ACL; Schema: realtime; Owner: supabase_admin
--

GRANT ALL ON FUNCTION realtime.is_visible_through_filters(columns realtime.wal_column[], filters realtime.user_defined_filter[]) TO postgres;
GRANT ALL ON FUNCTION realtime.is_visible_through_filters(columns realtime.wal_column[], filters realtime.user_defined_filter[]) TO dashboard_user;
GRANT ALL ON FUNCTION realtime.is_visible_through_filters(columns realtime.wal_column[], filters realtime.user_defined_filter[]) TO anon;
GRANT ALL ON FUNCTION realtime.is_visible_through_filters(columns realtime.wal_column[], filters realtime.user_defined_filter[]) TO authenticated;
GRANT ALL ON FUNCTION realtime.is_visible_through_filters(columns realtime.wal_column[], filters realtime.user_defined_filter[]) TO service_role;
GRANT ALL ON FUNCTION realtime.is_visible_through_filters(columns realtime.wal_column[], filters realtime.user_defined_filter[]) TO supabase_realtime_admin;


--
-- Name: FUNCTION list_changes(publication name, slot_name name, max_changes integer, max_record_bytes integer); Type: ACL; Schema: realtime; Owner: supabase_admin
--

GRANT ALL ON FUNCTION realtime.list_changes(publication name, slot_name name, max_changes integer, max_record_bytes integer) TO postgres;
GRANT ALL ON FUNCTION realtime.list_changes(publication name, slot_name name, max_changes integer, max_record_bytes integer) TO dashboard_user;
GRANT ALL ON FUNCTION realtime.list_changes(publication name, slot_name name, max_changes integer, max_record_bytes integer) TO anon;
GRANT ALL ON FUNCTION realtime.list_changes(publication name, slot_name name, max_changes integer, max_record_bytes integer) TO authenticated;
GRANT ALL ON FUNCTION realtime.list_changes(publication name, slot_name name, max_changes integer, max_record_bytes integer) TO service_role;
GRANT ALL ON FUNCTION realtime.list_changes(publication name, slot_name name, max_changes integer, max_record_bytes integer) TO supabase_realtime_admin;


--
-- Name: FUNCTION quote_wal2json(entity regclass); Type: ACL; Schema: realtime; Owner: supabase_admin
--

GRANT ALL ON FUNCTION realtime.quote_wal2json(entity regclass) TO postgres;
GRANT ALL ON FUNCTION realtime.quote_wal2json(entity regclass) TO dashboard_user;
GRANT ALL ON FUNCTION realtime.quote_wal2json(entity regclass) TO anon;
GRANT ALL ON FUNCTION realtime.quote_wal2json(entity regclass) TO authenticated;
GRANT ALL ON FUNCTION realtime.quote_wal2json(entity regclass) TO service_role;
GRANT ALL ON FUNCTION realtime.quote_wal2json(entity regclass) TO supabase_realtime_admin;


--
-- Name: FUNCTION send(payload jsonb, event text, topic text, private boolean); Type: ACL; Schema: realtime; Owner: supabase_admin
--

GRANT ALL ON FUNCTION realtime.send(payload jsonb, event text, topic text, private boolean) TO postgres;
GRANT ALL ON FUNCTION realtime.send(payload jsonb, event text, topic text, private boolean) TO dashboard_user;


--
-- Name: FUNCTION subscription_check_filters(); Type: ACL; Schema: realtime; Owner: supabase_admin
--

GRANT ALL ON FUNCTION realtime.subscription_check_filters() TO postgres;
GRANT ALL ON FUNCTION realtime.subscription_check_filters() TO dashboard_user;
GRANT ALL ON FUNCTION realtime.subscription_check_filters() TO anon;
GRANT ALL ON FUNCTION realtime.subscription_check_filters() TO authenticated;
GRANT ALL ON FUNCTION realtime.subscription_check_filters() TO service_role;
GRANT ALL ON FUNCTION realtime.subscription_check_filters() TO supabase_realtime_admin;


--
-- Name: FUNCTION to_regrole(role_name text); Type: ACL; Schema: realtime; Owner: supabase_admin
--

GRANT ALL ON FUNCTION realtime.to_regrole(role_name text) TO postgres;
GRANT ALL ON FUNCTION realtime.to_regrole(role_name text) TO dashboard_user;
GRANT ALL ON FUNCTION realtime.to_regrole(role_name text) TO anon;
GRANT ALL ON FUNCTION realtime.to_regrole(role_name text) TO authenticated;
GRANT ALL ON FUNCTION realtime.to_regrole(role_name text) TO service_role;
GRANT ALL ON FUNCTION realtime.to_regrole(role_name text) TO supabase_realtime_admin;


--
-- Name: FUNCTION topic(); Type: ACL; Schema: realtime; Owner: supabase_realtime_admin
--

GRANT ALL ON FUNCTION realtime.topic() TO postgres;
GRANT ALL ON FUNCTION realtime.topic() TO dashboard_user;


--
-- Name: FUNCTION extract_school_id_from_path(object_path text); Type: ACL; Schema: storage; Owner: supabase_admin
--

GRANT ALL ON FUNCTION storage.extract_school_id_from_path(object_path text) TO authenticated;


--
-- Name: FUNCTION get_object_school_id(object_metadata jsonb); Type: ACL; Schema: storage; Owner: supabase_admin
--

GRANT ALL ON FUNCTION storage.get_object_school_id(object_metadata jsonb) TO authenticated;


--
-- Name: FUNCTION is_public_bucket(bucket_name text); Type: ACL; Schema: storage; Owner: supabase_admin
--

GRANT ALL ON FUNCTION storage.is_public_bucket(bucket_name text) TO authenticated;


--
-- Name: FUNCTION http_request(); Type: ACL; Schema: supabase_functions; Owner: supabase_functions_admin
--

REVOKE ALL ON FUNCTION supabase_functions.http_request() FROM PUBLIC;
GRANT ALL ON FUNCTION supabase_functions.http_request() TO anon;
GRANT ALL ON FUNCTION supabase_functions.http_request() TO authenticated;
GRANT ALL ON FUNCTION supabase_functions.http_request() TO service_role;
GRANT ALL ON FUNCTION supabase_functions.http_request() TO postgres;


--
-- Name: FUNCTION _crypto_aead_det_decrypt(message bytea, additional bytea, key_id bigint, context bytea, nonce bytea); Type: ACL; Schema: vault; Owner: supabase_admin
--

GRANT ALL ON FUNCTION vault._crypto_aead_det_decrypt(message bytea, additional bytea, key_id bigint, context bytea, nonce bytea) TO postgres WITH GRANT OPTION;


--
-- Name: FUNCTION create_secret(new_secret text, new_name text, new_description text, new_key_id uuid); Type: ACL; Schema: vault; Owner: supabase_admin
--

GRANT ALL ON FUNCTION vault.create_secret(new_secret text, new_name text, new_description text, new_key_id uuid) TO postgres WITH GRANT OPTION;


--
-- Name: FUNCTION update_secret(secret_id uuid, new_secret text, new_name text, new_description text, new_key_id uuid); Type: ACL; Schema: vault; Owner: supabase_admin
--

GRANT ALL ON FUNCTION vault.update_secret(secret_id uuid, new_secret text, new_name text, new_description text, new_key_id uuid) TO postgres WITH GRANT OPTION;


--
-- Name: TABLE audit_log_entries; Type: ACL; Schema: auth; Owner: supabase_auth_admin
--

GRANT ALL ON TABLE auth.audit_log_entries TO dashboard_user;
GRANT INSERT,REFERENCES,DELETE,TRIGGER,TRUNCATE,UPDATE ON TABLE auth.audit_log_entries TO postgres;
GRANT SELECT ON TABLE auth.audit_log_entries TO postgres WITH GRANT OPTION;


--
-- Name: TABLE flow_state; Type: ACL; Schema: auth; Owner: supabase_auth_admin
--

GRANT INSERT,REFERENCES,DELETE,TRIGGER,TRUNCATE,UPDATE ON TABLE auth.flow_state TO postgres;
GRANT SELECT ON TABLE auth.flow_state TO postgres WITH GRANT OPTION;
GRANT ALL ON TABLE auth.flow_state TO dashboard_user;


--
-- Name: TABLE identities; Type: ACL; Schema: auth; Owner: supabase_auth_admin
--

GRANT INSERT,REFERENCES,DELETE,TRIGGER,TRUNCATE,UPDATE ON TABLE auth.identities TO postgres;
GRANT SELECT ON TABLE auth.identities TO postgres WITH GRANT OPTION;
GRANT ALL ON TABLE auth.identities TO dashboard_user;


--
-- Name: TABLE instances; Type: ACL; Schema: auth; Owner: supabase_auth_admin
--

GRANT ALL ON TABLE auth.instances TO dashboard_user;
GRANT INSERT,REFERENCES,DELETE,TRIGGER,TRUNCATE,UPDATE ON TABLE auth.instances TO postgres;
GRANT SELECT ON TABLE auth.instances TO postgres WITH GRANT OPTION;


--
-- Name: TABLE mfa_amr_claims; Type: ACL; Schema: auth; Owner: supabase_auth_admin
--

GRANT INSERT,REFERENCES,DELETE,TRIGGER,TRUNCATE,UPDATE ON TABLE auth.mfa_amr_claims TO postgres;
GRANT SELECT ON TABLE auth.mfa_amr_claims TO postgres WITH GRANT OPTION;
GRANT ALL ON TABLE auth.mfa_amr_claims TO dashboard_user;


--
-- Name: TABLE mfa_challenges; Type: ACL; Schema: auth; Owner: supabase_auth_admin
--

GRANT INSERT,REFERENCES,DELETE,TRIGGER,TRUNCATE,UPDATE ON TABLE auth.mfa_challenges TO postgres;
GRANT SELECT ON TABLE auth.mfa_challenges TO postgres WITH GRANT OPTION;
GRANT ALL ON TABLE auth.mfa_challenges TO dashboard_user;


--
-- Name: TABLE mfa_factors; Type: ACL; Schema: auth; Owner: supabase_auth_admin
--

GRANT INSERT,REFERENCES,DELETE,TRIGGER,TRUNCATE,UPDATE ON TABLE auth.mfa_factors TO postgres;
GRANT SELECT ON TABLE auth.mfa_factors TO postgres WITH GRANT OPTION;
GRANT ALL ON TABLE auth.mfa_factors TO dashboard_user;


--
-- Name: TABLE one_time_tokens; Type: ACL; Schema: auth; Owner: supabase_auth_admin
--

GRANT INSERT,REFERENCES,DELETE,TRIGGER,TRUNCATE,UPDATE ON TABLE auth.one_time_tokens TO postgres;
GRANT SELECT ON TABLE auth.one_time_tokens TO postgres WITH GRANT OPTION;
GRANT ALL ON TABLE auth.one_time_tokens TO dashboard_user;


--
-- Name: TABLE refresh_tokens; Type: ACL; Schema: auth; Owner: supabase_auth_admin
--

GRANT ALL ON TABLE auth.refresh_tokens TO dashboard_user;
GRANT INSERT,REFERENCES,DELETE,TRIGGER,TRUNCATE,UPDATE ON TABLE auth.refresh_tokens TO postgres;
GRANT SELECT ON TABLE auth.refresh_tokens TO postgres WITH GRANT OPTION;


--
-- Name: SEQUENCE refresh_tokens_id_seq; Type: ACL; Schema: auth; Owner: supabase_auth_admin
--

GRANT ALL ON SEQUENCE auth.refresh_tokens_id_seq TO dashboard_user;
GRANT ALL ON SEQUENCE auth.refresh_tokens_id_seq TO postgres;


--
-- Name: TABLE saml_providers; Type: ACL; Schema: auth; Owner: supabase_auth_admin
--

GRANT INSERT,REFERENCES,DELETE,TRIGGER,TRUNCATE,UPDATE ON TABLE auth.saml_providers TO postgres;
GRANT SELECT ON TABLE auth.saml_providers TO postgres WITH GRANT OPTION;
GRANT ALL ON TABLE auth.saml_providers TO dashboard_user;


--
-- Name: TABLE saml_relay_states; Type: ACL; Schema: auth; Owner: supabase_auth_admin
--

GRANT INSERT,REFERENCES,DELETE,TRIGGER,TRUNCATE,UPDATE ON TABLE auth.saml_relay_states TO postgres;
GRANT SELECT ON TABLE auth.saml_relay_states TO postgres WITH GRANT OPTION;
GRANT ALL ON TABLE auth.saml_relay_states TO dashboard_user;


--
-- Name: TABLE schema_migrations; Type: ACL; Schema: auth; Owner: supabase_auth_admin
--

GRANT ALL ON TABLE auth.schema_migrations TO dashboard_user;
GRANT INSERT,REFERENCES,DELETE,TRIGGER,TRUNCATE,UPDATE ON TABLE auth.schema_migrations TO postgres;
GRANT SELECT ON TABLE auth.schema_migrations TO postgres WITH GRANT OPTION;


--
-- Name: TABLE sessions; Type: ACL; Schema: auth; Owner: supabase_auth_admin
--

GRANT INSERT,REFERENCES,DELETE,TRIGGER,TRUNCATE,UPDATE ON TABLE auth.sessions TO postgres;
GRANT SELECT ON TABLE auth.sessions TO postgres WITH GRANT OPTION;
GRANT ALL ON TABLE auth.sessions TO dashboard_user;


--
-- Name: TABLE sso_domains; Type: ACL; Schema: auth; Owner: supabase_auth_admin
--

GRANT INSERT,REFERENCES,DELETE,TRIGGER,TRUNCATE,UPDATE ON TABLE auth.sso_domains TO postgres;
GRANT SELECT ON TABLE auth.sso_domains TO postgres WITH GRANT OPTION;
GRANT ALL ON TABLE auth.sso_domains TO dashboard_user;


--
-- Name: TABLE sso_providers; Type: ACL; Schema: auth; Owner: supabase_auth_admin
--

GRANT INSERT,REFERENCES,DELETE,TRIGGER,TRUNCATE,UPDATE ON TABLE auth.sso_providers TO postgres;
GRANT SELECT ON TABLE auth.sso_providers TO postgres WITH GRANT OPTION;
GRANT ALL ON TABLE auth.sso_providers TO dashboard_user;


--
-- Name: TABLE users; Type: ACL; Schema: auth; Owner: supabase_auth_admin
--

GRANT ALL ON TABLE auth.users TO dashboard_user;
GRANT INSERT,REFERENCES,DELETE,TRIGGER,TRUNCATE,UPDATE ON TABLE auth.users TO postgres;
GRANT SELECT ON TABLE auth.users TO postgres WITH GRANT OPTION;


--
-- Name: TABLE pg_stat_statements; Type: ACL; Schema: extensions; Owner: supabase_admin
--

GRANT ALL ON TABLE extensions.pg_stat_statements TO postgres WITH GRANT OPTION;


--
-- Name: TABLE pg_stat_statements_info; Type: ACL; Schema: extensions; Owner: supabase_admin
--

GRANT ALL ON TABLE extensions.pg_stat_statements_info TO postgres WITH GRANT OPTION;


--
-- Name: TABLE bulletin_post_users; Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON TABLE public.bulletin_post_users TO postgres;
GRANT ALL ON TABLE public.bulletin_post_users TO anon;
GRANT ALL ON TABLE public.bulletin_post_users TO authenticated;
GRANT ALL ON TABLE public.bulletin_post_users TO service_role;
GRANT SELECT ON TABLE public.bulletin_post_users TO test_user;


--
-- Name: TABLE bulletin_posts; Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON TABLE public.bulletin_posts TO postgres;
GRANT ALL ON TABLE public.bulletin_posts TO anon;
GRANT ALL ON TABLE public.bulletin_posts TO authenticated;
GRANT ALL ON TABLE public.bulletin_posts TO service_role;
GRANT SELECT ON TABLE public.bulletin_posts TO test_user;


--
-- Name: TABLE bulletin_recurrences; Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON TABLE public.bulletin_recurrences TO postgres;
GRANT ALL ON TABLE public.bulletin_recurrences TO anon;
GRANT ALL ON TABLE public.bulletin_recurrences TO authenticated;
GRANT ALL ON TABLE public.bulletin_recurrences TO service_role;
GRANT SELECT ON TABLE public.bulletin_recurrences TO test_user;


--
-- Name: TABLE change_log; Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON TABLE public.change_log TO postgres;
GRANT ALL ON TABLE public.change_log TO anon;
GRANT ALL ON TABLE public.change_log TO authenticated;
GRANT ALL ON TABLE public.change_log TO service_role;
GRANT SELECT ON TABLE public.change_log TO test_user;


--
-- Name: TABLE contacts; Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON TABLE public.contacts TO postgres;
GRANT ALL ON TABLE public.contacts TO anon;
GRANT ALL ON TABLE public.contacts TO authenticated;
GRANT ALL ON TABLE public.contacts TO service_role;
GRANT SELECT ON TABLE public.contacts TO test_user;


--
-- Name: TABLE course_allocation_drafts; Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON TABLE public.course_allocation_drafts TO postgres;
GRANT ALL ON TABLE public.course_allocation_drafts TO anon;
GRANT ALL ON TABLE public.course_allocation_drafts TO authenticated;
GRANT ALL ON TABLE public.course_allocation_drafts TO service_role;
GRANT SELECT ON TABLE public.course_allocation_drafts TO test_user;


--
-- Name: TABLE course_applications; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.course_applications TO anon;
GRANT ALL ON TABLE public.course_applications TO authenticated;
GRANT ALL ON TABLE public.course_applications TO service_role;
GRANT SELECT ON TABLE public.course_applications TO test_user;


--
-- Name: TABLE course_enrollments; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.course_enrollments TO anon;
GRANT ALL ON TABLE public.course_enrollments TO authenticated;
GRANT ALL ON TABLE public.course_enrollments TO service_role;
GRANT SELECT ON TABLE public.course_enrollments TO test_user;


--
-- Name: TABLE course_lessons; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.course_lessons TO anon;
GRANT ALL ON TABLE public.course_lessons TO authenticated;
GRANT ALL ON TABLE public.course_lessons TO service_role;
GRANT SELECT ON TABLE public.course_lessons TO test_user;


--
-- Name: TABLE course_list; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.course_list TO anon;
GRANT ALL ON TABLE public.course_list TO authenticated;
GRANT ALL ON TABLE public.course_list TO service_role;
GRANT SELECT ON TABLE public.course_list TO test_user;


--
-- Name: TABLE course_notes; Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON TABLE public.course_notes TO postgres;
GRANT ALL ON TABLE public.course_notes TO anon;
GRANT ALL ON TABLE public.course_notes TO authenticated;
GRANT ALL ON TABLE public.course_notes TO service_role;
GRANT SELECT ON TABLE public.course_notes TO test_user;


--
-- Name: TABLE course_offers; Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON TABLE public.course_offers TO postgres;
GRANT ALL ON TABLE public.course_offers TO anon;
GRANT ALL ON TABLE public.course_offers TO authenticated;
GRANT ALL ON TABLE public.course_offers TO service_role;


--
-- Name: TABLE course_possible_times; Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON TABLE public.course_possible_times TO postgres;
GRANT ALL ON TABLE public.course_possible_times TO anon;
GRANT ALL ON TABLE public.course_possible_times TO authenticated;
GRANT ALL ON TABLE public.course_possible_times TO service_role;
GRANT SELECT ON TABLE public.course_possible_times TO test_user;


--
-- Name: TABLE course_registration_windows; Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON TABLE public.course_registration_windows TO postgres;
GRANT ALL ON TABLE public.course_registration_windows TO anon;
GRANT ALL ON TABLE public.course_registration_windows TO authenticated;
GRANT ALL ON TABLE public.course_registration_windows TO service_role;
GRANT SELECT ON TABLE public.course_registration_windows TO test_user;


--
-- Name: TABLE course_schedules; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.course_schedules TO anon;
GRANT ALL ON TABLE public.course_schedules TO authenticated;
GRANT ALL ON TABLE public.course_schedules TO service_role;
GRANT SELECT ON TABLE public.course_schedules TO test_user;


--
-- Name: TABLE debug_logs; Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON TABLE public.debug_logs TO postgres;
GRANT ALL ON TABLE public.debug_logs TO anon;
GRANT ALL ON TABLE public.debug_logs TO authenticated;
GRANT ALL ON TABLE public.debug_logs TO service_role;
GRANT SELECT ON TABLE public.debug_logs TO test_user;


--
-- Name: SEQUENCE debug_logs_id_seq; Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON SEQUENCE public.debug_logs_id_seq TO postgres;
GRANT ALL ON SEQUENCE public.debug_logs_id_seq TO anon;
GRANT ALL ON SEQUENCE public.debug_logs_id_seq TO authenticated;
GRANT ALL ON SEQUENCE public.debug_logs_id_seq TO service_role;


--
-- Name: TABLE document_types; Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON TABLE public.document_types TO postgres;
GRANT ALL ON TABLE public.document_types TO anon;
GRANT ALL ON TABLE public.document_types TO authenticated;
GRANT ALL ON TABLE public.document_types TO service_role;
GRANT SELECT ON TABLE public.document_types TO test_user;


--
-- Name: TABLE families; Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON TABLE public.families TO postgres;
GRANT ALL ON TABLE public.families TO anon;
GRANT ALL ON TABLE public.families TO authenticated;
GRANT ALL ON TABLE public.families TO service_role;
GRANT SELECT ON TABLE public.families TO test_user;


--
-- Name: TABLE family_member_child_links; Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON TABLE public.family_member_child_links TO postgres;
GRANT ALL ON TABLE public.family_member_child_links TO anon;
GRANT ALL ON TABLE public.family_member_child_links TO authenticated;
GRANT ALL ON TABLE public.family_member_child_links TO service_role;
GRANT SELECT ON TABLE public.family_member_child_links TO test_user;


--
-- Name: TABLE family_members; Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON TABLE public.family_members TO postgres;
GRANT ALL ON TABLE public.family_members TO anon;
GRANT ALL ON TABLE public.family_members TO authenticated;
GRANT ALL ON TABLE public.family_members TO service_role;
GRANT SELECT ON TABLE public.family_members TO test_user;


--
-- Name: TABLE ingest_interview_debug_log; Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON TABLE public.ingest_interview_debug_log TO postgres;
GRANT ALL ON TABLE public.ingest_interview_debug_log TO anon;
GRANT ALL ON TABLE public.ingest_interview_debug_log TO authenticated;
GRANT ALL ON TABLE public.ingest_interview_debug_log TO service_role;
GRANT SELECT ON TABLE public.ingest_interview_debug_log TO test_user;


--
-- Name: SEQUENCE ingest_interview_debug_log_id_seq; Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON SEQUENCE public.ingest_interview_debug_log_id_seq TO postgres;
GRANT ALL ON SEQUENCE public.ingest_interview_debug_log_id_seq TO anon;
GRANT ALL ON SEQUENCE public.ingest_interview_debug_log_id_seq TO authenticated;
GRANT ALL ON SEQUENCE public.ingest_interview_debug_log_id_seq TO service_role;


--
-- Name: TABLE lesson_diary_entries; Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON TABLE public.lesson_diary_entries TO postgres;
GRANT ALL ON TABLE public.lesson_diary_entries TO anon;
GRANT ALL ON TABLE public.lesson_diary_entries TO authenticated;
GRANT ALL ON TABLE public.lesson_diary_entries TO service_role;


--
-- Name: TABLE profile_info_family_member; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.profile_info_family_member TO anon;
GRANT ALL ON TABLE public.profile_info_family_member TO authenticated;
GRANT ALL ON TABLE public.profile_info_family_member TO service_role;
GRANT SELECT ON TABLE public.profile_info_family_member TO test_user;


--
-- Name: TABLE profile_info_staff; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.profile_info_staff TO anon;
GRANT ALL ON TABLE public.profile_info_staff TO authenticated;
GRANT ALL ON TABLE public.profile_info_staff TO service_role;
GRANT SELECT ON TABLE public.profile_info_staff TO test_user;


--
-- Name: TABLE profile_info_student; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.profile_info_student TO anon;
GRANT ALL ON TABLE public.profile_info_student TO authenticated;
GRANT ALL ON TABLE public.profile_info_student TO service_role;
GRANT SELECT ON TABLE public.profile_info_student TO test_user;


--
-- Name: TABLE protected_roles; Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON TABLE public.protected_roles TO postgres;
GRANT ALL ON TABLE public.protected_roles TO anon;
GRANT ALL ON TABLE public.protected_roles TO authenticated;
GRANT ALL ON TABLE public.protected_roles TO service_role;


--
-- Name: TABLE public_holiday_and_breaks; Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON TABLE public.public_holiday_and_breaks TO postgres;
GRANT ALL ON TABLE public.public_holiday_and_breaks TO anon;
GRANT ALL ON TABLE public.public_holiday_and_breaks TO authenticated;
GRANT ALL ON TABLE public.public_holiday_and_breaks TO service_role;
GRANT SELECT ON TABLE public.public_holiday_and_breaks TO test_user;


--
-- Name: TABLE published_drafts; Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON TABLE public.published_drafts TO postgres;
GRANT ALL ON TABLE public.published_drafts TO anon;
GRANT ALL ON TABLE public.published_drafts TO authenticated;
GRANT ALL ON TABLE public.published_drafts TO service_role;
GRANT SELECT ON TABLE public.published_drafts TO test_user;


--
-- Name: TABLE recurrence_debug_log; Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON TABLE public.recurrence_debug_log TO postgres;
GRANT ALL ON TABLE public.recurrence_debug_log TO anon;
GRANT ALL ON TABLE public.recurrence_debug_log TO authenticated;
GRANT ALL ON TABLE public.recurrence_debug_log TO service_role;
GRANT SELECT ON TABLE public.recurrence_debug_log TO test_user;


--
-- Name: SEQUENCE recurrence_debug_log_id_seq; Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON SEQUENCE public.recurrence_debug_log_id_seq TO postgres;
GRANT ALL ON SEQUENCE public.recurrence_debug_log_id_seq TO anon;
GRANT ALL ON SEQUENCE public.recurrence_debug_log_id_seq TO authenticated;
GRANT ALL ON SEQUENCE public.recurrence_debug_log_id_seq TO service_role;


--
-- Name: TABLE registration_periods; Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON TABLE public.registration_periods TO postgres;
GRANT ALL ON TABLE public.registration_periods TO anon;
GRANT ALL ON TABLE public.registration_periods TO authenticated;
GRANT ALL ON TABLE public.registration_periods TO service_role;
GRANT SELECT ON TABLE public.registration_periods TO test_user;


--
-- Name: TABLE roles; Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON TABLE public.roles TO postgres;
GRANT ALL ON TABLE public.roles TO anon;
GRANT ALL ON TABLE public.roles TO authenticated;
GRANT ALL ON TABLE public.roles TO service_role;
GRANT SELECT ON TABLE public.roles TO test_user;


--
-- Name: TABLE schedule_calendar_exceptions; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.schedule_calendar_exceptions TO anon;
GRANT ALL ON TABLE public.schedule_calendar_exceptions TO authenticated;
GRANT ALL ON TABLE public.schedule_calendar_exceptions TO service_role;
GRANT SELECT ON TABLE public.schedule_calendar_exceptions TO test_user;


--
-- Name: TABLE schedule_daily_rostering; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.schedule_daily_rostering TO anon;
GRANT ALL ON TABLE public.schedule_daily_rostering TO authenticated;
GRANT ALL ON TABLE public.schedule_daily_rostering TO service_role;
GRANT SELECT ON TABLE public.schedule_daily_rostering TO test_user;


--
-- Name: TABLE schedule_drafts; Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON TABLE public.schedule_drafts TO postgres;
GRANT ALL ON TABLE public.schedule_drafts TO anon;
GRANT ALL ON TABLE public.schedule_drafts TO authenticated;
GRANT ALL ON TABLE public.schedule_drafts TO service_role;
GRANT SELECT ON TABLE public.schedule_drafts TO test_user;


--
-- Name: TABLE schedule_periods; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.schedule_periods TO anon;
GRANT ALL ON TABLE public.schedule_periods TO authenticated;
GRANT ALL ON TABLE public.schedule_periods TO service_role;
GRANT SELECT ON TABLE public.schedule_periods TO test_user;


--
-- Name: TABLE schema_change_log; Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON TABLE public.schema_change_log TO postgres;
GRANT ALL ON TABLE public.schema_change_log TO anon;
GRANT ALL ON TABLE public.schema_change_log TO authenticated;
GRANT ALL ON TABLE public.schema_change_log TO service_role;
GRANT SELECT ON TABLE public.schema_change_log TO test_user;


--
-- Name: SEQUENCE schema_change_log_id_seq; Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON SEQUENCE public.schema_change_log_id_seq TO postgres;
GRANT ALL ON SEQUENCE public.schema_change_log_id_seq TO anon;
GRANT ALL ON SEQUENCE public.schema_change_log_id_seq TO authenticated;
GRANT ALL ON SEQUENCE public.schema_change_log_id_seq TO service_role;


--
-- Name: TABLE staff_absence_comments; Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON TABLE public.staff_absence_comments TO postgres;
GRANT ALL ON TABLE public.staff_absence_comments TO anon;
GRANT ALL ON TABLE public.staff_absence_comments TO authenticated;
GRANT ALL ON TABLE public.staff_absence_comments TO service_role;
GRANT SELECT ON TABLE public.staff_absence_comments TO test_user;


--
-- Name: TABLE staff_absences; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.staff_absences TO anon;
GRANT ALL ON TABLE public.staff_absences TO authenticated;
GRANT ALL ON TABLE public.staff_absences TO service_role;
GRANT SELECT ON TABLE public.staff_absences TO test_user;


--
-- Name: TABLE staff_class_links; Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON TABLE public.staff_class_links TO postgres;
GRANT ALL ON TABLE public.staff_class_links TO anon;
GRANT ALL ON TABLE public.staff_class_links TO authenticated;
GRANT ALL ON TABLE public.staff_class_links TO service_role;
GRANT SELECT ON TABLE public.staff_class_links TO test_user;


--
-- Name: TABLE staff_contracts; Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON TABLE public.staff_contracts TO postgres;
GRANT ALL ON TABLE public.staff_contracts TO anon;
GRANT ALL ON TABLE public.staff_contracts TO authenticated;
GRANT ALL ON TABLE public.staff_contracts TO service_role;
GRANT SELECT ON TABLE public.staff_contracts TO test_user;


--
-- Name: TABLE staff_documents; Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON TABLE public.staff_documents TO postgres;
GRANT ALL ON TABLE public.staff_documents TO anon;
GRANT ALL ON TABLE public.staff_documents TO authenticated;
GRANT ALL ON TABLE public.staff_documents TO service_role;
GRANT SELECT ON TABLE public.staff_documents TO test_user;


--
-- Name: TABLE staff_duty_plan; Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON TABLE public.staff_duty_plan TO postgres;
GRANT ALL ON TABLE public.staff_duty_plan TO anon;
GRANT ALL ON TABLE public.staff_duty_plan TO authenticated;
GRANT ALL ON TABLE public.staff_duty_plan TO service_role;
GRANT SELECT ON TABLE public.staff_duty_plan TO test_user;


--
-- Name: TABLE staff_subjects; Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON TABLE public.staff_subjects TO postgres;
GRANT ALL ON TABLE public.staff_subjects TO anon;
GRANT ALL ON TABLE public.staff_subjects TO authenticated;
GRANT ALL ON TABLE public.staff_subjects TO service_role;
GRANT SELECT ON TABLE public.staff_subjects TO test_user;


--
-- Name: TABLE staff_work_contracts; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.staff_work_contracts TO anon;
GRANT ALL ON TABLE public.staff_work_contracts TO authenticated;
GRANT ALL ON TABLE public.staff_work_contracts TO service_role;
GRANT SELECT ON TABLE public.staff_work_contracts TO test_user;


--
-- Name: TABLE staff_yearly_preferences; Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON TABLE public.staff_yearly_preferences TO postgres;
GRANT ALL ON TABLE public.staff_yearly_preferences TO anon;
GRANT ALL ON TABLE public.staff_yearly_preferences TO authenticated;
GRANT ALL ON TABLE public.staff_yearly_preferences TO service_role;
GRANT SELECT ON TABLE public.staff_yearly_preferences TO test_user;


--
-- Name: TABLE structure_classes; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.structure_classes TO anon;
GRANT ALL ON TABLE public.structure_classes TO authenticated;
GRANT ALL ON TABLE public.structure_classes TO service_role;
GRANT SELECT ON TABLE public.structure_classes TO test_user;


--
-- Name: TABLE structure_days; Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON TABLE public.structure_days TO postgres;
GRANT ALL ON TABLE public.structure_days TO anon;
GRANT ALL ON TABLE public.structure_days TO authenticated;
GRANT ALL ON TABLE public.structure_days TO service_role;
GRANT SELECT ON TABLE public.structure_days TO test_user;


--
-- Name: SEQUENCE structure_days_id_seq; Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON SEQUENCE public.structure_days_id_seq TO postgres;
GRANT ALL ON SEQUENCE public.structure_days_id_seq TO anon;
GRANT ALL ON SEQUENCE public.structure_days_id_seq TO authenticated;
GRANT ALL ON SEQUENCE public.structure_days_id_seq TO service_role;


--
-- Name: TABLE structure_rooms; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.structure_rooms TO anon;
GRANT ALL ON TABLE public.structure_rooms TO authenticated;
GRANT ALL ON TABLE public.structure_rooms TO service_role;
GRANT SELECT ON TABLE public.structure_rooms TO test_user;


--
-- Name: TABLE structure_school_days; Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON TABLE public.structure_school_days TO postgres;
GRANT ALL ON TABLE public.structure_school_days TO anon;
GRANT ALL ON TABLE public.structure_school_days TO authenticated;
GRANT ALL ON TABLE public.structure_school_days TO service_role;
GRANT SELECT ON TABLE public.structure_school_days TO test_user;


--
-- Name: TABLE structure_school_semesters; Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON TABLE public.structure_school_semesters TO postgres;
GRANT ALL ON TABLE public.structure_school_semesters TO anon;
GRANT ALL ON TABLE public.structure_school_semesters TO authenticated;
GRANT ALL ON TABLE public.structure_school_semesters TO service_role;
GRANT SELECT ON TABLE public.structure_school_semesters TO test_user;


--
-- Name: TABLE structure_school_years; Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON TABLE public.structure_school_years TO postgres;
GRANT ALL ON TABLE public.structure_school_years TO anon;
GRANT ALL ON TABLE public.structure_school_years TO authenticated;
GRANT ALL ON TABLE public.structure_school_years TO service_role;
GRANT SELECT ON TABLE public.structure_school_years TO test_user;


--
-- Name: TABLE structure_schools; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.structure_schools TO anon;
GRANT ALL ON TABLE public.structure_schools TO authenticated;
GRANT ALL ON TABLE public.structure_schools TO service_role;
GRANT SELECT ON TABLE public.structure_schools TO test_user;


--
-- Name: TABLE student_absence_notes; Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON TABLE public.student_absence_notes TO postgres;
GRANT ALL ON TABLE public.student_absence_notes TO anon;
GRANT ALL ON TABLE public.student_absence_notes TO authenticated;
GRANT ALL ON TABLE public.student_absence_notes TO service_role;
GRANT SELECT ON TABLE public.student_absence_notes TO test_user;


--
-- Name: TABLE student_absence_recurrences; Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON TABLE public.student_absence_recurrences TO postgres;
GRANT ALL ON TABLE public.student_absence_recurrences TO anon;
GRANT ALL ON TABLE public.student_absence_recurrences TO authenticated;
GRANT ALL ON TABLE public.student_absence_recurrences TO service_role;
GRANT SELECT ON TABLE public.student_absence_recurrences TO test_user;


--
-- Name: TABLE student_attendance_logs; Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON TABLE public.student_attendance_logs TO postgres;
GRANT ALL ON TABLE public.student_attendance_logs TO anon;
GRANT ALL ON TABLE public.student_attendance_logs TO authenticated;
GRANT ALL ON TABLE public.student_attendance_logs TO service_role;
GRANT SELECT ON TABLE public.student_attendance_logs TO test_user;


--
-- Name: TABLE student_course_wish_choices; Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON TABLE public.student_course_wish_choices TO postgres;
GRANT ALL ON TABLE public.student_course_wish_choices TO anon;
GRANT ALL ON TABLE public.student_course_wish_choices TO authenticated;
GRANT ALL ON TABLE public.student_course_wish_choices TO service_role;
GRANT SELECT ON TABLE public.student_course_wish_choices TO test_user;


--
-- Name: TABLE student_course_wish_submissions; Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON TABLE public.student_course_wish_submissions TO postgres;
GRANT ALL ON TABLE public.student_course_wish_submissions TO anon;
GRANT ALL ON TABLE public.student_course_wish_submissions TO authenticated;
GRANT ALL ON TABLE public.student_course_wish_submissions TO service_role;
GRANT SELECT ON TABLE public.student_course_wish_submissions TO test_user;


--
-- Name: TABLE student_daily_log; Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON TABLE public.student_daily_log TO postgres;
GRANT ALL ON TABLE public.student_daily_log TO anon;
GRANT ALL ON TABLE public.student_daily_log TO authenticated;
GRANT ALL ON TABLE public.student_daily_log TO service_role;
GRANT ALL ON TABLE public.student_daily_log TO supabase_realtime;
GRANT SELECT ON TABLE public.student_daily_log TO test_user;


--
-- Name: TABLE student_emergency_information; Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON TABLE public.student_emergency_information TO postgres;
GRANT ALL ON TABLE public.student_emergency_information TO anon;
GRANT ALL ON TABLE public.student_emergency_information TO authenticated;
GRANT ALL ON TABLE public.student_emergency_information TO service_role;


--
-- Name: TABLE student_pickup_arrangement_overrides; Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON TABLE public.student_pickup_arrangement_overrides TO postgres;
GRANT ALL ON TABLE public.student_pickup_arrangement_overrides TO anon;
GRANT ALL ON TABLE public.student_pickup_arrangement_overrides TO authenticated;
GRANT ALL ON TABLE public.student_pickup_arrangement_overrides TO service_role;
GRANT SELECT ON TABLE public.student_pickup_arrangement_overrides TO test_user;


--
-- Name: TABLE student_presence_events; Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON TABLE public.student_presence_events TO postgres;
GRANT ALL ON TABLE public.student_presence_events TO anon;
GRANT ALL ON TABLE public.student_presence_events TO authenticated;
GRANT ALL ON TABLE public.student_presence_events TO service_role;
GRANT SELECT ON TABLE public.student_presence_events TO test_user;


--
-- Name: TABLE student_weekly_pickup_arrangements; Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON TABLE public.student_weekly_pickup_arrangements TO postgres;
GRANT ALL ON TABLE public.student_weekly_pickup_arrangements TO anon;
GRANT ALL ON TABLE public.student_weekly_pickup_arrangements TO authenticated;
GRANT ALL ON TABLE public.student_weekly_pickup_arrangements TO service_role;
GRANT SELECT ON TABLE public.student_weekly_pickup_arrangements TO test_user;


--
-- Name: TABLE subject_class_hours; Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON TABLE public.subject_class_hours TO postgres;
GRANT ALL ON TABLE public.subject_class_hours TO anon;
GRANT ALL ON TABLE public.subject_class_hours TO authenticated;
GRANT ALL ON TABLE public.subject_class_hours TO service_role;
GRANT SELECT ON TABLE public.subject_class_hours TO test_user;


--
-- Name: TABLE subject_grade_hours; Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON TABLE public.subject_grade_hours TO postgres;
GRANT ALL ON TABLE public.subject_grade_hours TO anon;
GRANT ALL ON TABLE public.subject_grade_hours TO authenticated;
GRANT ALL ON TABLE public.subject_grade_hours TO service_role;
GRANT SELECT ON TABLE public.subject_grade_hours TO test_user;


--
-- Name: TABLE subject_icons; Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON TABLE public.subject_icons TO postgres;
GRANT ALL ON TABLE public.subject_icons TO anon;
GRANT ALL ON TABLE public.subject_icons TO authenticated;
GRANT ALL ON TABLE public.subject_icons TO service_role;
GRANT SELECT ON TABLE public.subject_icons TO test_user;


--
-- Name: TABLE subjects; Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON TABLE public.subjects TO postgres;
GRANT ALL ON TABLE public.subjects TO anon;
GRANT ALL ON TABLE public.subjects TO authenticated;
GRANT ALL ON TABLE public.subjects TO service_role;
GRANT SELECT ON TABLE public.subjects TO test_user;


--
-- Name: TABLE substitutions; Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON TABLE public.substitutions TO postgres;
GRANT ALL ON TABLE public.substitutions TO anon;
GRANT ALL ON TABLE public.substitutions TO authenticated;
GRANT ALL ON TABLE public.substitutions TO service_role;
GRANT SELECT ON TABLE public.substitutions TO test_user;


--
-- Name: TABLE user_codes; Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON TABLE public.user_codes TO postgres;
GRANT ALL ON TABLE public.user_codes TO anon;
GRANT ALL ON TABLE public.user_codes TO authenticated;
GRANT ALL ON TABLE public.user_codes TO service_role;
GRANT SELECT ON TABLE public.user_codes TO test_user;


--
-- Name: TABLE user_group_members; Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON TABLE public.user_group_members TO postgres;
GRANT ALL ON TABLE public.user_group_members TO anon;
GRANT ALL ON TABLE public.user_group_members TO authenticated;
GRANT ALL ON TABLE public.user_group_members TO service_role;
GRANT SELECT ON TABLE public.user_group_members TO test_user;


--
-- Name: TABLE user_groups; Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON TABLE public.user_groups TO postgres;
GRANT ALL ON TABLE public.user_groups TO anon;
GRANT ALL ON TABLE public.user_groups TO authenticated;
GRANT ALL ON TABLE public.user_groups TO service_role;
GRANT SELECT ON TABLE public.user_groups TO test_user;


--
-- Name: TABLE user_profiles; Type: ACL; Schema: public; Owner: postgres
--

GRANT ALL ON TABLE public.user_profiles TO anon;
GRANT ALL ON TABLE public.user_profiles TO authenticated;
GRANT ALL ON TABLE public.user_profiles TO service_role;
GRANT SELECT ON TABLE public.user_profiles TO test_user;


--
-- Name: TABLE user_roles; Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON TABLE public.user_roles TO postgres;
GRANT ALL ON TABLE public.user_roles TO anon;
GRANT ALL ON TABLE public.user_roles TO authenticated;
GRANT ALL ON TABLE public.user_roles TO service_role;
GRANT SELECT ON TABLE public.user_roles TO test_user;


--
-- Name: SEQUENCE user_roles_id_seq; Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON SEQUENCE public.user_roles_id_seq TO postgres;
GRANT ALL ON SEQUENCE public.user_roles_id_seq TO anon;
GRANT ALL ON SEQUENCE public.user_roles_id_seq TO authenticated;
GRANT ALL ON SEQUENCE public.user_roles_id_seq TO service_role;


--
-- Name: TABLE v_is_subrole; Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON TABLE public.v_is_subrole TO postgres;
GRANT ALL ON TABLE public.v_is_subrole TO anon;
GRANT ALL ON TABLE public.v_is_subrole TO authenticated;
GRANT ALL ON TABLE public.v_is_subrole TO service_role;
GRANT SELECT ON TABLE public.v_is_subrole TO test_user;


--
-- Name: TABLE v_primary_email; Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON TABLE public.v_primary_email TO postgres;
GRANT ALL ON TABLE public.v_primary_email TO anon;
GRANT ALL ON TABLE public.v_primary_email TO authenticated;
GRANT ALL ON TABLE public.v_primary_email TO service_role;
GRANT SELECT ON TABLE public.v_primary_email TO test_user;


--
-- Name: TABLE vw_attendance_dashboard; Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON TABLE public.vw_attendance_dashboard TO postgres;
GRANT ALL ON TABLE public.vw_attendance_dashboard TO anon;
GRANT ALL ON TABLE public.vw_attendance_dashboard TO authenticated;
GRANT ALL ON TABLE public.vw_attendance_dashboard TO service_role;


--
-- Name: TABLE vw_class_checkins_today; Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON TABLE public.vw_class_checkins_today TO postgres;
GRANT ALL ON TABLE public.vw_class_checkins_today TO anon;
GRANT ALL ON TABLE public.vw_class_checkins_today TO authenticated;
GRANT ALL ON TABLE public.vw_class_checkins_today TO service_role;
GRANT SELECT ON TABLE public.vw_class_checkins_today TO test_user;


--
-- Name: TABLE vw_course_schedules_detailed; Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON TABLE public.vw_course_schedules_detailed TO postgres;
GRANT ALL ON TABLE public.vw_course_schedules_detailed TO anon;
GRANT ALL ON TABLE public.vw_course_schedules_detailed TO authenticated;
GRANT ALL ON TABLE public.vw_course_schedules_detailed TO service_role;


--
-- Name: TABLE vw_course_summary; Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON TABLE public.vw_course_summary TO postgres;
GRANT ALL ON TABLE public.vw_course_summary TO anon;
GRANT ALL ON TABLE public.vw_course_summary TO authenticated;
GRANT ALL ON TABLE public.vw_course_summary TO service_role;


--
-- Name: TABLE vw_daily_absences; Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON TABLE public.vw_daily_absences TO postgres;
GRANT ALL ON TABLE public.vw_daily_absences TO anon;
GRANT ALL ON TABLE public.vw_daily_absences TO authenticated;
GRANT ALL ON TABLE public.vw_daily_absences TO service_role;


--
-- Name: TABLE vw_daily_attendance_by_class; Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON TABLE public.vw_daily_attendance_by_class TO postgres;
GRANT ALL ON TABLE public.vw_daily_attendance_by_class TO anon;
GRANT ALL ON TABLE public.vw_daily_attendance_by_class TO authenticated;
GRANT ALL ON TABLE public.vw_daily_attendance_by_class TO service_role;


--
-- Name: TABLE vw_daily_attendance_overview; Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON TABLE public.vw_daily_attendance_overview TO postgres;
GRANT ALL ON TABLE public.vw_daily_attendance_overview TO anon;
GRANT ALL ON TABLE public.vw_daily_attendance_overview TO authenticated;
GRANT ALL ON TABLE public.vw_daily_attendance_overview TO service_role;


--
-- Name: TABLE vw_enrollments_with_students; Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON TABLE public.vw_enrollments_with_students TO postgres;
GRANT ALL ON TABLE public.vw_enrollments_with_students TO anon;
GRANT ALL ON TABLE public.vw_enrollments_with_students TO authenticated;
GRANT ALL ON TABLE public.vw_enrollments_with_students TO service_role;


--
-- Name: TABLE vw_erzieher; Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON TABLE public.vw_erzieher TO postgres;
GRANT ALL ON TABLE public.vw_erzieher TO anon;
GRANT ALL ON TABLE public.vw_erzieher TO authenticated;
GRANT ALL ON TABLE public.vw_erzieher TO service_role;


--
-- Name: TABLE vw_erzieher_with_email; Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON TABLE public.vw_erzieher_with_email TO postgres;
GRANT ALL ON TABLE public.vw_erzieher_with_email TO anon;
GRANT ALL ON TABLE public.vw_erzieher_with_email TO authenticated;
GRANT ALL ON TABLE public.vw_erzieher_with_email TO service_role;


--
-- Name: TABLE vw_externa; Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON TABLE public.vw_externa TO postgres;
GRANT ALL ON TABLE public.vw_externa TO anon;
GRANT ALL ON TABLE public.vw_externa TO authenticated;
GRANT ALL ON TABLE public.vw_externa TO service_role;


--
-- Name: TABLE vw_family_all_members; Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON TABLE public.vw_family_all_members TO postgres;
GRANT ALL ON TABLE public.vw_family_all_members TO anon;
GRANT ALL ON TABLE public.vw_family_all_members TO authenticated;
GRANT ALL ON TABLE public.vw_family_all_members TO service_role;


--
-- Name: TABLE vw_lesson_attendance_badges; Type: ACL; Schema: public; Owner: authenticated
--

GRANT ALL ON TABLE public.vw_lesson_attendance_badges TO postgres;
GRANT ALL ON TABLE public.vw_lesson_attendance_badges TO anon;
GRANT ALL ON TABLE public.vw_lesson_attendance_badges TO service_role;


--
-- Name: TABLE vw_lesson_view_enriched; Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON TABLE public.vw_lesson_view_enriched TO postgres;
GRANT ALL ON TABLE public.vw_lesson_view_enriched TO anon;
GRANT ALL ON TABLE public.vw_lesson_view_enriched TO authenticated;
GRANT ALL ON TABLE public.vw_lesson_view_enriched TO service_role;


--
-- Name: TABLE vw_lessons_needing_substitute; Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON TABLE public.vw_lessons_needing_substitute TO postgres;
GRANT ALL ON TABLE public.vw_lessons_needing_substitute TO anon;
GRANT ALL ON TABLE public.vw_lessons_needing_substitute TO authenticated;
GRANT ALL ON TABLE public.vw_lessons_needing_substitute TO service_role;


--
-- Name: TABLE vw_parent_course_windows; Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON TABLE public.vw_parent_course_windows TO postgres;
GRANT ALL ON TABLE public.vw_parent_course_windows TO anon;
GRANT ALL ON TABLE public.vw_parent_course_windows TO authenticated;
GRANT ALL ON TABLE public.vw_parent_course_windows TO service_role;


--
-- Name: TABLE vw_parent_open_registration_cta; Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON TABLE public.vw_parent_open_registration_cta TO postgres;
GRANT ALL ON TABLE public.vw_parent_open_registration_cta TO anon;
GRANT ALL ON TABLE public.vw_parent_open_registration_cta TO authenticated;
GRANT ALL ON TABLE public.vw_parent_open_registration_cta TO service_role;


--
-- Name: TABLE vw_react_lesson_details; Type: ACL; Schema: public; Owner: authenticated
--

GRANT ALL ON TABLE public.vw_react_lesson_details TO postgres;
GRANT ALL ON TABLE public.vw_react_lesson_details TO anon;
GRANT ALL ON TABLE public.vw_react_lesson_details TO service_role;


--
-- Name: TABLE vw_registration_period_courses_by_day; Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON TABLE public.vw_registration_period_courses_by_day TO postgres;
GRANT ALL ON TABLE public.vw_registration_period_courses_by_day TO anon;
GRANT ALL ON TABLE public.vw_registration_period_courses_by_day TO authenticated;
GRANT ALL ON TABLE public.vw_registration_period_courses_by_day TO service_role;


--
-- Name: TABLE vw_registration_period_students_by_day; Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON TABLE public.vw_registration_period_students_by_day TO postgres;
GRANT ALL ON TABLE public.vw_registration_period_students_by_day TO anon;
GRANT ALL ON TABLE public.vw_registration_period_students_by_day TO authenticated;
GRANT ALL ON TABLE public.vw_registration_period_students_by_day TO service_role;


--
-- Name: TABLE vw_school_days; Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON TABLE public.vw_school_days TO postgres;
GRANT ALL ON TABLE public.vw_school_days TO anon;
GRANT ALL ON TABLE public.vw_school_days TO authenticated;
GRANT ALL ON TABLE public.vw_school_days TO service_role;


--
-- Name: TABLE vw_staff; Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON TABLE public.vw_staff TO postgres;
GRANT ALL ON TABLE public.vw_staff TO anon;
GRANT ALL ON TABLE public.vw_staff TO authenticated;
GRANT ALL ON TABLE public.vw_staff TO service_role;


--
-- Name: TABLE vw_staff_availability_next_7_days; Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON TABLE public.vw_staff_availability_next_7_days TO postgres;
GRANT ALL ON TABLE public.vw_staff_availability_next_7_days TO anon;
GRANT ALL ON TABLE public.vw_staff_availability_next_7_days TO authenticated;
GRANT ALL ON TABLE public.vw_staff_availability_next_7_days TO service_role;


--
-- Name: TABLE vw_staff_period_availability; Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON TABLE public.vw_staff_period_availability TO postgres;
GRANT ALL ON TABLE public.vw_staff_period_availability TO anon;
GRANT ALL ON TABLE public.vw_staff_period_availability TO authenticated;
GRANT ALL ON TABLE public.vw_staff_period_availability TO service_role;


--
-- Name: TABLE vw_staff_with_preferences; Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON TABLE public.vw_staff_with_preferences TO postgres;
GRANT ALL ON TABLE public.vw_staff_with_preferences TO anon;
GRANT ALL ON TABLE public.vw_staff_with_preferences TO authenticated;
GRANT ALL ON TABLE public.vw_staff_with_preferences TO service_role;


--
-- Name: TABLE vw_structure_school_years_with_periods; Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON TABLE public.vw_structure_school_years_with_periods TO postgres;
GRANT ALL ON TABLE public.vw_structure_school_years_with_periods TO anon;
GRANT ALL ON TABLE public.vw_structure_school_years_with_periods TO authenticated;
GRANT ALL ON TABLE public.vw_structure_school_years_with_periods TO service_role;
GRANT SELECT ON TABLE public.vw_structure_school_years_with_periods TO test_user;


--
-- Name: TABLE vw_student_attendance_today; Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON TABLE public.vw_student_attendance_today TO postgres;
GRANT ALL ON TABLE public.vw_student_attendance_today TO anon;
GRANT ALL ON TABLE public.vw_student_attendance_today TO authenticated;
GRANT ALL ON TABLE public.vw_student_attendance_today TO service_role;
GRANT SELECT ON TABLE public.vw_student_attendance_today TO test_user;


--
-- Name: TABLE vw_student_profiles; Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON TABLE public.vw_student_profiles TO postgres;
GRANT ALL ON TABLE public.vw_student_profiles TO anon;
GRANT ALL ON TABLE public.vw_student_profiles TO authenticated;
GRANT ALL ON TABLE public.vw_student_profiles TO service_role;


--
-- Name: TABLE vw_subject_grade_hours; Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON TABLE public.vw_subject_grade_hours TO postgres;
GRANT ALL ON TABLE public.vw_subject_grade_hours TO anon;
GRANT ALL ON TABLE public.vw_subject_grade_hours TO authenticated;
GRANT ALL ON TABLE public.vw_subject_grade_hours TO service_role;
GRANT SELECT ON TABLE public.vw_subject_grade_hours TO test_user;


--
-- Name: TABLE vw_subjects_with_grade_and_class_hours; Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON TABLE public.vw_subjects_with_grade_and_class_hours TO postgres;
GRANT ALL ON TABLE public.vw_subjects_with_grade_and_class_hours TO anon;
GRANT ALL ON TABLE public.vw_subjects_with_grade_and_class_hours TO authenticated;
GRANT ALL ON TABLE public.vw_subjects_with_grade_and_class_hours TO service_role;
GRANT SELECT ON TABLE public.vw_subjects_with_grade_and_class_hours TO test_user;


--
-- Name: TABLE vw_user_roles; Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON TABLE public.vw_user_roles TO postgres;
GRANT ALL ON TABLE public.vw_user_roles TO anon;
GRANT ALL ON TABLE public.vw_user_roles TO authenticated;
GRANT ALL ON TABLE public.vw_user_roles TO service_role;
GRANT SELECT ON TABLE public.vw_user_roles TO test_user;


--
-- Name: TABLE vwm_class_user_creation_stats; Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON TABLE public.vwm_class_user_creation_stats TO postgres;
GRANT ALL ON TABLE public.vwm_class_user_creation_stats TO anon;
GRANT ALL ON TABLE public.vwm_class_user_creation_stats TO authenticated;
GRANT ALL ON TABLE public.vwm_class_user_creation_stats TO service_role;
GRANT SELECT ON TABLE public.vwm_class_user_creation_stats TO test_user;


--
-- Name: TABLE vwm_school_semesters_with_year_label; Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON TABLE public.vwm_school_semesters_with_year_label TO postgres;
GRANT ALL ON TABLE public.vwm_school_semesters_with_year_label TO anon;
GRANT ALL ON TABLE public.vwm_school_semesters_with_year_label TO authenticated;
GRANT ALL ON TABLE public.vwm_school_semesters_with_year_label TO service_role;
GRANT SELECT ON TABLE public.vwm_school_semesters_with_year_label TO test_user;


--
-- Name: TABLE messages; Type: ACL; Schema: realtime; Owner: supabase_realtime_admin
--

GRANT ALL ON TABLE realtime.messages TO postgres;
GRANT ALL ON TABLE realtime.messages TO dashboard_user;
GRANT SELECT,INSERT,UPDATE ON TABLE realtime.messages TO anon;
GRANT SELECT,INSERT,UPDATE ON TABLE realtime.messages TO authenticated;
GRANT SELECT,INSERT,UPDATE ON TABLE realtime.messages TO service_role;


--
-- Name: TABLE messages_2025_08_25; Type: ACL; Schema: realtime; Owner: supabase_admin
--

GRANT ALL ON TABLE realtime.messages_2025_08_25 TO postgres;
GRANT ALL ON TABLE realtime.messages_2025_08_25 TO dashboard_user;


--
-- Name: TABLE messages_2025_08_26; Type: ACL; Schema: realtime; Owner: supabase_admin
--

GRANT ALL ON TABLE realtime.messages_2025_08_26 TO postgres;
GRANT ALL ON TABLE realtime.messages_2025_08_26 TO dashboard_user;


--
-- Name: TABLE messages_2025_08_27; Type: ACL; Schema: realtime; Owner: supabase_admin
--

GRANT ALL ON TABLE realtime.messages_2025_08_27 TO postgres;
GRANT ALL ON TABLE realtime.messages_2025_08_27 TO dashboard_user;


--
-- Name: TABLE messages_2025_08_28; Type: ACL; Schema: realtime; Owner: supabase_admin
--

GRANT ALL ON TABLE realtime.messages_2025_08_28 TO postgres;
GRANT ALL ON TABLE realtime.messages_2025_08_28 TO dashboard_user;


--
-- Name: TABLE messages_2025_08_29; Type: ACL; Schema: realtime; Owner: supabase_admin
--

GRANT ALL ON TABLE realtime.messages_2025_08_29 TO postgres;
GRANT ALL ON TABLE realtime.messages_2025_08_29 TO dashboard_user;


--
-- Name: TABLE messages_2025_08_30; Type: ACL; Schema: realtime; Owner: supabase_admin
--

GRANT ALL ON TABLE realtime.messages_2025_08_30 TO postgres;
GRANT ALL ON TABLE realtime.messages_2025_08_30 TO dashboard_user;


--
-- Name: TABLE messages_2025_08_31; Type: ACL; Schema: realtime; Owner: supabase_admin
--

GRANT ALL ON TABLE realtime.messages_2025_08_31 TO postgres;
GRANT ALL ON TABLE realtime.messages_2025_08_31 TO dashboard_user;


--
-- Name: TABLE schema_migrations; Type: ACL; Schema: realtime; Owner: supabase_admin
--

GRANT ALL ON TABLE realtime.schema_migrations TO postgres;
GRANT ALL ON TABLE realtime.schema_migrations TO dashboard_user;
GRANT SELECT ON TABLE realtime.schema_migrations TO anon;
GRANT SELECT ON TABLE realtime.schema_migrations TO authenticated;
GRANT SELECT ON TABLE realtime.schema_migrations TO service_role;
GRANT ALL ON TABLE realtime.schema_migrations TO supabase_realtime_admin;


--
-- Name: TABLE subscription; Type: ACL; Schema: realtime; Owner: supabase_admin
--

GRANT ALL ON TABLE realtime.subscription TO postgres;
GRANT ALL ON TABLE realtime.subscription TO dashboard_user;
GRANT SELECT ON TABLE realtime.subscription TO anon;
GRANT SELECT ON TABLE realtime.subscription TO authenticated;
GRANT SELECT ON TABLE realtime.subscription TO service_role;
GRANT ALL ON TABLE realtime.subscription TO supabase_realtime_admin;


--
-- Name: SEQUENCE subscription_id_seq; Type: ACL; Schema: realtime; Owner: supabase_admin
--

GRANT ALL ON SEQUENCE realtime.subscription_id_seq TO postgres;
GRANT ALL ON SEQUENCE realtime.subscription_id_seq TO dashboard_user;
GRANT USAGE ON SEQUENCE realtime.subscription_id_seq TO anon;
GRANT USAGE ON SEQUENCE realtime.subscription_id_seq TO authenticated;
GRANT USAGE ON SEQUENCE realtime.subscription_id_seq TO service_role;
GRANT ALL ON SEQUENCE realtime.subscription_id_seq TO supabase_realtime_admin;


--
-- Name: TABLE buckets; Type: ACL; Schema: storage; Owner: supabase_storage_admin
--

GRANT ALL ON TABLE storage.buckets TO anon;
GRANT ALL ON TABLE storage.buckets TO authenticated;
GRANT ALL ON TABLE storage.buckets TO service_role;
GRANT ALL ON TABLE storage.buckets TO postgres;


--
-- Name: TABLE migrations; Type: ACL; Schema: storage; Owner: supabase_storage_admin
--

GRANT ALL ON TABLE storage.migrations TO anon;
GRANT ALL ON TABLE storage.migrations TO authenticated;
GRANT ALL ON TABLE storage.migrations TO service_role;
GRANT ALL ON TABLE storage.migrations TO postgres;


--
-- Name: TABLE objects; Type: ACL; Schema: storage; Owner: supabase_storage_admin
--

GRANT ALL ON TABLE storage.objects TO anon;
GRANT ALL ON TABLE storage.objects TO authenticated;
GRANT ALL ON TABLE storage.objects TO service_role;
GRANT ALL ON TABLE storage.objects TO postgres;


--
-- Name: TABLE prefixes; Type: ACL; Schema: storage; Owner: supabase_storage_admin
--

GRANT ALL ON TABLE storage.prefixes TO service_role;
GRANT ALL ON TABLE storage.prefixes TO authenticated;
GRANT ALL ON TABLE storage.prefixes TO anon;


--
-- Name: TABLE s3_multipart_uploads; Type: ACL; Schema: storage; Owner: supabase_storage_admin
--

GRANT ALL ON TABLE storage.s3_multipart_uploads TO service_role;
GRANT SELECT ON TABLE storage.s3_multipart_uploads TO authenticated;
GRANT SELECT ON TABLE storage.s3_multipart_uploads TO anon;


--
-- Name: TABLE s3_multipart_uploads_parts; Type: ACL; Schema: storage; Owner: supabase_storage_admin
--

GRANT ALL ON TABLE storage.s3_multipart_uploads_parts TO service_role;
GRANT SELECT ON TABLE storage.s3_multipart_uploads_parts TO authenticated;
GRANT SELECT ON TABLE storage.s3_multipart_uploads_parts TO anon;


--
-- Name: TABLE tenants; Type: ACL; Schema: storage; Owner: postgres
--

GRANT ALL ON TABLE storage.tenants TO anon;
GRANT ALL ON TABLE storage.tenants TO authenticated;
GRANT ALL ON TABLE storage.tenants TO service_role;


--
-- Name: TABLE hooks; Type: ACL; Schema: supabase_functions; Owner: supabase_functions_admin
--

GRANT ALL ON TABLE supabase_functions.hooks TO anon;
GRANT ALL ON TABLE supabase_functions.hooks TO authenticated;
GRANT ALL ON TABLE supabase_functions.hooks TO service_role;


--
-- Name: SEQUENCE hooks_id_seq; Type: ACL; Schema: supabase_functions; Owner: supabase_functions_admin
--

GRANT ALL ON SEQUENCE supabase_functions.hooks_id_seq TO anon;
GRANT ALL ON SEQUENCE supabase_functions.hooks_id_seq TO authenticated;
GRANT ALL ON SEQUENCE supabase_functions.hooks_id_seq TO service_role;


--
-- Name: TABLE migrations; Type: ACL; Schema: supabase_functions; Owner: supabase_functions_admin
--

GRANT ALL ON TABLE supabase_functions.migrations TO anon;
GRANT ALL ON TABLE supabase_functions.migrations TO authenticated;
GRANT ALL ON TABLE supabase_functions.migrations TO service_role;


--
-- Name: TABLE secrets; Type: ACL; Schema: vault; Owner: supabase_admin
--

GRANT SELECT,DELETE ON TABLE vault.secrets TO postgres WITH GRANT OPTION;


--
-- Name: TABLE decrypted_secrets; Type: ACL; Schema: vault; Owner: supabase_admin
--

GRANT SELECT,DELETE ON TABLE vault.decrypted_secrets TO postgres WITH GRANT OPTION;


--
-- Name: TABLE vwm_user_login_profiles; Type: ACL; Schema: public; Owner: supabase_admin
--

GRANT ALL ON TABLE public.vwm_user_login_profiles TO postgres;
GRANT ALL ON TABLE public.vwm_user_login_profiles TO anon;
GRANT ALL ON TABLE public.vwm_user_login_profiles TO authenticated;
GRANT ALL ON TABLE public.vwm_user_login_profiles TO service_role;
GRANT SELECT ON TABLE public.vwm_user_login_profiles TO test_user;


--
-- Name: DEFAULT PRIVILEGES FOR SEQUENCES; Type: DEFAULT ACL; Schema: auth; Owner: supabase_auth_admin
--

ALTER DEFAULT PRIVILEGES FOR ROLE supabase_auth_admin IN SCHEMA auth GRANT ALL ON SEQUENCES TO postgres;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_auth_admin IN SCHEMA auth GRANT ALL ON SEQUENCES TO dashboard_user;


--
-- Name: DEFAULT PRIVILEGES FOR FUNCTIONS; Type: DEFAULT ACL; Schema: auth; Owner: supabase_auth_admin
--

ALTER DEFAULT PRIVILEGES FOR ROLE supabase_auth_admin IN SCHEMA auth GRANT ALL ON FUNCTIONS TO postgres;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_auth_admin IN SCHEMA auth GRANT ALL ON FUNCTIONS TO dashboard_user;


--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: auth; Owner: supabase_auth_admin
--

ALTER DEFAULT PRIVILEGES FOR ROLE supabase_auth_admin IN SCHEMA auth GRANT ALL ON TABLES TO postgres;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_auth_admin IN SCHEMA auth GRANT ALL ON TABLES TO dashboard_user;


--
-- Name: DEFAULT PRIVILEGES FOR SEQUENCES; Type: DEFAULT ACL; Schema: extensions; Owner: supabase_admin
--

ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA extensions GRANT ALL ON SEQUENCES TO postgres WITH GRANT OPTION;


--
-- Name: DEFAULT PRIVILEGES FOR FUNCTIONS; Type: DEFAULT ACL; Schema: extensions; Owner: supabase_admin
--

ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA extensions GRANT ALL ON FUNCTIONS TO postgres WITH GRANT OPTION;


--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: extensions; Owner: supabase_admin
--

ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA extensions GRANT ALL ON TABLES TO postgres WITH GRANT OPTION;


--
-- Name: DEFAULT PRIVILEGES FOR SEQUENCES; Type: DEFAULT ACL; Schema: graphql; Owner: supabase_admin
--

ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA graphql GRANT ALL ON SEQUENCES TO postgres;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA graphql GRANT ALL ON SEQUENCES TO anon;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA graphql GRANT ALL ON SEQUENCES TO authenticated;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA graphql GRANT ALL ON SEQUENCES TO service_role;


--
-- Name: DEFAULT PRIVILEGES FOR FUNCTIONS; Type: DEFAULT ACL; Schema: graphql; Owner: supabase_admin
--

ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA graphql GRANT ALL ON FUNCTIONS TO postgres;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA graphql GRANT ALL ON FUNCTIONS TO anon;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA graphql GRANT ALL ON FUNCTIONS TO authenticated;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA graphql GRANT ALL ON FUNCTIONS TO service_role;


--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: graphql; Owner: supabase_admin
--

ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA graphql GRANT ALL ON TABLES TO postgres;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA graphql GRANT ALL ON TABLES TO anon;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA graphql GRANT ALL ON TABLES TO authenticated;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA graphql GRANT ALL ON TABLES TO service_role;


--
-- Name: DEFAULT PRIVILEGES FOR SEQUENCES; Type: DEFAULT ACL; Schema: graphql_public; Owner: supabase_admin
--

ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA graphql_public GRANT ALL ON SEQUENCES TO postgres;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA graphql_public GRANT ALL ON SEQUENCES TO anon;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA graphql_public GRANT ALL ON SEQUENCES TO authenticated;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA graphql_public GRANT ALL ON SEQUENCES TO service_role;


--
-- Name: DEFAULT PRIVILEGES FOR FUNCTIONS; Type: DEFAULT ACL; Schema: graphql_public; Owner: supabase_admin
--

ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA graphql_public GRANT ALL ON FUNCTIONS TO postgres;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA graphql_public GRANT ALL ON FUNCTIONS TO anon;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA graphql_public GRANT ALL ON FUNCTIONS TO authenticated;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA graphql_public GRANT ALL ON FUNCTIONS TO service_role;


--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: graphql_public; Owner: supabase_admin
--

ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA graphql_public GRANT ALL ON TABLES TO postgres;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA graphql_public GRANT ALL ON TABLES TO anon;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA graphql_public GRANT ALL ON TABLES TO authenticated;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA graphql_public GRANT ALL ON TABLES TO service_role;


--
-- Name: DEFAULT PRIVILEGES FOR SEQUENCES; Type: DEFAULT ACL; Schema: public; Owner: postgres
--

ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA public GRANT ALL ON SEQUENCES TO postgres;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA public GRANT ALL ON SEQUENCES TO anon;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA public GRANT ALL ON SEQUENCES TO authenticated;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA public GRANT ALL ON SEQUENCES TO service_role;


--
-- Name: DEFAULT PRIVILEGES FOR SEQUENCES; Type: DEFAULT ACL; Schema: public; Owner: supabase_admin
--

ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA public GRANT ALL ON SEQUENCES TO postgres;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA public GRANT ALL ON SEQUENCES TO anon;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA public GRANT ALL ON SEQUENCES TO authenticated;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA public GRANT ALL ON SEQUENCES TO service_role;


--
-- Name: DEFAULT PRIVILEGES FOR FUNCTIONS; Type: DEFAULT ACL; Schema: public; Owner: postgres
--

ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA public GRANT ALL ON FUNCTIONS TO postgres;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA public GRANT ALL ON FUNCTIONS TO anon;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA public GRANT ALL ON FUNCTIONS TO authenticated;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA public GRANT ALL ON FUNCTIONS TO service_role;


--
-- Name: DEFAULT PRIVILEGES FOR FUNCTIONS; Type: DEFAULT ACL; Schema: public; Owner: supabase_admin
--

ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA public GRANT ALL ON FUNCTIONS TO postgres;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA public GRANT ALL ON FUNCTIONS TO anon;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA public GRANT ALL ON FUNCTIONS TO authenticated;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA public GRANT ALL ON FUNCTIONS TO service_role;


--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: public; Owner: postgres
--

ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA public GRANT ALL ON TABLES TO postgres;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA public GRANT ALL ON TABLES TO anon;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA public GRANT ALL ON TABLES TO authenticated;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA public GRANT ALL ON TABLES TO service_role;


--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: public; Owner: supabase_admin
--

ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA public GRANT ALL ON TABLES TO postgres;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA public GRANT ALL ON TABLES TO anon;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA public GRANT ALL ON TABLES TO authenticated;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA public GRANT ALL ON TABLES TO service_role;


--
-- Name: DEFAULT PRIVILEGES FOR SEQUENCES; Type: DEFAULT ACL; Schema: realtime; Owner: supabase_admin
--

ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA realtime GRANT ALL ON SEQUENCES TO postgres;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA realtime GRANT ALL ON SEQUENCES TO dashboard_user;


--
-- Name: DEFAULT PRIVILEGES FOR FUNCTIONS; Type: DEFAULT ACL; Schema: realtime; Owner: supabase_admin
--

ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA realtime GRANT ALL ON FUNCTIONS TO postgres;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA realtime GRANT ALL ON FUNCTIONS TO dashboard_user;


--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: realtime; Owner: supabase_admin
--

ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA realtime GRANT ALL ON TABLES TO postgres;
ALTER DEFAULT PRIVILEGES FOR ROLE supabase_admin IN SCHEMA realtime GRANT ALL ON TABLES TO dashboard_user;


--
-- Name: DEFAULT PRIVILEGES FOR SEQUENCES; Type: DEFAULT ACL; Schema: storage; Owner: postgres
--

ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA storage GRANT ALL ON SEQUENCES TO postgres;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA storage GRANT ALL ON SEQUENCES TO anon;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA storage GRANT ALL ON SEQUENCES TO authenticated;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA storage GRANT ALL ON SEQUENCES TO service_role;


--
-- Name: DEFAULT PRIVILEGES FOR FUNCTIONS; Type: DEFAULT ACL; Schema: storage; Owner: postgres
--

ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA storage GRANT ALL ON FUNCTIONS TO postgres;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA storage GRANT ALL ON FUNCTIONS TO anon;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA storage GRANT ALL ON FUNCTIONS TO authenticated;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA storage GRANT ALL ON FUNCTIONS TO service_role;


--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: storage; Owner: postgres
--

ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA storage GRANT ALL ON TABLES TO postgres;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA storage GRANT ALL ON TABLES TO anon;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA storage GRANT ALL ON TABLES TO authenticated;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA storage GRANT ALL ON TABLES TO service_role;


--
-- Name: DEFAULT PRIVILEGES FOR SEQUENCES; Type: DEFAULT ACL; Schema: supabase_functions; Owner: postgres
--

ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA supabase_functions GRANT ALL ON SEQUENCES TO postgres;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA supabase_functions GRANT ALL ON SEQUENCES TO anon;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA supabase_functions GRANT ALL ON SEQUENCES TO authenticated;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA supabase_functions GRANT ALL ON SEQUENCES TO service_role;


--
-- Name: DEFAULT PRIVILEGES FOR FUNCTIONS; Type: DEFAULT ACL; Schema: supabase_functions; Owner: postgres
--

ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA supabase_functions GRANT ALL ON FUNCTIONS TO postgres;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA supabase_functions GRANT ALL ON FUNCTIONS TO anon;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA supabase_functions GRANT ALL ON FUNCTIONS TO authenticated;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA supabase_functions GRANT ALL ON FUNCTIONS TO service_role;


--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: supabase_functions; Owner: postgres
--

ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA supabase_functions GRANT ALL ON TABLES TO postgres;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA supabase_functions GRANT ALL ON TABLES TO anon;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA supabase_functions GRANT ALL ON TABLES TO authenticated;
ALTER DEFAULT PRIVILEGES FOR ROLE postgres IN SCHEMA supabase_functions GRANT ALL ON TABLES TO service_role;


--
-- Name: issue_graphql_placeholder; Type: EVENT TRIGGER; Schema: -; Owner: supabase_admin
--

CREATE EVENT TRIGGER issue_graphql_placeholder ON sql_drop
         WHEN TAG IN ('DROP EXTENSION')
   EXECUTE FUNCTION extensions.set_graphql_placeholder();


ALTER EVENT TRIGGER issue_graphql_placeholder OWNER TO supabase_admin;

--
-- Name: issue_pg_cron_access; Type: EVENT TRIGGER; Schema: -; Owner: supabase_admin
--

CREATE EVENT TRIGGER issue_pg_cron_access ON ddl_command_end
         WHEN TAG IN ('CREATE EXTENSION')
   EXECUTE FUNCTION extensions.grant_pg_cron_access();


ALTER EVENT TRIGGER issue_pg_cron_access OWNER TO supabase_admin;

--
-- Name: issue_pg_graphql_access; Type: EVENT TRIGGER; Schema: -; Owner: supabase_admin
--

CREATE EVENT TRIGGER issue_pg_graphql_access ON ddl_command_end
         WHEN TAG IN ('CREATE FUNCTION')
   EXECUTE FUNCTION extensions.grant_pg_graphql_access();


ALTER EVENT TRIGGER issue_pg_graphql_access OWNER TO supabase_admin;

--
-- Name: issue_pg_net_access; Type: EVENT TRIGGER; Schema: -; Owner: postgres
--

CREATE EVENT TRIGGER issue_pg_net_access ON ddl_command_end
         WHEN TAG IN ('CREATE EXTENSION')
   EXECUTE FUNCTION extensions.grant_pg_net_access();


ALTER EVENT TRIGGER issue_pg_net_access OWNER TO postgres;

--
-- Name: log_schema_change_trigger; Type: EVENT TRIGGER; Schema: -; Owner: supabase_admin
--

CREATE EVENT TRIGGER log_schema_change_trigger ON ddl_command_end
   EXECUTE FUNCTION public.log_schema_change();


ALTER EVENT TRIGGER log_schema_change_trigger OWNER TO supabase_admin;

--
-- Name: pgrst_ddl_watch; Type: EVENT TRIGGER; Schema: -; Owner: supabase_admin
--

CREATE EVENT TRIGGER pgrst_ddl_watch ON ddl_command_end
   EXECUTE FUNCTION extensions.pgrst_ddl_watch();


ALTER EVENT TRIGGER pgrst_ddl_watch OWNER TO supabase_admin;

--
-- Name: pgrst_drop_watch; Type: EVENT TRIGGER; Schema: -; Owner: supabase_admin
--

CREATE EVENT TRIGGER pgrst_drop_watch ON sql_drop
   EXECUTE FUNCTION extensions.pgrst_drop_watch();


ALTER EVENT TRIGGER pgrst_drop_watch OWNER TO supabase_admin;

--
-- Name: trg_log_ddl; Type: EVENT TRIGGER; Schema: -; Owner: supabase_admin
--

CREATE EVENT TRIGGER trg_log_ddl ON ddl_command_end
   EXECUTE FUNCTION public.log_ddl_command();


ALTER EVENT TRIGGER trg_log_ddl OWNER TO supabase_admin;

--
-- PostgreSQL database dump complete
--

