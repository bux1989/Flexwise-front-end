# Database Schema Reference

## Overview
This document provides a comprehensive reference for the Flexwise database schema, including tables, relationships, and key patterns for Supabase integration.

## Authentication Pattern
- **Supabase Auth** → `auth.users.user_metadata.profile_id` → `user_profiles.id`
- Use `auth.get_profile_id()` to get current user's profile ID
- Use `auth.get_user_school_id()` to get current user's school

## Key Enums

### Account Status
```sql
account_status_enum: 'none' | 'created' | 'invited' | 'active' | 'inactive' | 'expired' | 'suspended' | 'deleted'
```

### Attendance Status
```sql
attendance_status: 'present' | 'late' | 'absent_unexcused' | 'absent_excused' | 'left_early'
```

### Presence Status
```sql
presence_status: 'present' | 'absent_unexcused' | 'absent_excused' | 'unmarked' | 'left_early' | 'left_without_notice' | 'temporarily_offsite' | 'late' | 'partial'
```

## Core Tables

### user_profiles
**Purpose**: Central profile for all users (students, staff, parents, contacts)

```sql
CREATE TABLE user_profiles (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    school_id uuid NOT NULL,
    first_name text,
    last_name text,
    date_of_birth date,
    gender text,
    profile_picture_url text,
    role_id uuid,
    account_status account_status_enum DEFAULT 'none',
    created_at timestamp DEFAULT now()
);
```

**Key Relationships:**
- `school_id` → `structure_schools(id)` ON DELETE CASCADE
- `role_id` → `roles(id)` ON DELETE SET NULL

**Auth Connection:** `auth.users.user_metadata.profile_id` → `user_profiles.id`

### roles
**Purpose**: Role definitions (Teacher, Parent, Admin, Student, etc.)

```sql
CREATE TABLE roles (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    name text NOT NULL,
    is_subrole boolean DEFAULT false
);
```

**Common Values:** 'Teacher', 'Parent', 'Admin', 'Student', 'Super Admin', 'Externe'

### user_roles
**Purpose**: Multi-role assignment (users can have multiple roles)

```sql
CREATE TABLE user_roles (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_profile_id uuid NOT NULL,
    role_id uuid NOT NULL,
    school_id uuid NOT NULL,
    created_at timestamp with time zone DEFAULT now()
);
```

**Relationships:**
- `user_profile_id` → `user_profiles(id)`
- `role_id` → `roles(id)`
- `school_id` → `structure_schools(id)`

### structure_schools
**Purpose**: School entities for multi-tenancy

```sql
CREATE TABLE structure_schools (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    name text NOT NULL,
    timezone text,
    language text,
    principal_id uuid,
    email text,
    phone text,
    address_street text,
    address_city text,
    address_postal_code text
);
```

### structure_classes
**Purpose**: Class/classroom definitions

```sql
CREATE TABLE structure_classes (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    school_id uuid NOT NULL,
    name text NOT NULL,
    year integer NOT NULL,
    teacher_id uuid,
    grade_level integer,
    room_id uuid,
    color text
);
```

**Relationships:**
- `school_id` → `structure_schools(id)` ON DELETE CASCADE
- `teacher_id` → `user_profiles(id)`
- `room_id` → `structure_rooms(id)` ON DELETE SET NULL

## Student & Family Management

### profile_info_student
**Purpose**: Student-specific profile information

```sql
CREATE TABLE profile_info_student (
    profile_id uuid NOT NULL,
    class_id uuid,
    school_id uuid NOT NULL,
    date_of_birth date,
    middle_name text,
    nickname text,
    allergies text,
    authorized_pickup_ids uuid[] DEFAULT '{}',
    notes text
);
```

### families
**Purpose**: Family groupings for managing parent-child relationships

```sql
CREATE TABLE families (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    school_id uuid NOT NULL,
    created_by uuid,
    updated_by uuid,
    created_at timestamp DEFAULT now()
);
```

### family_members
**Purpose**: Links profiles to families with roles

```sql
CREATE TABLE family_members (
    family_id uuid NOT NULL,
    profile_id uuid NOT NULL,
    role text NOT NULL, -- 'student', 'parent', 'guardian', 'staff', 'other'
    relation_description text,
    is_primary_guardian boolean,
    is_primary_contact boolean,
    added_at timestamp DEFAULT now(),
    school_id uuid NOT NULL
);
```

### family_member_child_links
**Purpose**: Adult-child relationships with permissions

```sql
CREATE TABLE family_member_child_links (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    family_id uuid NOT NULL,
    adult_profile_id uuid NOT NULL,
    child_profile_id uuid NOT NULL,
    relationship text,
    access_restricted boolean DEFAULT false,
    authorized_for_pickup boolean DEFAULT false,
    pickup_priority smallint,
    school_id uuid NOT NULL
);
```

## Attendance System

### student_daily_log
**Purpose**: Daily attendance tracking per student

```sql
CREATE TABLE student_daily_log (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    student_id uuid NOT NULL,
    school_id uuid NOT NULL,
    date date NOT NULL,
    check_in_time time,
    check_out_time time,
    check_in_by uuid,
    check_out_by uuid,
    presence_status presence_status DEFAULT 'unmarked',
    expected_arrival_time time,
    expected_checkout_time time,
    absence_note_id uuid,
    notes text,
    created_at timestamp DEFAULT now(),
    updated_at timestamp DEFAULT now()
);
```

### student_attendance_logs
**Purpose**: Lesson-level attendance tracking

```sql
CREATE TABLE student_attendance_logs (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    lesson_id uuid NOT NULL,
    student_id uuid NOT NULL,
    daily_log_id uuid,
    status attendance_status,
    lateness_duration_minutes integer,
    recorded_by uuid,
    timestamp timestamp DEFAULT now(),
    notes text,
    absence_note_id uuid,
    school_id uuid NOT NULL
);
```

**Relationships:**
- `lesson_id` → `course_lessons(id)` ON DELETE RESTRICT
- `student_id` → `user_profiles(id)`
- `recorded_by` → `user_profiles(id)`

### student_absence_notes
**Purpose**: Absence requests and approvals

```sql
CREATE TABLE student_absence_notes (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    student_id uuid NOT NULL,
    school_id uuid NOT NULL,
    created_by uuid NOT NULL,
    start_date date NOT NULL,
    end_date date NOT NULL,
    absence_type text NOT NULL,
    reason text,
    is_excused boolean DEFAULT false,
    status text DEFAULT 'pending',
    approved_by uuid,
    approved_at timestamp,
    attachment_url text,
    created_at timestamp DEFAULT now()
);
```

### lesson_diary_entries
**Purpose**: Klassenbuch entries (lesson diary/notes)

```sql
CREATE TABLE public.lesson_diary_entries (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  lesson_id uuid NOT NULL,
  school_id uuid NOT NULL,
  entry_text text NOT NULL,
  entry_type text NOT NULL DEFAULT 'general'::text,
  is_private boolean NOT NULL DEFAULT false,
  created_by uuid NOT NULL,
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  updated_at timestamp with time zone NOT NULL DEFAULT now(),
  updated_by uuid,
  CONSTRAINT lesson_diary_entries_pkey PRIMARY KEY (id),
  CONSTRAINT fk_lesson_diary_entries_lesson FOREIGN KEY (lesson_id) REFERENCES course_lessons (id) ON DELETE CASCADE,
  CONSTRAINT fk_lesson_diary_entries_school FOREIGN KEY (school_id) REFERENCES structure_schools (id) ON DELETE CASCADE,
  CONSTRAINT fk_lesson_diary_entries_created_by FOREIGN KEY (created_by) REFERENCES user_profiles (id) ON DELETE CASCADE,
  CONSTRAINT fk_lesson_diary_entries_updated_by FOREIGN KEY (updated_by) REFERENCES user_profiles (id) ON DELETE SET NULL,
  CONSTRAINT lesson_diary_entries_entry_type_check CHECK (
    entry_type = ANY (ARRAY['general','attendance','behavior','curriculum','special_event','substitute'])
  )
);

CREATE INDEX IF NOT EXISTS idx_lesson_diary_entries_lesson_id ON public.lesson_diary_entries (lesson_id);
CREATE INDEX IF NOT EXISTS idx_lesson_diary_entries_school_id ON public.lesson_diary_entries (school_id);
CREATE INDEX IF NOT EXISTS idx_lesson_diary_entries_created_by ON public.lesson_diary_entries (created_by);
CREATE INDEX IF NOT EXISTS idx_lesson_diary_entries_lesson_created ON public.lesson_diary_entries (lesson_id, created_at);
CREATE INDEX IF NOT EXISTS idx_lesson_diary_entries_type ON public.lesson_diary_entries (entry_type);
CREATE INDEX IF NOT EXISTS idx_lesson_diary_entries_school_created ON public.lesson_diary_entries (school_id, created_at);
CREATE INDEX IF NOT EXISTS idx_lesson_diary_entries_teacher_created ON public.lesson_diary_entries (created_by, created_at);
CREATE INDEX IF NOT EXISTS idx_lesson_diary_entries_privacy ON public.lesson_diary_entries (is_private);
```

## Course & Lesson Management

### course_list
**Purpose**: Course definitions

```sql
CREATE TABLE course_list (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    school_id uuid NOT NULL,
    name text NOT NULL,
    course_code text,
    subject_id uuid,
    max_students integer,
    start_date date,
    end_date date,
    is_active boolean DEFAULT true,
    created_at timestamp DEFAULT now()
);
```

### course_lessons
**Purpose**: Individual lesson instances

```sql
CREATE TABLE course_lessons (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    course_id uuid,
    subject_id uuid,
    class_id uuid,
    room_id uuid,
    primary_teacher_id uuid,
    teacher_ids uuid[] DEFAULT ARRAY[]::uuid[],
    start_datetime timestamp NOT NULL,
    end_datetime timestamp NOT NULL,
    is_cancelled boolean DEFAULT false,
    notes text,
    school_id uuid NOT NULL
);
```

### course_enrollments
**Purpose**: Student enrollment in courses

```sql
CREATE TABLE course_enrollments (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    student_id uuid NOT NULL,
    course_id uuid NOT NULL,
    school_id uuid NOT NULL,
    assigned_at timestamp DEFAULT now(),
    start_date date DEFAULT CURRENT_DATE,
    end_date date DEFAULT CURRENT_DATE + interval '90 days',
    is_trial boolean DEFAULT false
);
```

## Contact Management

### contacts
**Purpose**: Contact information for profiles

```sql
CREATE TABLE contacts (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    profile_id uuid NOT NULL,
    profile_type text NOT NULL,
    type text NOT NULL, -- 'email', 'phone'
    label text,
    value text NOT NULL,
    is_primary boolean DEFAULT false,
    is_linked_to_user_login boolean DEFAULT false,
    status text DEFAULT 'valid',
    notes text,
    school_id uuid NOT NULL,
    created_at timestamp DEFAULT now()
);
```

## Stored Procedures

### save_lesson_attendance_bulk
Records lesson-level attendance in bulk, upserting the student daily log and creating a Klassenbuch diary entry when provided.

```sql
CREATE OR REPLACE FUNCTION public.save_lesson_attendance_bulk(
  p_lesson_id uuid,
  p_school_id uuid,
  p_attendance jsonb,                -- [{ "student_id": uuid, "status": text, "note": text }, ...]
  p_recorded_by uuid DEFAULT auth.uid(),
  p_date date DEFAULT NULL,
  p_diary_entry_text text DEFAULT NULL,
  p_diary_entry_type text DEFAULT 'attendance',
  p_diary_is_private boolean DEFAULT false
) RETURNS TABLE(student_id uuid, daily_log_id uuid, attendance_log_id uuid, status public.attendance_status)
LANGUAGE plpgsql SECURITY DEFINER AS $$
DECLARE
  v_day date;
  v_rec jsonb;
  v_student_id uuid;
  v_status_text text;
  v_status public.attendance_status;
  v_note text;
  v_daily_log_id uuid;
  v_attendance_log_id uuid;
BEGIN
  SELECT date_trunc('day', cl.start_datetime)::date
  INTO v_day
  FROM public.course_lessons cl
  WHERE cl.id = p_lesson_id AND cl.school_id = p_school_id;
  IF NOT FOUND THEN
    RAISE EXCEPTION 'Lesson % does not exist in school %', p_lesson_id, p_school_id;
  END IF;
  IF p_date IS NOT NULL THEN v_day := p_date; END IF;

  IF COALESCE(trim(p_diary_entry_text), '') <> '' THEN
    INSERT INTO public.lesson_diary_entries
      (lesson_id, school_id, entry_text, entry_type, is_private, created_by, updated_by)
    VALUES
      (p_lesson_id, p_school_id, p_diary_entry_text, COALESCE(p_diary_entry_type,'attendance'), COALESCE(p_diary_is_private,false), p_recorded_by, p_recorded_by);
  END IF;

  FOR v_rec IN SELECT jsonb_array_elements(p_attendance)
  LOOP
    v_student_id := (v_rec->>'student_id')::uuid;
    v_status_text := v_rec->>'status';
    v_note := v_rec->>'note';

    IF NOT EXISTS (
      SELECT 1 FROM unnest(enum_range(NULL::public.attendance_status)) e(s) WHERE e.s::text = v_status_text
    ) THEN
      RAISE EXCEPTION 'Invalid attendance status: %', v_status_text;
    END IF;
    v_status := v_status_text::public.attendance_status;

    INSERT INTO public.student_daily_log (
      student_id, school_id, date, created_at, updated_at, last_updated_by, presence_status, is_late
    ) VALUES (
      v_student_id, p_school_id, v_day, NOW(), NOW(), p_recorded_by,
      CASE
        WHEN v_status IN ('present','late') THEN 'present'::public.presence_status
        WHEN v_status = 'absent_excused' THEN 'absent_excused'::public.presence_status
        WHEN v_status = 'absent_unexcused' THEN 'absent_unexcused'::public.presence_status
        WHEN v_status = 'left_early' THEN 'left_early'::public.presence_status
        WHEN v_status = 'temporarily_offsite' THEN 'temporarily_offsite'::public.presence_status
        WHEN v_status = 'left_without_notice' THEN 'left_without_notice'::public.presence_status
        ELSE 'unmarked'::public.presence_status
      END,
      CASE WHEN v_status = 'late' THEN TRUE ELSE FALSE END
    )
    ON CONFLICT (student_id, school_id, date)
    DO UPDATE SET
      updated_at = NOW(),
      last_updated_by = p_recorded_by,
      presence_status = CASE
        WHEN EXCLUDED.presence_status IN ('present','absent_excused','absent_unexcused','left_early','temporarily_offsite','left_without_notice')::public.presence_status[] THEN EXCLUDED.presence_status
        ELSE student_daily_log.presence_status
      END,
      is_late = student_daily_log.is_late OR EXCLUDED.is_late
    RETURNING id INTO v_daily_log_id;

    INSERT INTO public.student_attendance_logs (
      lesson_id, student_id, daily_log_id, notes, recorded_by, "timestamp", status, school_id
    ) VALUES (
      p_lesson_id, v_student_id, v_daily_log_id, v_note, p_recorded_by, NOW(), v_status, p_school_id
    )
    ON CONFLICT (student_id, lesson_id)
    DO UPDATE SET
      daily_log_id = EXCLUDED.daily_log_id,
      notes = EXCLUDED.notes,
      recorded_by = EXCLUDED.recorded_by,
      "timestamp" = NOW(),
      status = EXCLUDED.status,
      school_id = EXCLUDED.school_id
    RETURNING id INTO v_attendance_log_id;

    student_id := v_student_id;
    daily_log_id := v_daily_log_id;
    attendance_log_id := v_attendance_log_id;
    status := v_status;
    RETURN NEXT;
  END LOOP;
END;
$$;
```

**Notes:**
- Uses UNIQUE (student_id, school_id, date) on `student_daily_log` to upsert daily records.
- Upserts `student_attendance_logs` on UNIQUE (student_id, lesson_id).
- When `p_diary_entry_text` is provided, a `lesson_diary_entries` record is created (entry_type defaults to 'attendance').

## Key Auth Functions

### Available Helper Functions
```sql
-- Get current user's profile ID
auth.get_profile_id() → uuid

-- Get current user's school ID  
auth.get_user_school_id() → uuid

-- Get user's role name
auth.get_user_role() → text

-- Get accessible children (for parents)
auth.get_accessible_children() → uuid[]

-- Get accessible class IDs
auth.get_accessible_class_ids() → uuid[]
```

## Common Query Patterns

### Get User Profile with Role
```sql
SELECT up.*, r.name as role_name
FROM user_profiles up
LEFT JOIN roles r ON up.role_id = r.id  
WHERE up.id = auth.get_profile_id();
```

### Get User's Multiple Roles
```sql
SELECT array_agg(r.name) as roles
FROM user_roles ur
JOIN roles r ON ur.role_id = r.id
WHERE ur.user_profile_id = auth.get_profile_id();
```

### Get Student's Daily Attendance
```sql
SELECT * FROM student_daily_log 
WHERE student_id = $1 
  AND date = $2 
  AND school_id = auth.get_user_school_id();
```

### Get Lesson Attendance
```sql
SELECT sal.*, up.first_name, up.last_name
FROM student_attendance_logs sal
JOIN user_profiles up ON sal.student_id = up.id
WHERE sal.lesson_id = $1
  AND sal.school_id = auth.get_user_school_id();
```

## Security Notes

- **Row Level Security (RLS)**: Most tables implement RLS policies based on `school_id`
- **Multi-tenancy**: All data is scoped by `school_id` for data isolation
- **Profile-based Access**: Use `auth.get_profile_id()` for user-specific queries
- **Family Access**: Parents can only access their authorized children via `family_member_child_links`

## Common Relationships Summary

```
user_profiles (central hub)
├── roles (via role_id)
├── user_roles (many-to-many roles)
├── structure_schools (via school_id)
├── contacts (profile contact info)
├── family_members (family relationships)
├── profile_info_student (student details)
├── profile_info_staff (staff details)
├── student_daily_log (daily attendance)
├── student_attendance_logs (lesson attendance)
└── course_enrollments (course assignments)
```
